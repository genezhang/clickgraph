# v0.5.2 API & Functions Analysis

**Date**: December 2024  
**Context**: Property expressions bug discovered. User raised two critical questions about v0.5.2 schema features.

---

## Executive Summary

**Question 1**: Do we need to enhance `/schemas` API for new schema features?  
**Answer**: **YES** - Current API returns minimal information, missing critical v0.5.2 features.

**Question 2**: Do `id()`, `type()`, `label()` functions work with polymorphic edges?  
**Answer**: **PARTIALLY** - `type()` and `label()` are NOT implemented at all. `id()` exists but untested with composite IDs.

---

## Issue 1: /schemas API Enhancement Needed

### Current API Response

**Endpoint**: `GET /schemas/{name}`

**Current response** (from `src/server/handlers.rs` lines 1001-1020):
```json
{
  "schema_name": "social_network",
  "node_types": 2,
  "relationship_types": 1,
  "nodes": ["User", "Post"],
  "relationships": ["FOLLOWS"]
}
```

### Missing Information for v0.5.2 Features

The API currently returns only:
- ✅ Node type names
- ✅ Relationship type names
- ✅ Counts

**What's MISSING** for v0.5.2 schema features:

1. **Polymorphic Edges**:
   - ❌ `type_column` field (which column stores the type)
   - ❌ List of possible types in the polymorphic table
   - ❌ Indication that a relationship is polymorphic

2. **Denormalized Properties**:
   - ❌ Which node properties are denormalized in edge tables
   - ❌ Property mappings for denormalized properties
   - ❌ Access patterns (e.g., `(u)-[r]->(v)` allows `r.user_name`)

3. **Composite IDs**:
   - ❌ Primary key columns (single vs composite)
   - ❌ Which columns form the composite ID
   - ❌ ID type information

4. **Property Expressions** (NEW):
   - ❌ Which properties are computed expressions
   - ❌ Expression definitions
   - ❌ Whether property is stored column or computed

### Recommended API Enhancement

**Enhanced Response Schema**:
```json
{
  "schema_name": "social_network",
  "node_types": 2,
  "relationship_types": 1,
  "nodes": {
    "User": {
      "table": "users_bench",
      "database": "brahmand",
      "id": {
        "type": "single",
        "columns": ["user_id"]
      },
      "properties": {
        "user_id": {
          "type": "stored",
          "column": "user_id"
        },
        "name": {
          "type": "stored",
          "column": "full_name"
        },
        "full_name_upper": {
          "type": "expression",
          "expression": "upper(full_name)"
        },
        "age_days": {
          "type": "expression",
          "expression": "dateDiff('day', registration_date, now())"
        }
      },
      "property_count": 10
    }
  },
  "relationships": {
    "FOLLOWS": {
      "type": "standard",
      "table": "user_follows_bench",
      "database": "brahmand",
      "id": {
        "type": "composite",
        "columns": ["follower_id", "followed_id"]
      },
      "from_column": "follower_id",
      "to_column": "followed_id",
      "properties": {
        "follow_date": {
          "type": "stored",
          "column": "follow_date"
        }
      },
      "denormalized_properties": []
    },
    "INTERACTS": {
      "type": "polymorphic",
      "table": "interactions",
      "database": "brahmand",
      "type_column": "interaction_type",
      "possible_types": ["LIKES", "SHARES", "COMMENTS"],
      "id": {
        "type": "composite",
        "columns": ["from_id", "to_id", "interaction_type"]
      },
      "from_column": "from_id",
      "to_column": "to_id",
      "denormalized_properties": {
        "from": ["name", "email"],
        "to": ["name", "email"]
      }
    }
  }
}
```

### API Implementation Changes Needed

**File**: `src/server/handlers.rs`

**Current implementation** (lines 1001-1020):
```rust
pub async fn get_schema_handler(
    axum::extract::Path(schema_name): axum::extract::Path<String>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<serde_json::Value>)> {
    match graph_catalog::get_graph_schema_by_name(&schema_name).await {
        Ok(schema) => {
            Ok(Json(serde_json::json!({
                "schema_name": schema_name,
                "node_types": schema.get_nodes_schemas().len(),
                "relationship_types": schema.get_relationships_schemas().len(),
                "nodes": schema.get_nodes_schemas().keys().collect::<Vec<_>>(),
                "relationships": schema.get_relationships_schemas().keys().collect::<Vec<_>>()
            })))
        }
        // ...
    }
}
```

**Enhanced implementation needed**:
```rust
pub async fn get_schema_handler(
    axum::extract::Path(schema_name): axum::extract::Path<String>,
) -> Result<Json<serde_json::Value>, (StatusCode, Json<serde_json::Value>)> {
    match graph_catalog::get_graph_schema_by_name(&schema_name).await {
        Ok(schema) => {
            let mut nodes = serde_json::Map::new();
            for (name, node_schema) in schema.get_nodes_schemas() {
                let mut properties = serde_json::Map::new();
                for (prop_name, prop_mapping) in &node_schema.property_mappings {
                    // Detect if property is expression or stored column
                    let is_expression = is_clickhouse_expression(prop_mapping);
                    properties.insert(
                        prop_name.clone(),
                        serde_json::json!({
                            "type": if is_expression { "expression" } else { "stored" },
                            if is_expression { "expression" } else { "column" }: prop_mapping
                        })
                    );
                }
                
                nodes.insert(
                    name.clone(),
                    serde_json::json!({
                        "table": node_schema.view_name,
                        "database": node_schema.database,
                        "id": format_identifier(&node_schema.primary_keys),
                        "properties": properties,
                        "property_count": properties.len()
                    })
                );
            }

            let mut relationships = serde_json::Map::new();
            for (name, rel_schema) in schema.get_relationships_schemas() {
                let rel_info = serde_json::json!({
                    "type": if rel_schema.type_column.is_some() { "polymorphic" } else { "standard" },
                    "table": rel_schema.view_name,
                    "database": rel_schema.database,
                    "id": format_identifier(&rel_schema.primary_keys),
                    "from_column": rel_schema.from_id_column,
                    "to_column": rel_schema.to_id_column,
                    "type_column": rel_schema.type_column,
                    "denormalized_properties": rel_schema.denormalized_properties
                });
                relationships.insert(name.clone(), rel_info);
            }

            Ok(Json(serde_json::json!({
                "schema_name": schema_name,
                "node_types": nodes.len(),
                "relationship_types": relationships.len(),
                "nodes": nodes,
                "relationships": relationships
            })))
        }
        // ...
    }
}

// Helper to detect ClickHouse expressions
fn is_clickhouse_expression(value: &str) -> bool {
    // Check for function calls (has parentheses and likely ClickHouse function)
    value.contains('(') && value.contains(')')
}
```

### Priority

**HIGH** - API is external contract, users/tools depend on it for schema introspection.

**Recommended**: Implement as part of v0.5.2 to ensure complete feature exposure.

---

## Issue 2: id(), type(), label() Functions Missing/Incomplete

### Current Status

#### 1. `id()` Function

**Status**: **PARTIALLY IMPLEMENTED** ⚠️

**Documentation** (`docs/wiki/Cypher-Functions.md` lines 730-740):
```cypher
-- Get node ID
MATCH (u:User)
RETURN id(u), u.name

-- Note: id() returns internal ID, use properties for business keys
MATCH (u:User)
RETURN u.user_id AS business_id, u.name
```

**Reality Check**:
- ✅ Documented
- ⚠️ **NOT in function_registry.rs** - not mapped to ClickHouse
- ❓ **Untested** with composite IDs (v0.5.2 feature)
- ❓ **Untested** with polymorphic edges

**Issue with Composite IDs**:
```cypher
-- If User has composite ID: (user_id, tenant_id)
MATCH (u:User)
RETURN id(u)

-- What should this return?
-- Option 1: Single concatenated value? "user123_tenant456"
-- Option 2: Array? [123, "tenant456"]
-- Option 3: Tuple? "(123, 'tenant456')"
-- Option 4: Error?
```

**Current behavior**: Likely **BROKEN** or **UNDEFINED** for composite IDs.

#### 2. `type()` Function

**Status**: **NOT IMPLEMENTED** ❌

**Documentation** (`docs/wiki/Cypher-Functions.md` lines 718-725):
```cypher
-- Check edge type
MATCH ()-[e]->()
RETURN type(e) AS edge_type, count(*) AS count
GROUP BY type(e)
```

**Reality Check**:
- ✅ Documented
- ❌ **NOT in function_registry.rs**
- ❌ **NOT implemented anywhere**
- ❌ **Fake documentation** - claims it works but doesn't exist

**Critical Issue with Polymorphic Edges**:

In v0.5.2, polymorphic edges store type in a column:

```yaml
# Schema example
relationships:
  - name: INTERACTS
    view_name: interactions
    type_column: interaction_type  # ← Type is stored HERE
    from_id_column: from_id
    to_id_column: to_id
```

**Expected behavior**:
```cypher
-- User expects type() to map to type_column
MATCH (u:User)-[r:INTERACTS]->(p:Post)
RETURN type(r)

-- Should generate SQL:
SELECT interactions.interaction_type
FROM interactions
```

**Current behavior**: **BROKEN** - function doesn't exist at all.

#### 3. `label()` Function

**Status**: **NOT IMPLEMENTED** ❌

**Documentation** (`docs/wiki/Cypher-Functions.md` line 718):
```cypher
-- Check node label
MATCH (n)
RETURN CASE
  WHEN n:User THEN 'User'
  WHEN n:Post THEN 'Post'
  ELSE 'Other'
END AS node_type
```

**Reality Check**:
- ⚠️ Documented only as workaround (CASE expression)
- ❌ **NOT in function_registry.rs**
- ❌ **No direct `label()` function**
- ⚠️ Users expect Neo4j behavior: `label(n)` returns label string

**Neo4j behavior**:
```cypher
MATCH (n)
RETURN label(n)  -- Returns "User", "Post", etc.
```

**ClickGraph**: No such function exists.

### Functions Implementation Needed

#### Fix 1: Implement `type()` Function

**Priority**: **CRITICAL** for polymorphic edges

**Location**: `src/clickhouse_query_generator/function_registry.rs`

**Implementation**:
```rust
// Add to FUNCTION_MAPPINGS
m.insert("type", FunctionMapping {
    neo4j_name: "type",
    clickhouse_name: "",  // Special handling needed
    arg_transform: None,
});
```

**Special handling required** in `function_translator.rs`:
```rust
pub fn translate_scalar_function(
    fn_call: &ScalarFnCall,
) -> Result<String, ClickhouseQueryGeneratorError> {
    let fn_name_lower = fn_call.name.to_lowercase();
    
    // Special handling for type()
    if fn_name_lower == "type" {
        // Need relationship context to determine:
        // 1. Is this a standard relationship? → Return literal type name
        // 2. Is this a polymorphic relationship? → Return type_column value
        
        // Get relationship alias from argument
        let rel_alias = extract_relationship_alias(&fn_call.args[0])?;
        
        // Look up in schema - need schema context passed through!
        let schema = get_current_schema()?;
        let rel_schema = schema.get_relationship_schema_for_alias(rel_alias)?;
        
        if let Some(type_column) = &rel_schema.type_column {
            // Polymorphic: return column value
            Ok(format!("{}.{}", rel_alias, type_column))
        } else {
            // Standard: return literal type name
            Ok(format!("'{}'", rel_schema.type_name))
        }
    } else {
        // Existing function mapping logic...
    }
}
```

**Challenge**: Need to pass schema context through the entire SQL generation pipeline.

#### Fix 2: Implement `label()` Function

**Priority**: **MEDIUM** - less commonly used, workaround exists

**Similar approach** to `type()`:
```rust
// label(n) returns node label
if fn_name_lower == "label" {
    let node_alias = extract_node_alias(&fn_call.args[0])?;
    let schema = get_current_schema()?;
    let node_schema = schema.get_node_schema_for_alias(node_alias)?;
    
    // Return literal label
    Ok(format!("'{}'", node_schema.label))
}
```

#### Fix 3: Fix `id()` for Composite IDs

**Priority**: **HIGH** - composite IDs are v0.5.2 feature

**Options**:

**Option A: Concatenate with separator**
```rust
if fn_name_lower == "id" {
    let alias = extract_alias(&fn_call.args[0])?;
    let schema = get_current_schema()?;
    let entity_schema = schema.get_entity_schema_for_alias(alias)?;
    
    match &entity_schema.primary_keys {
        Identifier::Single(col) => {
            Ok(format!("{}.{}", alias, col))
        }
        Identifier::Composite(cols) => {
            // Concatenate with '|' separator
            let col_refs: Vec<String> = cols.iter()
                .map(|c| format!("{}.{}", alias, c))
                .collect();
            Ok(format!("concat({})", col_refs.join(", '|', ")))
        }
    }
}
```

**Option B: Return array (ClickHouse array type)**
```rust
Identifier::Composite(cols) => {
    let col_refs: Vec<String> = cols.iter()
        .map(|c| format!("{}.{}", alias, c))
        .collect();
    Ok(format!("[{}]", col_refs.join(", ")))
}
```

**Recommendation**: **Option A** (concatenated string) - more compatible with Neo4j expectations.

### Schema Context Threading Required

**MAJOR ARCHITECTURAL ISSUE**: Functions need schema context, but SQL generation is currently schema-agnostic.

**Current flow**:
```
Cypher Query
  ↓
Parser (creates AST)
  ↓
Planner (schema-aware, creates LogicalPlan)
  ↓
SQL Generator (schema-agnostic! Uses only LogicalPlan)
  ↓
ClickHouse SQL
```

**Problem**: `type()`, `label()`, `id()` need schema information in SQL generation phase.

**Solution Options**:

**Option 1: Thread schema through LogicalPlan**
- Add `schema: Arc<GraphSchema>` field to LogicalPlan
- Pass schema to SQL generator
- **Pro**: Clean separation
- **Con**: Large refactor

**Option 2: Expand functions early in planner**
- Replace `type(r)` with actual column/literal during planning
- SQL generator sees already-expanded expression
- **Pro**: Minimal SQL generator changes
- **Con**: Function calls lost in LogicalPlan (harder to debug)

**Option 3: Global schema context (current architecture)**
- SQL generator can call `get_current_schema()` when needed
- **Pro**: Easy to implement
- **Con**: Breaks pure functional style

**Recommendation**: **Option 2** (early expansion) - aligns with current architecture.

### Implementation in Query Planner

**Location**: `src/query_planner/analyzer/` (new pass: `function_expansion.rs`)

```rust
/// Expand schema-dependent functions before SQL generation
pub fn expand_schema_functions(
    plan: LogicalPlan,
    schema: &GraphSchema,
) -> Result<LogicalPlan, PlanningError> {
    match plan {
        LogicalPlan::Return(mut ret) => {
            // Walk return expressions
            for expr in &mut ret.expressions {
                expand_function_in_expr(expr, schema)?;
            }
            Ok(LogicalPlan::Return(ret))
        }
        // ... other plan types
    }
}

fn expand_function_in_expr(
    expr: &mut LogicalExpr,
    schema: &GraphSchema,
) -> Result<(), PlanningError> {
    if let LogicalExpr::ScalarFnCall(fn_call) = expr {
        match fn_call.name.to_lowercase().as_str() {
            "type" => {
                // Replace with PropertyAccess or Literal
                let rel_alias = extract_alias(&fn_call.args[0])?;
                let rel_schema = schema.get_relationship_schema(rel_alias)?;
                
                *expr = if let Some(type_col) = &rel_schema.type_column {
                    // Polymorphic: replace with property access
                    LogicalExpr::PropertyAccessExp(PropertyAccess {
                        table_alias: TableAlias(rel_alias.clone()),
                        column: ColumnName(type_col.clone()),
                    })
                } else {
                    // Standard: replace with literal
                    LogicalExpr::Literal(Literal::String(rel_schema.type_name.clone()))
                };
            }
            "label" => {
                // Similar to type()
            }
            "id" => {
                // Replace with PropertyAccess (single) or concat expr (composite)
            }
            _ => {}
        }
    }
    Ok(())
}
```

---

## Comprehensive Fix Plan for v0.5.2

### Phase 1: Property Expressions Bug (CRITICAL)

**Issue**: SQL generation prefixes ALL property accesses with table alias, breaking expressions with functions.

**File**: `src/clickhouse_query_generator/to_sql.rs` (lines 55-57)

**Current**:
```rust
LogicalExpr::PropertyAccessExp(prop) => {
    Ok(format!("{}.{}", prop.table_alias.0, prop.column.0))
}
```

**Fix**:
```rust
LogicalExpr::PropertyAccessExp(prop) => {
    // Detect if column is actually a ClickHouse expression
    if is_clickhouse_expression(&prop.column.0) {
        // Don't prefix expressions - they already contain table references
        Ok(prop.column.0.clone())
    } else {
        // Prefix simple column names
        Ok(format!("{}.{}", prop.table_alias.0, prop.column.0))
    }
}

fn is_clickhouse_expression(value: &str) -> bool {
    // Check for function calls or operators
    value.contains('(') && value.contains(')')
        || value.contains('+') || value.contains('-') 
        || value.contains('*') || value.contains('/')
        || value.contains('CASE')
}
```

**Estimated effort**: 2-3 hours  
**Risk**: LOW - isolated change with comprehensive test coverage

### Phase 2: Implement type(), label(), id() Functions (HIGH)

**2.1 Add function expansion pass to planner**

**File**: `src/query_planner/analyzer/function_expansion.rs` (NEW)

**Implementation**: ~200 lines
- Walk LogicalPlan expressions
- Find ScalarFnCall for type(), label(), id()
- Replace with PropertyAccess or Literal based on schema
- Handle composite IDs with concat expression

**Estimated effort**: 1 day  
**Risk**: MEDIUM - new analyzer pass, needs testing

**2.2 Add tests for functions**

**File**: `tests/integration/test_schema_functions.py` (NEW)

**Tests needed**:
- `type()` with standard relationships → returns literal
- `type()` with polymorphic edges → returns column value
- `label()` with nodes → returns label string
- `id()` with single ID → returns column
- `id()` with composite ID → returns concatenated string

**Estimated effort**: 4 hours  
**Risk**: LOW - integration tests

### Phase 3: Enhance /schemas API (MEDIUM)

**File**: `src/server/handlers.rs` (modify `get_schema_handler`)

**Implementation**:
- Add helper `is_clickhouse_expression()`
- Build detailed node/relationship info objects
- Include ID type, property types, polymorphic indicators
- Include denormalized property info

**Estimated effort**: 4-6 hours  
**Risk**: LOW - additive change, backwards compatible

**Testing**: Manual API testing + update API documentation

### Phase 4: Documentation Updates (MEDIUM)

**Files to update**:
1. `docs/wiki/Cypher-Functions.md` - Fix type(), label(), id() docs
2. `docs/wiki/Schema-Configuration-Advanced.md` - Fix property expressions examples
3. `docs/api.md` - Document enhanced /schemas response
4. `STATUS.md` - Update feature status
5. `CHANGELOG.md` - Add v0.5.2 changes

**Estimated effort**: 3-4 hours  
**Risk**: LOW

---

## Testing Strategy

### Property Expressions Tests
- ✅ **Already created**: 28 comprehensive tests
- ⏳ **Re-run after fix**: Expect 28/28 passing (currently 7/28)

### Function Tests (NEW)
**File**: `tests/integration/test_schema_functions.py`

**Test cases**:
1. `type()` with standard relationship
2. `type()` with polymorphic relationship
3. `label()` with nodes
4. `id()` with single-column ID
5. `id()` with composite ID
6. Functions in WHERE clauses
7. Functions in RETURN clauses
8. Functions in ORDER BY
9. Mixed function calls

**Estimated**: 15-20 test cases

### API Tests (NEW)
**File**: `tests/integration/test_schemas_api.py`

**Test cases**:
1. GET /schemas - list schemas
2. GET /schemas/{name} - get schema details
3. Verify property types (stored vs expression)
4. Verify ID types (single vs composite)
5. Verify polymorphic relationship info
6. Verify denormalized properties

**Estimated**: 8-10 test cases

---

## Timeline Estimate

| Phase | Task | Effort | Dependencies |
|-------|------|--------|--------------|
| 1 | Fix property expressions SQL generation | 3 hours | None |
| 1 | Re-test property expressions (28 tests) | 1 hour | Fix complete |
| 2 | Implement function expansion pass | 8 hours | None |
| 2 | Add function tests (15-20 tests) | 4 hours | Expansion pass |
| 3 | Enhance /schemas API | 6 hours | None |
| 3 | Test API manually | 2 hours | API changes |
| 4 | Update documentation (5 files) | 4 hours | All features complete |
| - | **TOTAL** | **28 hours** | **~3.5 days** |

**Recommendation**: Fix all three issues together as comprehensive v0.5.2 release.

---

## Risk Assessment

### Property Expressions Fix
- **Risk**: LOW
- **Impact if unfixed**: CRITICAL (75% of feature broken)
- **Test coverage**: EXCELLENT (28 tests)

### Function Implementation
- **Risk**: MEDIUM (new analyzer pass)
- **Impact if unfixed**: HIGH (documented features don't work)
- **Test coverage**: GOOD (will create comprehensive tests)

### API Enhancement
- **Risk**: LOW (additive change)
- **Impact if unfixed**: MEDIUM (users can't introspect schema features)
- **Test coverage**: MEDIUM (manual testing)

---

## Recommendations

1. **Fix Property Expressions FIRST** (3 hours)
   - Most critical, best tested, lowest risk
   - Blocks other work

2. **Implement Functions SECOND** (12 hours)
   - High priority for v0.5.2
   - Enables polymorphic edge queries
   - Medium risk, needs careful testing

3. **Enhance API THIRD** (8 hours)
   - Important for completeness
   - Low risk, low priority
   - Can ship v0.5.2 without this if time-constrained

4. **Document Everything** (4 hours)
   - **CRITICAL**: Fix fake documentation
   - Update Cypher Functions docs
   - Create feature notes

**Total v0.5.2 effort**: 3-4 days for comprehensive release.

**Minimum viable v0.5.2**: 1-2 days (property expressions + functions only).

---

## Next Steps

**Immediate**:
1. ✅ Property expressions test infrastructure created
2. ✅ Bug documented (PROPERTY_EXPRESSIONS_TEST_RESULTS.md)
3. ✅ API and function analysis complete (this document)
4. ⏳ **START**: Fix property expressions SQL generation
5. ⏳ Re-test property expressions (expect 28/28)
6. ⏳ Implement function expansion pass
7. ⏳ Test functions
8. ⏳ Enhance API (if time permits)
9. ⏳ Update all documentation
10. ⏳ Release v0.5.2

**User quote**: "Let's take time to fix. We don't have a set schedule for v0.5.2 release."

**Strategy**: Fix all three issues comprehensively for robust v0.5.2 release.
