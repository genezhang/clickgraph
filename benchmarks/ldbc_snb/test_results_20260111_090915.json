{
  "timestamp": "2026-01-11T09:09:15.182590",
  "results": [
    {
      "category": "interactive-short",
      "query": "short-1",
      "status": "PASS",
      "error": null,
      "rows": 0
    },
    {
      "category": "interactive-short",
      "query": "short-2",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 60. DB::Exception: Unknown table expression identifier 'ldbc.with_message_messageCreationDate_messageId_cte_1' in scope SELECT start_node.CommentId AS start_id, start_node.CommentId AS end_id, 0 AS hop_count, CAST([], 'Array(Tuple(UInt64, UInt64))') AS path_edges, CAST([], 'Array(String)') AS path_relationships, [start_node.CommentId] AS path_nodes FROM ldbc.with_message_messageCreationDate_messageId_cte_1 AS start_node. (UNKNOWN_TABLE) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "interactive-short",
      "query": "short-3",
      "status": "PASS",
      "error": null,
      "rows": 0
    },
    {
      "category": "interactive-short",
      "query": "short-4",
      "status": "PASS",
      "error": null,
      "rows": 0
    },
    {
      "category": "interactive-short",
      "query": "short-5",
      "status": "PASS",
      "error": null,
      "rows": 0
    },
    {
      "category": "interactive-short",
      "query": "short-6",
      "status": "PASS",
      "error": null,
      "rows": 0
    },
    {
      "category": "interactive-short",
      "query": "short-7",
      "status": "PASS",
      "error": null,
      "rows": 0
    },
    {
      "category": "interactive-complex",
      "query": "complex-1",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 164. DB::Exception: Cannot modify 'max_recursive_cte_evaluation_depth' setting in readonly mode. (READONLY) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-10",
      "status": "FAIL",
      "error": "Query syntax error: Unexpected tokens after query: ([p IN posts WHERE (p)-[:HAS_TAG]->()<-[:HAS_INTEREST]-(person)]) AS commonPostCount\nRETURN friend.id AS personId,\n       friend.firstName AS personFirstName,\n       friend.lastName AS personLastName,\n       commonPostCount - (postCount - commonPostCount) AS commonInterestScore,\n       friend.gender AS personGender,\n       city.name AS personCityName\nORDER BY commonInterestScore DESC, personId ASC\nLIMIT 10\nUnparsed input: ([p IN posts WHERE (p)-[:HAS_TAG]->()<-[:HAS_INTEREST]-(person)]) AS commonPostCount\nRETURN friend.id AS personId,\n       friend.firstName AS personFirstName,\n       friend.lastName AS personLastName,\n       commonPostCount - (postCount - commonPostCount) AS commonInterestScore,\n       friend.gender AS personGender,\n       city.name AS personCityName\nORDER BY commonInterestScore DESC, personId ASC\nLIMIT 10\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-11",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression or function identifier `person` in scope SELECT person.firstName AS `person.firstName`, person.birthday AS `person.birthday`, person.locationIP AS `person.locationIP`, person.lastName AS `person.lastName`, person.gender AS `person.gender`, person.browserUsed AS `person.browserUsed`, person.creationDate AS `person.creationDate`, person.id AS `person.id`, friend.firstName AS `friend.firstName`, friend.birthday AS `friend.birthday`, friend.locationIP AS `friend.locationIP`, friend.lastName AS `friend.lastName`, friend.gender AS `friend.gender`, friend.browserUsed AS `friend.browserUsed`, friend.creationDate AS `friend.creationDate`, friend.id AS `friend.id` FROM vlp_cte15 AS vlp15 INNER JOIN ldbc.Person AS person ON vlp15.start_id = person.id INNER JOIN ldbc.Person AS friend ON vlp15.end_id = friend.id WHERE NOT (person = friend). Maybe you meant: ['personId']. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-12",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression or table expression identifier `tags` in scope SELECT friend.id AS personId, friend.firstName AS personFirstName, friend.lastName AS personLastName, groupArrayDistinct(tag.name) AS tagNames, countDistinct(comment.id) AS replyCount FROM ldbc.Comment AS comment INNER JOIN ldbc.Comment_hasCreator_Person AS t59 ON t59.CommentId = comment.id INNER JOIN ldbc.Person AS friend ON friend.id = t59.PersonId INNER JOIN ldbc.Comment_replyOf_Post AS t60 ON t60.CommentId = comment.id INNER JOIN ldbc.Post AS t57 ON t57.id = t60.PostId INNER JOIN ldbc.Post_hasTag_Tag AS t61 ON t61.PostId = t57.id INNER JOIN ldbc.Tag AS tag ON tag.id = t61.TagId WHERE tag.id IN (tags) GROUP BY friend.id, friend.firstName, friend.lastName ORDER BY replyCount DESC, toInt64(personId) ASC LIMIT 20. Maybe you meant: ['tag']. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-13",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Identifier 'start_node.Person1Id' cannot be resolved from table with name start_node. In scope SELECT start_node.Person1Id AS start_id, end_node.id AS end_id, 1 AS hop_count, [(rel.Person1Id, rel.Person2Id)] AS path_edges, ['KNOWS::Person::Person'] AS path_relationships, [start_node.Person1Id, end_node.id] AS path_nodes, start_node.id AS start_id FROM ldbc.Person AS start_node INNER JOIN ldbc.Person_knows_Person AS rel ON start_node.Person1Id = rel.Person1Id INNER JOIN ldbc.Person AS end_node ON rel.Person2Id = end_node.id WHERE start_node.id = 8796093022390. Maybe you meant: ['start_node.firstName']. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-14",
      "status": "FAIL",
      "error": "Query syntax error: Unexpected tokens after query: CALL gds.graph.project.cypher(\n  apoc.create.uuidBase64(),\n  'MATCH (p:Person) RETURN id(p) AS id',\n  'MATCH\n      (pA:Person)-[knows:KNOWS]-(pB:Person),\n      (pA)<-[:HAS_CREATOR]-(m1:Message)-[r:REPLY_OF]-(m2:Message)-[:HAS_CREATOR]->(pB)\n    WITH\n      id(pA) AS source,\n      id(pB) AS target,\n      count(r) AS numInteractions\n    RETURN\n      source,\n      target,\n      CASE WHEN round(40-sqrt(numInteractions)) > 1 THEN round(40-sqrt(numInteractions)) ELSE 1 END AS weight\n  '\n)\nYIELD graphName\n\nWITH person1, person2, graphName\n\nCALL gds.shortestPath.dijkstra.stream(\n    graphName, {sourceNode: person1, targetNode: person2, relationshipWeightProperty: 'weight'}\n)\nYIELD index, sourceNode, targetNode, totalCost, nodeIds, costs, path\n\nWITH path, totalCost, graphName\n\nCALL gds.graph.drop(graphName, false)\nYIELD graphName as graphNameremoved\n\nRETURN [person IN nodes(path) | person.id] AS personIdsInPath, totalCost AS pathWeight\nLIMIT 1\nUnparsed input: CALL gds.graph.project.cypher(\n  apoc.create.uuidBase64(),\n  'MATCH (p:Person) RETURN id(p) AS id',\n  'MATCH\n      (pA:Person)-[knows:KNOWS]-(pB:Person),\n      (pA)<-[:HAS_CREATOR]-(m1:Message)-[r:REPLY_OF]-(m2:Message)-[:HAS_CREATOR]->(pB)\n    WITH\n      id(pA) AS source,\n      id(pB) AS target,\n      count(r) AS numInteractions\n    RETURN\n      source,\n      target,\n      CASE WHEN round(40-sqrt(numInteractions)) > 1 THEN round(40-sqrt(numInteractions)) ELSE 1 END AS weight\n  '\n)\nYIELD graphName\n\nWITH person1, person2, graphName\n\nCALL gds.shortestPath.dijkstra.stream(\n    graphName, {sourceNode: person1, targetNode: person2, relationshipWeightProperty: 'weight'}\n)\nYIELD index, sourceNode, targetNode, totalCost, nodeIds, costs, path\n\nWITH path, totalCost, graphName\n\nCALL gds.graph.drop(graphName, false)\nYIELD graphName as graphNameremoved\n\nRETURN [person IN nodes(path) | person.id] AS personIdsInPath, totalCost AS pathWeight\nLIMIT 1\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-2",
      "status": "PASS",
      "error": null,
      "rows": 0
    },
    {
      "category": "interactive-complex",
      "query": "complex-3",
      "status": "FAIL",
      "error": "ClickGraph Error: AnalyzerError: Property 'creationDate' not found on node 'message'",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-4",
      "status": "FAIL",
      "error": "ClickGraph Error: Invalid render plan: No FROM clause found. This usually indicates missing table information or incomplete query planning.",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-5",
      "status": "FAIL",
      "error": "ClickGraph Error: Invalid render plan: Cannot find ID column for alias 'forum' needed for GROUP BY aggregation. This alias may come from a CTE that hasn't been properly registered.",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-6",
      "status": "FAIL",
      "error": "ClickGraph Error: Invalid render plan: No FROM clause found. This usually indicates missing table information or incomplete query planning.",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-7",
      "status": "FAIL",
      "error": "ClickGraph Error: AnalyzerError: Property 'likeTime' not found on node 'latestLike'",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-8",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression or function identifier `t85.PersonId` in scope SELECT person.id AS personId, person.firstName AS personFirstName, person.lastName AS personLastName, comment.creationDate AS commentCreationDate, comment.id AS commentId, comment.content AS commentContent FROM ldbc.Message_hasCreator_Person AS t83 INNER JOIN ldbc.Person AS person ON person.id = t85.PersonId INNER JOIN ldbc.Comment_hasCreator_Person AS t85 ON t85.CommentId = comment.id INNER JOIN ldbc.Comment_replyOf_Message AS t84 ON t84.MessageId = t82.id INNER JOIN ldbc.Comment AS comment ON comment.id = t84.CommentId WHERE start.id = 143 ORDER BY commentCreationDate DESC, commentId ASC LIMIT 20. Maybe you meant: ['t83.PersonId']. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-9",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression identifier `friends` in scope WITH RECURSIVE with_friends_cte AS (SELECT root.firstName AS `root.firstName`, root.birthday AS `root.birthday`, root.locationIP AS `root.locationIP`, root.lastName AS `root.lastName`, root.gender AS `root.gender`, root.browserUsed AS `root.browserUsed`, root.creationDate AS `root.creationDate`, root.id AS `root.id`, friend.firstName AS `friend.firstName`, friend.birthday AS `friend.birthday`, friend.locationIP AS `friend.locationIP`, friend.lastName AS `friend.lastName`, friend.gender AS `friend.gender`, friend.browserUsed AS `friend.browserUsed`, friend.creationDate AS `friend.creationDate`, friend.id AS `friend.id` FROM vlp_cte31 AS vlp31 INNER JOIN ldbc.Person AS root ON vlp31.start_id = root.id INNER JOIN ldbc.Person AS friend ON vlp31.end_id = friend.id WHERE NOT (friend = root) UNION ALL SELECT friend.firstName AS `friend.firstName`, friend.birthday AS `friend.birthday`, friend.locationIP AS `friend.locationIP`, friend.lastName AS `friend.lastName`, friend.gender AS `friend.gender`, friend.browserUsed AS `friend.browserUsed`, friend.creationDate AS `friend.creationDate`, friend.id AS `friend.id`, root.firstName AS `root.firstName`, root.birthday AS `root.birthday`, root.locationIP AS `root.locationIP`, root.lastName AS `root.lastName`, root.gender AS `root.gender`, root.browserUsed AS `root.browserUsed`, root.creationDate AS `root.creationDate`, root.id AS `root.id` FROM vlp_cte32 AS vlp32 INNER JOIN ldbc.Person AS friend ON vlp32.start_id = friend.id INNER JOIN ldbc.Person AS root ON vlp32.end_id = root.id WHERE NOT (friend = root)), vlp_cte29 AS (SELECT * FROM (WITH RECURSIVE vlp_cte29 AS (SELECT start_node.id AS start_id, end_node.id AS end_id, 1 AS hop_count, [(rel.Person1Id, rel.Person2Id)] AS path_edges, ['KNOWS::Person::Person'] AS path_relationships, [start_node.id, end_node.id] AS path_nodes FROM ldbc.Person AS start_node INNER JOIN ldbc.Person_knows_Person AS rel ON start_node.id = rel.Person1Id INNER JOIN ldbc.Person AS end_node ON rel.Person2Id = end_node.id WHERE (start_node.id = 4398046511268) AND (NOT (rel.Person2Id = rel.Person1Id)) UNION ALL SELECT vp.start_id, end_node.id AS end_id, vp.hop_count + 1 AS hop_count, arrayConcat(vp.path_edges, [(rel.Person1Id, rel.Person2Id)]) AS path_edges, arrayConcat(vp.path_relationships, ['KNOWS::Person::Person']) AS path_relationships, arrayConcat(vp.path_nodes, [end_node.id]) AS path_nodes FROM vlp_cte29 AS vp INNER JOIN ldbc.Person AS current_node ON vp.end_id = current_node.id INNER JOIN ldbc.Person_knows_Person AS rel ON current_node.id = rel.Person1Id INNER JOIN ldbc.Person AS end_node ON rel.Person2Id = end_node.id WHERE (vp.hop_count < 2) AND (NOT has(vp.path_edges, (rel.Person1Id, rel.Person2Id))) AND (NOT (rel.Person2Id = rel.Person1Id))) SELECT * FROM vlp_cte29)), vlp_cte30 AS (SELECT * FROM (WITH RECURSIVE vlp_cte30 AS (SELECT start_node.id AS start_id, end_node.id AS end_id, 1 AS hop_count, [(rel.Person1Id, rel.Person2Id)] AS path_edges, ['KNOWS::Person::Person'] AS path_relationships, [start_node.id, end_node.id] AS path_nodes FROM ldbc.Person AS start_node INNER JOIN ldbc.Person_knows_Person AS rel ON start_node.id = rel.Person1Id INNER JOIN ldbc.Person AS end_node ON rel.Person2Id = end_node.id WHERE (end_node.id = 4398046511268) AND (NOT (rel.Person1Id = rel.Person2Id)) UNION ALL SELECT vp.start_id, end_node.id AS end_id, vp.hop_count + 1 AS hop_count, arrayConcat(vp.path_edges, [(rel.Person1Id, rel.Person2Id)]) AS path_edges, arrayConcat(vp.path_relationships, ['KNOWS::Person::Person']) AS path_relationships, arrayConcat(vp.path_nodes, [end_node.id]) AS path_nodes FROM vlp_cte30 AS vp INNER JOIN ldbc.Person AS current_node ON vp.end_id = current_node.id INNER JOIN ldbc.Person_knows_Person AS rel ON current_node.id = rel.Person1Id INNER JOIN ldbc.Person AS end_node ON rel.Person2Id = end_node.id WHERE (vp.hop_count < 2) AND (NOT has(vp.path_edges, (rel.Person1Id, rel.Person2Id))) AND (end_node.id = 4398046511268) AND (NOT (rel.Person1Id = rel.Person2Id))) SELECT * FROM vlp_cte30)) SELECT friend.id AS personId, friend.firstName AS personFirstName, friend.lastName AS personLastName, message.id AS commentOrPostId, coalesce(message.content, message.imageFile) AS commentOrPostContent, message.creationDate AS commentOrPostCreationDate FROM ldbc.Message AS message INNER JOIN ldbc.Message_hasCreator_Person AS t87 ON t87.MessageId = message.id INNER JOIN ldbc.Person AS friend ON friend.id = t87.PersonId ARRAY JOIN friends AS friend WHERE message.creationDate < 1289908800000 ORDER BY commentOrPostCreationDate DESC, message.id ASC LIMIT 20 SETTINGS max_recursive_cte_evaluation_depth = 100. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-1",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 43. DB::Exception: Illegal type Int64 of argument of function toYear. Should be Date, Date32, DateTime or DateTime64: In scope with_message_totalMessageCount_year_cte_1 AS (SELECT message.browserUsed AS message_browserUsed, message.content AS message_content, message.creationDate AS message_creationDate, message.id AS message_id, message.imageFile AS message_imageFile, message.language AS message_language, message.length AS message_length, message.locationIP AS message_locationIP, message.type AS message_type, toYear(message.creationDate) AS year FROM ldbc.Message AS message WHERE ((message.creationDate < 'datetime(\\\\'2011-12-01T00:00:00.000\\\\')') AND (message.content IS NOT NULL)) AND ((message.creationDate < 'datetime(\\\\'2011-12-01T00:00:00.000\\\\')') AND (message.content IS NOT NULL))). (ILLEGAL_TYPE_OF_ARGUMENT) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-10",
      "status": "FAIL",
      "error": "Query syntax error: Unexpected tokens after query: (startPerson, {\n\trelationshipFilter: \"KNOWS\",\n    minLevel: 1,\n    maxLevel: $minPathDistance-1\n})\nYIELD node\nWITH startPerson, collect(DISTINCT node) AS nodesCloserThanMinPathDistance\nCALL apoc.path.subgraphNodes(startPerson, {\n\trelationshipFilter: \"KNOWS\",\n    minLevel: 1,\n    maxLevel: $maxPathDistance\n})\nYIELD node\nWITH nodesCloserThanMinPathDistance, collect(DISTINCT node) AS nodesCloserThanMaxPathDistance\nWITH [n IN nodesCloserThanMaxPathDistance WHERE NOT n IN nodesCloserThanMinPathDistance] AS expertCandidatePersons\nUNWIND expertCandidatePersons AS expertCandidatePerson\nMATCH\n  (expertCandidatePerson)-[:IS_LOCATED_IN]->(:City)-[:IS_PART_OF]->(:Country {name: $country}),\n  (expertCandidatePerson)<-[:HAS_CREATOR]-(message:Message)-[:HAS_TAG]->(:Tag)-[:HAS_TYPE]->\n  (:TagClass {name: $tagClass})\nMATCH\n  (message)-[:HAS_TAG]->(tag:Tag)\nRETURN\n  expertCandidatePerson.id,\n  tag.name,\n  count(DISTINCT message) AS messageCount\nORDER BY\n  messageCount DESC,\n  tag.name ASC,\n  expertCandidatePerson.id ASC\nLIMIT 100\nUnparsed input: (startPerson, {\n\trelationshipFilter: \"KNOWS\",\n    minLevel: 1,\n    maxLevel: $minPathDistance-1\n})\nYIELD node\nWITH startPerson, collect(DISTINCT node) AS nodesCloserThanMinPathDistance\nCALL apoc.path.subgraphNodes(startPerson, {\n\trelationshipFilter: \"KNOWS\",\n    minLevel: 1,\n    maxLevel: $maxPathDistance\n})\nYIELD node\nWITH nodesCloserThanMinPathDistance, collect(DISTINCT node) AS nodesCloserThanMaxPathDistance\nWITH [n IN nodesCloserThanMaxPathDistance WHERE NOT n IN nodesCloserThanMinPathDistance] AS expertCandidatePersons\nUNWIND expertCandidatePersons AS expertCandidatePerson\nMATCH\n  (expertCandidatePerson)-[:IS_LOCATED_IN]->(:City)-[:IS_PART_OF]->(:Country {name: $country}),\n  (expertCandidatePerson)<-[:HAS_CREATOR]-(message:Message)-[:HAS_TAG]->(:Tag)-[:HAS_TYPE]->\n  (:TagClass {name: $tagClass})\nMATCH\n  (message)-[:HAS_TAG]->(tag:Tag)\nRETURN\n  expertCandidatePerson.id,\n  tag.name,\n  count(DISTINCT message) AS messageCount\nORDER BY\n  messageCount DESC,\n  tag.name ASC,\n  expertCandidatePerson.id ASC\nLIMIT 100\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-11",
      "status": "FAIL",
      "error": "ClickGraph Error: Invalid render plan: No FROM clause found. This usually indicates missing table information or incomplete query planning.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-12",
      "status": "FAIL",
      "error": "ClickGraph Error: Invalid render plan: No FROM clause found. This usually indicates missing table information or incomplete query planning.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-13",
      "status": "FAIL",
      "error": "ClickGraph Error: Invalid render plan: Cannot find ID column for alias 'zombie' needed for GROUP BY aggregation. This alias may come from a CTE that hasn't been properly registered.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-14",
      "status": "FAIL",
      "error": "ClickGraph Error: AnalyzerError: Property 'person1Id' not found on node 'top'",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-15",
      "status": "FAIL",
      "error": "Query syntax error: Unexpected tokens after query: ('bi15', false)\nYIELD graphName\n\nWITH count(*) AS dummy\n\nCALL gds.graph.project.cypher(\n  'bi15',\n  'MATCH (p:Person) RETURN id(p) AS id',\n  'MATCH (pA:Person)-[knows:KNOWS]-(pB:Person)\n      OPTIONAL MATCH (pA)<-[:HAS_CREATOR]-(m1:Message)-[r:REPLY_OF]-(m2:Message)-[:HAS_CREATOR]->(pB)\n      OPTIONAL MATCH (m1)-[:REPLY_OF*0..]->(:Post)<-[:CONTAINER_OF]-(forum:Forum)\n              WHERE forum.creationDate >= datetime({epochmillis: ' + $startDate.epochMillis + '})\n                AND forum.creationDate <= datetime({epochmillis: ' + $endDate.epochMillis   + '})\n      WITH pA, pB,\n          sum(CASE forum IS NOT NULL\n              WHEN true THEN\n                  CASE (m1:Post OR m2:Post) WHEN true THEN 1.0\n                  ELSE 0.5 END\n              ELSE 0.0 END\n          ) AS w\n      RETURN\n        id(pA) AS source,\n        id(pB) AS target,\n        1/(w+1) AS weight\n  '\n)\nYIELD graphName\n\nWITH count(*) AS dummy\n\nCALL {\n  MATCH (person1:Person {id: $person1Id}), (person2:Person {id: $person2Id})\n  CALL gds.shortestPath.dijkstra.stream('bi15', {\n    sourceNode: person1,\n    targetNode: person2,\n    relationshipWeightProperty: 'weight'\n  })\n  YIELD index, sourceNode, targetNode, totalCost, nodeIds, costs, path\n  RETURN totalCost\n  UNION ALL\n  RETURN -1.0 AS totalCost\n}\nRETURN max(totalCost) AS totalCost\nUnparsed input: ('bi15', false)\nYIELD graphName\n\nWITH count(*) AS dummy\n\nCALL gds.graph.project.cypher(\n  'bi15',\n  'MATCH (p:Person) RETURN id(p) AS id',\n  'MATCH (pA:Person)-[knows:KNOWS]-(pB:Person)\n      OPTIONAL MATCH (pA)<-[:HAS_CREATOR]-(m1:Message)-[r:REPLY_OF]-(m2:Message)-[:HAS_CREATOR]->(pB)\n      OPTIONAL MATCH (m1)-[:REPLY_OF*0..]->(:Post)<-[:CONTAINER_OF]-(forum:Forum)\n              WHERE forum.creationDate >= datetime({epochmillis: ' + $startDate.epochMillis + '})\n                AND forum.creationDate <= datetime({epochmillis: ' + $endDate.epochMillis   + '})\n      WITH pA, pB,\n          sum(CASE forum IS NOT NULL\n              WHEN true THEN\n                  CASE (m1:Post OR m2:Post) WHEN true THEN 1.0\n                  ELSE 0.5 END\n              ELSE 0.0 END\n          ) AS w\n      RETURN\n        id(pA) AS source,\n        id(pB) AS target,\n        1/(w+1) AS weight\n  '\n)\nYIELD graphName\n\nWITH count(*) AS dummy\n\nCALL {\n  MATCH (person1:Person {id: $person1Id}), (person2:Person {id: $person2Id})\n  CALL gds.shortestPath.dijkstra.stream('bi15', {\n    sourceNode: person1,\n    targetNode: person2,\n    relationshipWeightProperty: 'weight'\n  })\n  YIELD index, sourceNode, targetNode, totalCost, nodeIds, costs, path\n  RETURN totalCost\n  UNION ALL\n  RETURN -1.0 AS totalCost\n}\nRETURN max(totalCost) AS totalCost\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-16",
      "status": "FAIL",
      "error": "Query syntax error: Unexpected tokens after query: CALL {\n  WITH paramTagX, paramDateX\n  MATCH (person1:Person)<-[:HAS_CREATOR]-(message1:Message)-[:HAS_TAG]->(tag:Tag {name: paramTagX})\n  WHERE date(message1.creationDate) = date(paramDateX)\n  OPTIONAL MATCH (person1)-[:KNOWS]-(person2:Person)<-[:HAS_CREATOR]-(message2:Message)-[:HAS_TAG]->(tag)\n  WHERE date(message2.creationDate) = date(paramDateX)\n  WITH person1, count(DISTINCT message1) AS cm, count(DISTINCT person2) AS cp2\n  WHERE cp2 <= $maxKnowsLimit\n  RETURN person1, cm\n}\nWITH person1, collect({letter: paramLetter, messageCount: cm}) AS results\nWHERE size(results) = 2\nRETURN\n  person1.id,\n  [r IN results WHERE r.letter = 'A' | r.messageCount][0] AS messageCountA,\n  [r IN results WHERE r.letter = 'B' | r.messageCount][0] AS messageCountB\nORDER BY messageCountA + messageCountB DESC, person1.id ASC\nLIMIT 20\nUnparsed input: CALL {\n  WITH paramTagX, paramDateX\n  MATCH (person1:Person)<-[:HAS_CREATOR]-(message1:Message)-[:HAS_TAG]->(tag:Tag {name: paramTagX})\n  WHERE date(message1.creationDate) = date(paramDateX)\n  OPTIONAL MATCH (person1)-[:KNOWS]-(person2:Person)<-[:HAS_CREATOR]-(message2:Message)-[:HAS_TAG]->(tag)\n  WHERE date(message2.creationDate) = date(paramDateX)\n  WITH person1, count(DISTINCT message1) AS cm, count(DISTINCT person2) AS cp2\n  WHERE cp2 <= $maxKnowsLimit\n  RETURN person1, cm\n}\nWITH person1, collect({letter: paramLetter, messageCount: cm}) AS results\nWHERE size(results) = 2\nRETURN\n  person1.id,\n  [r IN results WHERE r.letter = 'A' | r.messageCount][0] AS messageCountA,\n  [r IN results WHERE r.letter = 'B' | r.messageCount][0] AS messageCountB\nORDER BY messageCountA + messageCountB DESC, person1.id ASC\nLIMIT 20\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-17",
      "status": "FAIL",
      "error": "Query syntax error: Unable to parse: >(person2:Person)<-[:HAS_CREATOR]-(comment:Comment)-[:HAS_TAG]->(tag),\n  (forum1)<-[:HAS_MEMBER]->(person3:Person)<-[:HAS_CREATOR]-(message2:Message),\n  (comment)-[:REPLY_OF]->(message2)-[:REPLY_OF*0..]->(post2:Post)<-[:CONTAINER_OF]-(forum2:Forum)\nMATCH (comment)-[:HAS_TAG]->(tag)\nMATCH (message2)-[:HAS_TAG]->(tag)\nWHERE forum1 <> forum2\n  AND message2.creationDate > message1.creationDate + duration({hours: $delta})\n  AND NOT (forum2)-[:HAS_MEMBER]->(person1)\nRETURN person1.id, count(DISTINCT message2) AS messageCount\nORDER BY messageCount DESC, person1.id ASC\nLIMIT 10\nError in match clause: (tag:Tag {name: $tag}),\n  (person1:Person)<-[:HAS_CREATOR]-(message1:Message)-[:REPLY_OF*0..]->(post1:Post)<-[:CONTAINER_OF]-(forum1:Forum),\n  (message1)-[:HAS_TAG]->(tag),\n  (forum1)<-[:HAS_MEMBER]->(person2:Person)<-[:HAS_CREATOR]-(comment:Comment)-[:HAS_TAG]->(tag),\n  (forum1)<-[:HAS_MEMBER]->(person3:Person)<-[:HAS_CREATOR]-(message2:Message),\n  (comment)-[:REPLY_OF]->(message2)-[:REPLY_OF*0..]->(post2:Post)<-[:CONTAINER_OF]-(forum2:Forum)\nMATCH (comment)-[:HAS_TAG]->(tag)\nMATCH (message2)-[:HAS_TAG]->(tag)\nWHERE forum1 <> forum2\n  AND message2.creationDate > message1.creationDate + duration({hours: $delta})\n  AND NOT (forum2)-[:HAS_MEMBER]->(person1)\nRETURN person1.id, count(DISTINCT message2) AS messageCount\nORDER BY messageCount DESC, person1.id ASC\nLIMIT 10\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-18",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression or function identifier `person1` in scope SELECT person1.id AS person1Id, person2.id AS person2Id FROM ldbc.Person AS person1 INNER JOIN ldbc.Person_knows_Person AS t125 ON t125.Person1Id = person1.id INNER JOIN ldbc.Person AS mutualFriend ON mutualFriend.id = t125.Person2Id INNER JOIN ldbc.Person_hasInterest_Tag AS t124 ON t124.PersonId = person1.id INNER JOIN ldbc.Tag AS tag ON tag.id = t124.TagId INNER JOIN ldbc.Person_knows_Person AS t126 ON t126.Person1Id = mutualFriend.id INNER JOIN ldbc.Person AS person2 ON person2.id = t126.Person2Id INNER JOIN ldbc.Person_hasInterest_Tag AS t127 ON (t127.PersonId = person2.id) AND (t127.TagId = tag.id) WHERE ((person1 != person2) AND (NOT exists((SELECT 1 FROM ldbc.Person_knows_Person WHERE ((Person_knows_Person.Person1Id = person1.id) AND (Person_knows_Person.Person2Id = person2.id)) OR ((Person_knows_Person.Person1Id = person2.id) AND (Person_knows_Person.Person2Id = person1.id)))))) AND ((NOT ((t124.PersonId = t124.PersonId) AND (t124.TagId = t124.TagId))) AND (NOT ((t126.Person1Id = t125.Person1Id) AND (t126.Person2Id = t125.Person2Id)))). Maybe you meant: ['PersonId']. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-19",
      "status": "FAIL",
      "error": "Query syntax error: Unexpected tokens after query: ('bi19', {\n  sourceNode: person1,\n  targetNode: person2,\n  relationshipWeightProperty: 'weight'\n})\nYIELD totalCost\nWITH person1.id AS person1Id, person2.id AS person2Id, totalCost AS totalWeight\nORDER BY totalWeight ASC, person1.id ASC, person2.id ASC\nWITH collect({person1Id: person1Id, person2Id: person2Id, totalWeight: totalWeight}) AS results\nUNWIND results AS result\nWITH result.person1Id AS person1Id, result.person2Id AS person2Id, result.totalWeight AS totalWeight\nWHERE totalWeight = results[0].totalWeight\nRETURN person1Id, person2Id, totalWeight\nORDER BY person1Id, person2Id\nUnparsed input: ('bi19', {\n  sourceNode: person1,\n  targetNode: person2,\n  relationshipWeightProperty: 'weight'\n})\nYIELD totalCost\nWITH person1.id AS person1Id, person2.id AS person2Id, totalCost AS totalWeight\nORDER BY totalWeight ASC, person1.id ASC, person2.id ASC\nWITH collect({person1Id: person1Id, person2Id: person2Id, totalWeight: totalWeight}) AS results\nUNWIND results AS result\nWITH result.person1Id AS person1Id, result.person2Id AS person2Id, result.totalWeight AS totalWeight\nWHERE totalWeight = results[0].totalWeight\nRETURN person1Id, person2Id, totalWeight\nORDER BY person1Id, person2Id\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-2",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Identifier 'tag.id' cannot be resolved from table with name tag. In scope with_countWindow1_tag_cte_1 AS (SELECT tag.id AS tag_id, anyLast(tag.name) AS tag_name, anyLast(tag.url) AS tag_url, count(*) AS countWindow1 FROM ldbc.Message AS message1 LEFT JOIN ldbc.Message_hasTag_Tag AS t130 ON t130.MessageId = message1.id LEFT JOIN ldbc.Tag_hasType_TagClass AS tag ON tag.TagId = t130.TagId INNER JOIN ldbc.Tag_hasType_TagClass AS t129 ON t129.TagId = tag.id INNER JOIN ldbc.TagClass AS t128 ON t128.id = t129.TagClassId WHERE t128.name = 'MusicalArtist' GROUP BY tag.id). (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-20",
      "status": "FAIL",
      "error": "Query syntax error: Unexpected tokens after query: ('bi20', {\n  sourceNode: person1,\n  targetNode: person2,\n  relationshipWeightProperty: 'weight'\n})\nYIELD totalCost\nWHERE person1.id <> $person2Id\nWITH person1.id AS person1Id, totalCost AS totalWeight\nORDER BY totalWeight ASC\nWITH collect({person1Id: person1Id, totalWeight: totalWeight}) AS results\nUNWIND results AS result\nWITH result.person1Id AS person1Id, result.totalWeight AS totalWeight\nWHERE totalWeight = results[0].totalWeight\nRETURN person1Id, totalWeight\nORDER BY person1Id ASC\nLIMIT 20\nUnparsed input: ('bi20', {\n  sourceNode: person1,\n  targetNode: person2,\n  relationshipWeightProperty: 'weight'\n})\nYIELD totalCost\nWHERE person1.id <> $person2Id\nWITH person1.id AS person1Id, totalCost AS totalWeight\nORDER BY totalWeight ASC\nWITH collect({person1Id: person1Id, totalWeight: totalWeight}) AS results\nUNWIND results AS result\nWITH result.person1Id AS person1Id, result.totalWeight AS totalWeight\nWHERE totalWeight = results[0].totalWeight\nRETURN person1Id, totalWeight\nORDER BY person1Id ASC\nLIMIT 20\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-3",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 179. DB::Exception: Multiple table expressions with same alias post. In scope WITH RECURSIVE vlp_cte34 AS (SELECT start_node.id AS start_id, start_node.id AS end_id, 0 AS hop_count, CAST([], 'Array(Tuple(UInt64, UInt64))') AS path_edges, CAST([], 'Array(String)') AS path_relationships, [start_node.id] AS path_nodes FROM ldbc.Message AS start_node UNION ALL SELECT vp.start_id, end_node.TargetMessageId AS end_id, vp.hop_count + 1 AS hop_count, arrayConcat(vp.path_edges, [(rel.MessageId, rel.TargetMessageId)]) AS path_edges, arrayConcat(vp.path_relationships, ['REPLY_OF']) AS path_relationships, arrayConcat(vp.path_nodes, [end_node.TargetMessageId]) AS path_nodes FROM vlp_cte34 AS vp INNER JOIN ldbc.Forum AS current_node ON vp.end_id = current_node.TargetMessageId INNER JOIN ldbc.Message_replyOf_Message AS rel ON current_node.TargetMessageId = rel.MessageId INNER JOIN ldbc.Forum AS end_node ON rel.TargetMessageId = end_node.TargetMessageId WHERE (vp.hop_count < 3) AND (NOT has(vp.path_edges, (rel.MessageId, rel.TargetMessageId)))) SELECT forum.id AS `forum.id`, forum.title AS `forum.title`, forum.creationDate AS `forum.creationDate`, person.id AS `person.id`, countDistinct(message.id) AS messageCount FROM vlp_cte34 AS vlp34 INNER JOIN ldbc.Message AS message ON vlp34.start_id = message.id INNER JOIN ldbc.Forum AS post ON vlp34.end_id = post.TargetMessageId INNER JOIN ldbc.Message_hasTag_Tag AS t141 ON t141.MessageId = message.id INNER JOIN ldbc.Tag AS t134 ON t134.id = t141.TagId INNER JOIN ldbc.Tag_hasType_TagClass AS t142 ON t142.TagId = t134.id INNER JOIN ldbc.TagClass AS t135 ON t135.id = t142.TagClassId INNER JOIN ldbc.Forum AS forum ON forum.id = t138.ForumId INNER JOIN ldbc.Person AS person ON person.id = t137.PersonId INNER JOIN ldbc.Person_isLocatedIn_Place AS t137 ON t137.CityId = t133.id INNER JOIN ldbc.Forum_hasModerator_Person AS t138 ON t138.PersonId = person.id INNER JOIN ldbc.Forum_containerOf_Post AS t139 ON t139.ForumId = forum.id INNER JOIN ldbc.Post AS post ON post.id = t139.PostId INNER JOIN ldbc.Message_replyOf_Message AS t140 ON t140.TargetMessageId = t139.PostId WHERE (((t135.name = 'MusicalArtist') AND (t132.name = 'Burma')) AND (t133.type = 'City')) AND (t132.type = 'Country') GROUP BY forum.id, forum.title, forum.creationDate, person.id ORDER BY messageCount DESC, forum.id ASC LIMIT 20 SETTINGS max_recursive_cte_evaluation_depth = 100. (MULTIPLE_EXPRESSIONS_FOR_ALIAS) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-4",
      "status": "FAIL",
      "error": "Query syntax error: Unexpected tokens after query: CALL {\n  WITH topForums\n  UNWIND topForums AS topForum1\n  MATCH (topForum1)-[:CONTAINER_OF]->(post:Post)<-[:REPLY_OF*0..]-(message:Message)-[:HAS_CREATOR]->(person:Person)<-[:HAS_MEMBER]-(topForum2:Forum)\n  WITH person, message, topForum2\n  WHERE topForum2 IN topForums\n  RETURN person, count(DISTINCT message) AS messageCount\nUNION ALL\n  WITH topForums\n  UNWIND topForums AS topForum1\n  MATCH (person:Person)<-[:HAS_MEMBER]-(topForum1:Forum)\n  RETURN person, 0 AS messageCount\n}\nRETURN\n  person.id AS personId,\n  person.firstName AS personFirstName,\n  person.lastName AS personLastName,\n  person.creationDate AS personCreationDate,\n  sum(messageCount) AS messageCount\nORDER BY\n  messageCount DESC,\n  person.id ASC\nLIMIT 100\nUnparsed input: CALL {\n  WITH topForums\n  UNWIND topForums AS topForum1\n  MATCH (topForum1)-[:CONTAINER_OF]->(post:Post)<-[:REPLY_OF*0..]-(message:Message)-[:HAS_CREATOR]->(person:Person)<-[:HAS_MEMBER]-(topForum2:Forum)\n  WITH person, message, topForum2\n  WHERE topForum2 IN topForums\n  RETURN person, count(DISTINCT message) AS messageCount\nUNION ALL\n  WITH topForums\n  UNWIND topForums AS topForum1\n  MATCH (person:Person)<-[:HAS_MEMBER]-(topForum1:Forum)\n  RETURN person, 0 AS messageCount\n}\nRETURN\n  person.id AS personId,\n  person.firstName AS personFirstName,\n  person.lastName AS personLastName,\n  person.creationDate AS personCreationDate,\n  sum(messageCount) AS messageCount\nORDER BY\n  messageCount DESC,\n  person.id ASC\nLIMIT 100\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-5",
      "status": "FAIL",
      "error": "ClickGraph Error: Invalid render plan: No FROM clause found. This usually indicates missing table information or incomplete query planning.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-6",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression or function identifier `person1.id` in scope SELECT person1.id AS `person1.id`, countDistinct((like.PersonId, like.MessageId)) AS authorityScore FROM ldbc.Message_hasTag_Tag AS t147 INNER JOIN ldbc.Message_hasCreator_Person AS t148 ON t148.PersonId = person1.id LEFT JOIN ldbc.Person_likes_Message AS like ON like.MessageId = message2.id LEFT JOIN ldbc.Person AS person3 ON person3.id = like.PersonId LEFT JOIN ldbc.Person_likes_Message AS t149 ON t149.MessageId = message1.id LEFT JOIN ldbc.Message AS message2 ON message2.id = t150.MessageId INNER JOIN ldbc.Message AS message1 ON message1.id = t148.MessageId LEFT JOIN Message_hasCreator_Person AS t150 ON t150.PersonId = person2.id LEFT JOIN ldbc.Person AS person2 ON person2.id = t149.PersonId WHERE tag.name = 'Arnold_Schwarzenegger' GROUP BY person1.id ORDER BY authorityScore DESC, person1.id ASC LIMIT 100. Maybe you meant: ['person1.id']. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-7",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression or function identifier `t152.CommentId` in scope SELECT relatedTag.name AS `relatedTag.name`, countDistinct(comment.id) AS count FROM ldbc.Message_hasTag_Tag AS t151 INNER JOIN ldbc.Comment AS comment ON comment.id = t152.CommentId INNER JOIN ldbc.Comment_hasTag_Tag AS t153 ON t153.CommentId = comment.id INNER JOIN ldbc.Comment_replyOf_Message AS t152 ON t152.MessageId = message.id INNER JOIN ldbc.Tag AS relatedTag ON relatedTag.id = t153.TagId WHERE (NOT exists((SELECT 1 FROM ldbc.Comment_hasTag_Tag WHERE (Comment_hasTag_Tag.CommentId = comment.id) AND (Comment_hasTag_Tag.TagId = tag.id)))) AND (tag.name = 'Enrique_Iglesias') GROUP BY relatedTag.name ORDER BY count DESC, relatedTag.name ASC LIMIT 100. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-8",
      "status": "ERROR",
      "error": "('Connection aborted.', RemoteDisconnected('Remote end closed connection without response'))",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-9",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Identifier 'current_node.TargetMessageId' cannot be resolved from table with name current_node. In scope SELECT vp.start_id, end_node.TargetMessageId AS end_id, vp.hop_count + 1 AS hop_count, arrayConcat(vp.path_edges, [(rel.MessageId, rel.TargetMessageId)]) AS path_edges, arrayConcat(vp.path_relationships, ['REPLY_OF']) AS path_relationships, arrayConcat(vp.path_nodes, [end_node.TargetMessageId]) AS path_nodes FROM vlp_cte35 AS vp INNER JOIN ldbc.Post AS current_node ON vp.end_id = current_node.TargetMessageId INNER JOIN ldbc.Message_replyOf_Message AS rel ON current_node.TargetMessageId = rel.MessageId INNER JOIN ldbc.Post AS end_node ON rel.TargetMessageId = end_node.TargetMessageId WHERE (vp.hop_count < 3) AND (NOT has(vp.path_edges, (rel.MessageId, rel.TargetMessageId))) AND ((end_node.creationDate >= 'datetime(\\\\'2011-10-01\\\\')') AND (end_node.creationDate <= 'datetime(\\\\'2011-10-15\\\\')')). Maybe you meant: ['current_node.language']. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    }
  ],
  "summary": {
    "total": 41,
    "pass": 7,
    "fail": 33,
    "error": 1,
    "timeout": 0
  }
}