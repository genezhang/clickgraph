{
  "timestamp": "2026-01-11T20:26:42.484135",
  "results": [
    {
      "category": "interactive-short",
      "query": "short-1",
      "status": "PASS",
      "error": null,
      "rows": 0
    },
    {
      "category": "interactive-short",
      "query": "short-2",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Identifier 'start_node.CommentId' cannot be resolved from subquery with name start_node. In scope SELECT start_node.CommentId AS start_id, start_node.CommentId AS end_id, 0 AS hop_count, CAST([], 'Array(Tuple(UInt64, UInt64))') AS path_edges, CAST([], 'Array(String)') AS path_relationships, [start_node.CommentId] AS path_nodes FROM with_message_messageCreationDate_messageId_cte_1 AS start_node. Maybe you meant: ['start_node.messageId']. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "interactive-short",
      "query": "short-3",
      "status": "PASS",
      "error": null,
      "rows": 0
    },
    {
      "category": "interactive-short",
      "query": "short-4",
      "status": "PASS",
      "error": null,
      "rows": 0
    },
    {
      "category": "interactive-short",
      "query": "short-5",
      "status": "PASS",
      "error": null,
      "rows": 0
    },
    {
      "category": "interactive-short",
      "query": "short-6",
      "status": "PASS",
      "error": null,
      "rows": 0
    },
    {
      "category": "interactive-short",
      "query": "short-7",
      "status": "PASS",
      "error": null,
      "rows": 0
    },
    {
      "category": "interactive-complex",
      "query": "complex-1",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 164. DB::Exception: Cannot modify 'max_recursive_cte_evaluation_depth' setting in readonly mode. (READONLY) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-10",
      "status": "FAIL",
      "error": "Query syntax error: Unexpected tokens after query: ([p IN posts WHERE (p)-[:HAS_TAG]->()<-[:HAS_INTEREST]-(person)]) AS commonPostCount\nRETURN friend.id AS personId,\n       friend.firstName AS personFirstName,\n       friend.lastName AS personLastName,\n       commonPostCount - (postCount - commonPostCount) AS commonInterestScore,\n       friend.gender AS personGender,\n       city.name AS personCityName\nORDER BY commonInterestScore DESC, personId ASC\nLIMIT 10\nUnparsed input: ([p IN posts WHERE (p)-[:HAS_TAG]->()<-[:HAS_INTEREST]-(person)]) AS commonPostCount\nRETURN friend.id AS personId,\n       friend.firstName AS personFirstName,\n       friend.lastName AS personLastName,\n       commonPostCount - (postCount - commonPostCount) AS commonInterestScore,\n       friend.gender AS personGender,\n       city.name AS personCityName\nORDER BY commonInterestScore DESC, personId ASC\nLIMIT 10\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-11",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression or function identifier `person` in scope SELECT person.locationIP AS `person.locationIP`, person.lastName AS `person.lastName`, person.firstName AS `person.firstName`, person.gender AS `person.gender`, person.id AS `person.id`, person.creationDate AS `person.creationDate`, person.birthday AS `person.birthday`, person.browserUsed AS `person.browserUsed`, friend.locationIP AS `friend.locationIP`, friend.lastName AS `friend.lastName`, friend.firstName AS `friend.firstName`, friend.gender AS `friend.gender`, friend.id AS `friend.id`, friend.creationDate AS `friend.creationDate`, friend.birthday AS `friend.birthday`, friend.browserUsed AS `friend.browserUsed` FROM vlp_cte5 AS vlp5 INNER JOIN ldbc.Person AS person ON vlp5.start_id = person.id INNER JOIN ldbc.Person AS friend ON vlp5.end_id = friend.id WHERE NOT (person = friend). Maybe you meant: ['personId']. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-12",
      "status": "FAIL",
      "error": "ClickGraph Error: Invalid render plan: Could not render any WITH clause for alias 'tags'",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-13",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Identifier 'start_node.Person1Id' cannot be resolved from table with name start_node. In scope SELECT start_node.Person1Id AS start_id, end_node.id AS end_id, 1 AS hop_count, [(rel.Person1Id, rel.Person2Id)] AS path_edges, ['KNOWS::Person::Person'] AS path_relationships, [start_node.Person1Id, end_node.id] AS path_nodes, start_node.id AS start_id FROM ldbc.Person AS start_node INNER JOIN ldbc.Person_knows_Person AS rel ON start_node.Person1Id = rel.Person1Id INNER JOIN ldbc.Person AS end_node ON rel.Person2Id = end_node.id WHERE start_node.id = 8796093022390. Maybe you meant: ['start_node.firstName']. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-14",
      "status": "FAIL",
      "error": "Query syntax error: Unexpected tokens after query: CALL gds.graph.project.cypher(\n  apoc.create.uuidBase64(),\n  'MATCH (p:Person) RETURN id(p) AS id',\n  'MATCH\n      (pA:Person)-[knows:KNOWS]-(pB:Person),\n      (pA)<-[:HAS_CREATOR]-(m1:Message)-[r:REPLY_OF]-(m2:Message)-[:HAS_CREATOR]->(pB)\n    WITH\n      id(pA) AS source,\n      id(pB) AS target,\n      count(r) AS numInteractions\n    RETURN\n      source,\n      target,\n      CASE WHEN round(40-sqrt(numInteractions)) > 1 THEN round(40-sqrt(numInteractions)) ELSE 1 END AS weight\n  '\n)\nYIELD graphName\n\nWITH person1, person2, graphName\n\nCALL gds.shortestPath.dijkstra.stream(\n    graphName, {sourceNode: person1, targetNode: person2, relationshipWeightProperty: 'weight'}\n)\nYIELD index, sourceNode, targetNode, totalCost, nodeIds, costs, path\n\nWITH path, totalCost, graphName\n\nCALL gds.graph.drop(graphName, false)\nYIELD graphName as graphNameremoved\n\nRETURN [person IN nodes(path) | person.id] AS personIdsInPath, totalCost AS pathWeight\nLIMIT 1\nUnparsed input: CALL gds.graph.project.cypher(\n  apoc.create.uuidBase64(),\n  'MATCH (p:Person) RETURN id(p) AS id',\n  'MATCH\n      (pA:Person)-[knows:KNOWS]-(pB:Person),\n      (pA)<-[:HAS_CREATOR]-(m1:Message)-[r:REPLY_OF]-(m2:Message)-[:HAS_CREATOR]->(pB)\n    WITH\n      id(pA) AS source,\n      id(pB) AS target,\n      count(r) AS numInteractions\n    RETURN\n      source,\n      target,\n      CASE WHEN round(40-sqrt(numInteractions)) > 1 THEN round(40-sqrt(numInteractions)) ELSE 1 END AS weight\n  '\n)\nYIELD graphName\n\nWITH person1, person2, graphName\n\nCALL gds.shortestPath.dijkstra.stream(\n    graphName, {sourceNode: person1, targetNode: person2, relationshipWeightProperty: 'weight'}\n)\nYIELD index, sourceNode, targetNode, totalCost, nodeIds, costs, path\n\nWITH path, totalCost, graphName\n\nCALL gds.graph.drop(graphName, false)\nYIELD graphName as graphNameremoved\n\nRETURN [person IN nodes(path) | person.id] AS personIdsInPath, totalCost AS pathWeight\nLIMIT 1\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-2",
      "status": "PASS",
      "error": null,
      "rows": 0
    },
    {
      "category": "interactive-complex",
      "query": "complex-3",
      "status": "FAIL",
      "error": "ClickGraph Error: AnalyzerError: Property 'creationDate' not found on node 'message'",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-4",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression or function identifier `post.creationDate` in scope with_inValid_tag_valid_cte_4 AS (SELECT with_post_tag_cte_3.tag_id AS tag_id, with_post_tag_cte_3.tag_url AS tag_url, with_post_tag_cte_3.tag_name AS tag_name, multiIf((1277856000000 > post.creationDate) >= 1275350400000, 1, 0) AS valid, multiIf(1275350400000 > post.creationDate, 1, 0) AS inValid FROM with_post_tag_cte_3 AS post_tag). (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-5",
      "status": "FAIL",
      "error": "ClickGraph Error: Invalid render plan: Could not render any WITH clause for alias 'forum_postCount'",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-6",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression or function identifier `t` in scope with_postCount_tagName_cte_3 AS (SELECT tag.name AS tagName, count(*) AS postCount FROM ldbc.Post AS post INNER JOIN ldbc.Message_hasCreator_Person AS t46 ON t46.MessageId = post.id INNER JOIN ldbc.Person AS f ON f.id = t46.PersonId INNER JOIN ldbc.Post_hasTag_Tag AS t47 ON t47.PostId = post.id INNER JOIN ldbc.Tag AS t ON t.id = t47.TagId INNER JOIN ldbc.Post_hasTag_Tag AS t48 ON t48.PostId = post.id INNER JOIN ldbc.Tag AS tag ON tag.id = t48.TagId WHERE (NOT (t = tag)) AND (vlp32.id = knownTagId) GROUP BY tag.name). (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-7",
      "status": "FAIL",
      "error": "ClickGraph Error: AnalyzerError: Property 'likeTime' not found on node 'latestLike'",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-8",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression or function identifier `t53.PersonId` in scope SELECT person.id AS personId, person.firstName AS personFirstName, person.lastName AS personLastName, comment.creationDate AS commentCreationDate, comment.id AS commentId, comment.content AS commentContent FROM ldbc.Message_hasCreator_Person AS t51 INNER JOIN ldbc.Person AS person ON person.id = t53.PersonId INNER JOIN ldbc.Comment AS comment ON comment.id = t52.CommentId INNER JOIN ldbc.Comment_replyOf_Message AS t52 ON t52.MessageId = t50.id INNER JOIN ldbc.Comment_hasCreator_Person AS t53 ON t53.CommentId = comment.id WHERE start.id = 143 ORDER BY commentCreationDate DESC, commentId ASC LIMIT 20. Maybe you meant: ['t51.PersonId']. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "interactive-complex",
      "query": "complex-9",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression identifier `friends` in scope WITH RECURSIVE with_friends_cte AS (SELECT root.locationIP AS `root.locationIP`, root.lastName AS `root.lastName`, root.firstName AS `root.firstName`, root.gender AS `root.gender`, root.id AS `root.id`, root.creationDate AS `root.creationDate`, root.birthday AS `root.birthday`, root.browserUsed AS `root.browserUsed`, friend.locationIP AS `friend.locationIP`, friend.lastName AS `friend.lastName`, friend.firstName AS `friend.firstName`, friend.gender AS `friend.gender`, friend.id AS `friend.id`, friend.creationDate AS `friend.creationDate`, friend.birthday AS `friend.birthday`, friend.browserUsed AS `friend.browserUsed` FROM vlp_cte37 AS vlp37 INNER JOIN ldbc.Person AS root ON vlp37.start_id = root.id INNER JOIN ldbc.Person AS friend ON vlp37.end_id = friend.id WHERE NOT (friend = root) UNION ALL SELECT friend.locationIP AS `friend.locationIP`, friend.lastName AS `friend.lastName`, friend.firstName AS `friend.firstName`, friend.gender AS `friend.gender`, friend.id AS `friend.id`, friend.creationDate AS `friend.creationDate`, friend.birthday AS `friend.birthday`, friend.browserUsed AS `friend.browserUsed`, root.locationIP AS `root.locationIP`, root.lastName AS `root.lastName`, root.firstName AS `root.firstName`, root.gender AS `root.gender`, root.id AS `root.id`, root.creationDate AS `root.creationDate`, root.birthday AS `root.birthday`, root.browserUsed AS `root.browserUsed` FROM vlp_cte38 AS vlp38 INNER JOIN ldbc.Person AS friend ON vlp38.start_id = friend.id INNER JOIN ldbc.Person AS root ON vlp38.end_id = root.id WHERE NOT (friend = root)), vlp_cte35 AS (SELECT * FROM (WITH RECURSIVE vlp_cte35 AS (SELECT start_node.id AS start_id, end_node.id AS end_id, 1 AS hop_count, [(rel.Person1Id, rel.Person2Id)] AS path_edges, ['KNOWS::Person::Person'] AS path_relationships, [start_node.id, end_node.id] AS path_nodes FROM ldbc.Person AS start_node INNER JOIN ldbc.Person_knows_Person AS rel ON start_node.id = rel.Person1Id INNER JOIN ldbc.Person AS end_node ON rel.Person2Id = end_node.id WHERE (start_node.id = 4398046511268) AND (NOT (rel.Person2Id = rel.Person1Id)) UNION ALL SELECT vp.start_id, end_node.id AS end_id, vp.hop_count + 1 AS hop_count, arrayConcat(vp.path_edges, [(rel.Person1Id, rel.Person2Id)]) AS path_edges, arrayConcat(vp.path_relationships, ['KNOWS::Person::Person']) AS path_relationships, arrayConcat(vp.path_nodes, [end_node.id]) AS path_nodes FROM vlp_cte35 AS vp INNER JOIN ldbc.Person AS current_node ON vp.end_id = current_node.id INNER JOIN ldbc.Person_knows_Person AS rel ON current_node.id = rel.Person1Id INNER JOIN ldbc.Person AS end_node ON rel.Person2Id = end_node.id WHERE (vp.hop_count < 2) AND (NOT has(vp.path_edges, (rel.Person1Id, rel.Person2Id))) AND (NOT (rel.Person2Id = rel.Person1Id))) SELECT * FROM vlp_cte35)), vlp_cte36 AS (SELECT * FROM (WITH RECURSIVE vlp_cte36 AS (SELECT start_node.id AS start_id, end_node.id AS end_id, 1 AS hop_count, [(rel.Person1Id, rel.Person2Id)] AS path_edges, ['KNOWS::Person::Person'] AS path_relationships, [start_node.id, end_node.id] AS path_nodes FROM ldbc.Person AS start_node INNER JOIN ldbc.Person_knows_Person AS rel ON start_node.id = rel.Person1Id INNER JOIN ldbc.Person AS end_node ON rel.Person2Id = end_node.id WHERE (end_node.id = 4398046511268) AND (NOT (rel.Person1Id = rel.Person2Id)) UNION ALL SELECT vp.start_id, end_node.id AS end_id, vp.hop_count + 1 AS hop_count, arrayConcat(vp.path_edges, [(rel.Person1Id, rel.Person2Id)]) AS path_edges, arrayConcat(vp.path_relationships, ['KNOWS::Person::Person']) AS path_relationships, arrayConcat(vp.path_nodes, [end_node.id]) AS path_nodes FROM vlp_cte36 AS vp INNER JOIN ldbc.Person AS current_node ON vp.end_id = current_node.id INNER JOIN ldbc.Person_knows_Person AS rel ON current_node.id = rel.Person1Id INNER JOIN ldbc.Person AS end_node ON rel.Person2Id = end_node.id WHERE (vp.hop_count < 2) AND (NOT has(vp.path_edges, (rel.Person1Id, rel.Person2Id))) AND (end_node.id = 4398046511268) AND (NOT (rel.Person1Id = rel.Person2Id))) SELECT * FROM vlp_cte36)) SELECT friend.id AS personId, friend.firstName AS personFirstName, friend.lastName AS personLastName, message.id AS commentOrPostId, coalesce(message.content, message.imageFile) AS commentOrPostContent, message.creationDate AS commentOrPostCreationDate FROM ldbc.Message AS message INNER JOIN ldbc.Message_hasCreator_Person AS t55 ON t55.MessageId = message.id INNER JOIN ldbc.Person AS friend ON friend.id = t55.PersonId ARRAY JOIN friends AS friend WHERE message.creationDate < 1289908800000 ORDER BY commentOrPostCreationDate DESC, message.id ASC LIMIT 20 SETTINGS max_recursive_cte_evaluation_depth = 100. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-1",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: Code: 62. DB::Exception: Syntax error: failed at position 1221 (WHERE) (line 28, col 1): WHERE (message.creationDate < 'datetime(\\'2011-12-01T00:00:00.000\\')' AND message.content IS NOT NULL)\n), \nwith_averageMessageLength_isComment_lengthCategory_mess... Expected one of: FINAL, SAMPLE, USING, ON. (SYNTAX_ERROR) (version 25.8.11.66 (official build))",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-10",
      "status": "FAIL",
      "error": "Query syntax error: Unexpected tokens after query: (startPerson, {\n\trelationshipFilter: \"KNOWS\",\n    minLevel: 1,\n    maxLevel: $minPathDistance-1\n})\nYIELD node\nWITH startPerson, collect(DISTINCT node) AS nodesCloserThanMinPathDistance\nCALL apoc.path.subgraphNodes(startPerson, {\n\trelationshipFilter: \"KNOWS\",\n    minLevel: 1,\n    maxLevel: $maxPathDistance\n})\nYIELD node\nWITH nodesCloserThanMinPathDistance, collect(DISTINCT node) AS nodesCloserThanMaxPathDistance\nWITH [n IN nodesCloserThanMaxPathDistance WHERE NOT n IN nodesCloserThanMinPathDistance] AS expertCandidatePersons\nUNWIND expertCandidatePersons AS expertCandidatePerson\nMATCH\n  (expertCandidatePerson)-[:IS_LOCATED_IN]->(:City)-[:IS_PART_OF]->(:Country {name: $country}),\n  (expertCandidatePerson)<-[:HAS_CREATOR]-(message:Message)-[:HAS_TAG]->(:Tag)-[:HAS_TYPE]->\n  (:TagClass {name: $tagClass})\nMATCH\n  (message)-[:HAS_TAG]->(tag:Tag)\nRETURN\n  expertCandidatePerson.id,\n  tag.name,\n  count(DISTINCT message) AS messageCount\nORDER BY\n  messageCount DESC,\n  tag.name ASC,\n  expertCandidatePerson.id ASC\nLIMIT 100\nUnparsed input: (startPerson, {\n\trelationshipFilter: \"KNOWS\",\n    minLevel: 1,\n    maxLevel: $minPathDistance-1\n})\nYIELD node\nWITH startPerson, collect(DISTINCT node) AS nodesCloserThanMinPathDistance\nCALL apoc.path.subgraphNodes(startPerson, {\n\trelationshipFilter: \"KNOWS\",\n    minLevel: 1,\n    maxLevel: $maxPathDistance\n})\nYIELD node\nWITH nodesCloserThanMinPathDistance, collect(DISTINCT node) AS nodesCloserThanMaxPathDistance\nWITH [n IN nodesCloserThanMaxPathDistance WHERE NOT n IN nodesCloserThanMinPathDistance] AS expertCandidatePersons\nUNWIND expertCandidatePersons AS expertCandidatePerson\nMATCH\n  (expertCandidatePerson)-[:IS_LOCATED_IN]->(:City)-[:IS_PART_OF]->(:Country {name: $country}),\n  (expertCandidatePerson)<-[:HAS_CREATOR]-(message:Message)-[:HAS_TAG]->(:Tag)-[:HAS_TYPE]->\n  (:TagClass {name: $tagClass})\nMATCH\n  (message)-[:HAS_TAG]->(tag:Tag)\nRETURN\n  expertCandidatePerson.id,\n  tag.name,\n  count(DISTINCT message) AS messageCount\nORDER BY\n  messageCount DESC,\n  tag.name ASC,\n  expertCandidatePerson.id ASC\nLIMIT 100\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-11",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression or function identifier `a.id` in scope with_a_b_country_cte_4 AS (SELECT DISTINCT b.birthday AS b_birthday, b.browserUsed AS b_browserUsed, b.creationDate AS b_creationDate, b.firstName AS b_firstName, b.gender AS b_gender, b.id AS b_id, b.lastName AS b_lastName, b.locationIP AS b_locationIP FROM ldbc.Person AS b INNER JOIN ldbc.Person_knows_Person AS k1 ON (k1.Person1Id = a.id) OR (k1.Person2Id = a.id) WHERE (('datetime(\\\\'2012-09-29\\\\')' <= k1.creationDate) AND (k1.creationDate <= 'datetime(\\\\'2013-01-01\\\\')')) AND (a.id < b.id)). Maybe you meant: ['a.id']. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-12",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Identifier 'start_node.MessageId' cannot be resolved from table with name start_node. In scope SELECT start_node.MessageId AS start_id, start_node.MessageId AS end_id, 0 AS hop_count, CAST([], 'Array(Tuple(UInt64, UInt64))') AS path_edges, CAST([], 'Array(String)') AS path_relationships, [start_node.MessageId] AS path_nodes FROM ldbc.Message AS start_node WHERE start_node.language IN ('[\\\\'ar'). Maybe you meant: ['start_node.imageFile']. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-13",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression or function identifier `message.id` in scope with_totalLikeCount_zombie_zombieLikeCount_cte_7 AS (SELECT anyLast(with_zombie_zombieLikeCount_cte_6.zombieLikeCount) AS zombieLikeCount, count(*) AS totalLikeCount FROM ldbc.Person AS likerPerson LEFT JOIN ldbc.Person_likes_Message AS t74 ON t74.PersonId = likerPerson.id INNER JOIN ldbc.Message_hasCreator_Person AS t73 ON t73.MessageId = message.id INNER JOIN with_zombie_zombieLikeCount_cte_6 AS zombie ON zombie.zombie_id = t73.PersonId WHERE ((likerPerson.creationDate < 'datetime(\\\\'2013-01-01\\\\')') AND (message.creationDate < 'datetime(\\\\'2013-01-01\\\\')')) AND ((message.creationDate < 'datetime(\\\\'2013-01-01\\\\')') AND (zombie.zombie_creationDate < 'datetime(\\\\'2013-01-01\\\\')'))). (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-14",
      "status": "FAIL",
      "error": "ClickGraph Error: AnalyzerError: Property 'person1Id' not found on node 'top'",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-15",
      "status": "FAIL",
      "error": "Query syntax error: Unexpected tokens after query: ('bi15', false)\nYIELD graphName\n\nWITH count(*) AS dummy\n\nCALL gds.graph.project.cypher(\n  'bi15',\n  'MATCH (p:Person) RETURN id(p) AS id',\n  'MATCH (pA:Person)-[knows:KNOWS]-(pB:Person)\n      OPTIONAL MATCH (pA)<-[:HAS_CREATOR]-(m1:Message)-[r:REPLY_OF]-(m2:Message)-[:HAS_CREATOR]->(pB)\n      OPTIONAL MATCH (m1)-[:REPLY_OF*0..]->(:Post)<-[:CONTAINER_OF]-(forum:Forum)\n              WHERE forum.creationDate >= datetime({epochmillis: ' + $startDate.epochMillis + '})\n                AND forum.creationDate <= datetime({epochmillis: ' + $endDate.epochMillis   + '})\n      WITH pA, pB,\n          sum(CASE forum IS NOT NULL\n              WHEN true THEN\n                  CASE (m1:Post OR m2:Post) WHEN true THEN 1.0\n                  ELSE 0.5 END\n              ELSE 0.0 END\n          ) AS w\n      RETURN\n        id(pA) AS source,\n        id(pB) AS target,\n        1/(w+1) AS weight\n  '\n)\nYIELD graphName\n\nWITH count(*) AS dummy\n\nCALL {\n  MATCH (person1:Person {id: $person1Id}), (person2:Person {id: $person2Id})\n  CALL gds.shortestPath.dijkstra.stream('bi15', {\n    sourceNode: person1,\n    targetNode: person2,\n    relationshipWeightProperty: 'weight'\n  })\n  YIELD index, sourceNode, targetNode, totalCost, nodeIds, costs, path\n  RETURN totalCost\n  UNION ALL\n  RETURN -1.0 AS totalCost\n}\nRETURN max(totalCost) AS totalCost\nUnparsed input: ('bi15', false)\nYIELD graphName\n\nWITH count(*) AS dummy\n\nCALL gds.graph.project.cypher(\n  'bi15',\n  'MATCH (p:Person) RETURN id(p) AS id',\n  'MATCH (pA:Person)-[knows:KNOWS]-(pB:Person)\n      OPTIONAL MATCH (pA)<-[:HAS_CREATOR]-(m1:Message)-[r:REPLY_OF]-(m2:Message)-[:HAS_CREATOR]->(pB)\n      OPTIONAL MATCH (m1)-[:REPLY_OF*0..]->(:Post)<-[:CONTAINER_OF]-(forum:Forum)\n              WHERE forum.creationDate >= datetime({epochmillis: ' + $startDate.epochMillis + '})\n                AND forum.creationDate <= datetime({epochmillis: ' + $endDate.epochMillis   + '})\n      WITH pA, pB,\n          sum(CASE forum IS NOT NULL\n              WHEN true THEN\n                  CASE (m1:Post OR m2:Post) WHEN true THEN 1.0\n                  ELSE 0.5 END\n              ELSE 0.0 END\n          ) AS w\n      RETURN\n        id(pA) AS source,\n        id(pB) AS target,\n        1/(w+1) AS weight\n  '\n)\nYIELD graphName\n\nWITH count(*) AS dummy\n\nCALL {\n  MATCH (person1:Person {id: $person1Id}), (person2:Person {id: $person2Id})\n  CALL gds.shortestPath.dijkstra.stream('bi15', {\n    sourceNode: person1,\n    targetNode: person2,\n    relationshipWeightProperty: 'weight'\n  })\n  YIELD index, sourceNode, targetNode, totalCost, nodeIds, costs, path\n  RETURN totalCost\n  UNION ALL\n  RETURN -1.0 AS totalCost\n}\nRETURN max(totalCost) AS totalCost\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-16",
      "status": "FAIL",
      "error": "Query syntax error: Unexpected tokens after query: CALL {\n  WITH paramTagX, paramDateX\n  MATCH (person1:Person)<-[:HAS_CREATOR]-(message1:Message)-[:HAS_TAG]->(tag:Tag {name: paramTagX})\n  WHERE date(message1.creationDate) = date(paramDateX)\n  OPTIONAL MATCH (person1)-[:KNOWS]-(person2:Person)<-[:HAS_CREATOR]-(message2:Message)-[:HAS_TAG]->(tag)\n  WHERE date(message2.creationDate) = date(paramDateX)\n  WITH person1, count(DISTINCT message1) AS cm, count(DISTINCT person2) AS cp2\n  WHERE cp2 <= $maxKnowsLimit\n  RETURN person1, cm\n}\nWITH person1, collect({letter: paramLetter, messageCount: cm}) AS results\nWHERE size(results) = 2\nRETURN\n  person1.id,\n  [r IN results WHERE r.letter = 'A' | r.messageCount][0] AS messageCountA,\n  [r IN results WHERE r.letter = 'B' | r.messageCount][0] AS messageCountB\nORDER BY messageCountA + messageCountB DESC, person1.id ASC\nLIMIT 20\nUnparsed input: CALL {\n  WITH paramTagX, paramDateX\n  MATCH (person1:Person)<-[:HAS_CREATOR]-(message1:Message)-[:HAS_TAG]->(tag:Tag {name: paramTagX})\n  WHERE date(message1.creationDate) = date(paramDateX)\n  OPTIONAL MATCH (person1)-[:KNOWS]-(person2:Person)<-[:HAS_CREATOR]-(message2:Message)-[:HAS_TAG]->(tag)\n  WHERE date(message2.creationDate) = date(paramDateX)\n  WITH person1, count(DISTINCT message1) AS cm, count(DISTINCT person2) AS cp2\n  WHERE cp2 <= $maxKnowsLimit\n  RETURN person1, cm\n}\nWITH person1, collect({letter: paramLetter, messageCount: cm}) AS results\nWHERE size(results) = 2\nRETURN\n  person1.id,\n  [r IN results WHERE r.letter = 'A' | r.messageCount][0] AS messageCountA,\n  [r IN results WHERE r.letter = 'B' | r.messageCount][0] AS messageCountB\nORDER BY messageCountA + messageCountB DESC, person1.id ASC\nLIMIT 20\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-17",
      "status": "FAIL",
      "error": "Query syntax error: Unable to parse: >(person2:Person)<-[:HAS_CREATOR]-(comment:Comment)-[:HAS_TAG]->(tag),\n  (forum1)<-[:HAS_MEMBER]->(person3:Person)<-[:HAS_CREATOR]-(message2:Message),\n  (comment)-[:REPLY_OF]->(message2)-[:REPLY_OF*0..]->(post2:Post)<-[:CONTAINER_OF]-(forum2:Forum)\nMATCH (comment)-[:HAS_TAG]->(tag)\nMATCH (message2)-[:HAS_TAG]->(tag)\nWHERE forum1 <> forum2\n  AND message2.creationDate > message1.creationDate + duration({hours: $delta})\n  AND NOT (forum2)-[:HAS_MEMBER]->(person1)\nRETURN person1.id, count(DISTINCT message2) AS messageCount\nORDER BY messageCount DESC, person1.id ASC\nLIMIT 10\nError in match clause: (tag:Tag {name: $tag}),\n  (person1:Person)<-[:HAS_CREATOR]-(message1:Message)-[:REPLY_OF*0..]->(post1:Post)<-[:CONTAINER_OF]-(forum1:Forum),\n  (message1)-[:HAS_TAG]->(tag),\n  (forum1)<-[:HAS_MEMBER]->(person2:Person)<-[:HAS_CREATOR]-(comment:Comment)-[:HAS_TAG]->(tag),\n  (forum1)<-[:HAS_MEMBER]->(person3:Person)<-[:HAS_CREATOR]-(message2:Message),\n  (comment)-[:REPLY_OF]->(message2)-[:REPLY_OF*0..]->(post2:Post)<-[:CONTAINER_OF]-(forum2:Forum)\nMATCH (comment)-[:HAS_TAG]->(tag)\nMATCH (message2)-[:HAS_TAG]->(tag)\nWHERE forum1 <> forum2\n  AND message2.creationDate > message1.creationDate + duration({hours: $delta})\n  AND NOT (forum2)-[:HAS_MEMBER]->(person1)\nRETURN person1.id, count(DISTINCT message2) AS messageCount\nORDER BY messageCount DESC, person1.id ASC\nLIMIT 10\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-18",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression or function identifier `person1` in scope SELECT person1.id AS person1Id, person2.id AS person2Id, mutualFriend.id AS `mutualFriend.id` FROM ldbc.Person AS person1 INNER JOIN ldbc.Person_hasInterest_Tag AS t92 ON t92.PersonId = person1.id INNER JOIN ldbc.Person_knows_Person AS t93 ON t93.Person1Id = person1.id INNER JOIN ldbc.Person AS mutualFriend ON mutualFriend.id = t93.Person2Id INNER JOIN ldbc.Tag AS tag ON tag.id = t92.TagId INNER JOIN ldbc.Person_knows_Person AS t94 ON t94.Person1Id = mutualFriend.id INNER JOIN ldbc.Person AS person2 ON person2.id = t94.Person2Id INNER JOIN ldbc.Person_hasInterest_Tag AS t95 ON (t95.PersonId = person2.id) AND (t95.TagId = tag.id) WHERE ((person1 != person2) AND (NOT exists((SELECT 1 FROM ldbc.Person_knows_Person WHERE ((Person_knows_Person.Person1Id = person1.id) AND (Person_knows_Person.Person2Id = person2.id)) OR ((Person_knows_Person.Person1Id = person2.id) AND (Person_knows_Person.Person2Id = person1.id)))))) AND ((NOT ((t92.PersonId = t92.PersonId) AND (t92.TagId = t92.TagId))) AND (NOT ((t94.Person1Id = t93.Person1Id) AND (t94.Person2Id = t93.Person2Id)))). Maybe you meant: ['Person1Id']. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-19",
      "status": "FAIL",
      "error": "Query syntax error: Unexpected tokens after query: ('bi19', {\n  sourceNode: person1,\n  targetNode: person2,\n  relationshipWeightProperty: 'weight'\n})\nYIELD totalCost\nWITH person1.id AS person1Id, person2.id AS person2Id, totalCost AS totalWeight\nORDER BY totalWeight ASC, person1.id ASC, person2.id ASC\nWITH collect({person1Id: person1Id, person2Id: person2Id, totalWeight: totalWeight}) AS results\nUNWIND results AS result\nWITH result.person1Id AS person1Id, result.person2Id AS person2Id, result.totalWeight AS totalWeight\nWHERE totalWeight = results[0].totalWeight\nRETURN person1Id, person2Id, totalWeight\nORDER BY person1Id, person2Id\nUnparsed input: ('bi19', {\n  sourceNode: person1,\n  targetNode: person2,\n  relationshipWeightProperty: 'weight'\n})\nYIELD totalCost\nWITH person1.id AS person1Id, person2.id AS person2Id, totalCost AS totalWeight\nORDER BY totalWeight ASC, person1.id ASC, person2.id ASC\nWITH collect({person1Id: person1Id, person2Id: person2Id, totalWeight: totalWeight}) AS results\nUNWIND results AS result\nWITH result.person1Id AS person1Id, result.person2Id AS person2Id, result.totalWeight AS totalWeight\nWHERE totalWeight = results[0].totalWeight\nRETURN person1Id, person2Id, totalWeight\nORDER BY person1Id, person2Id\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-2",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression or function identifier `countWindow1_tag.tag_id` in scope with_countWindow1_countWindow2_tag_cte_3 AS (SELECT with_countWindow1_tag_cte_2.tag_id AS tag_id, anyLast(with_countWindow1_tag_cte_2.tag_name) AS tag_name, anyLast(with_countWindow1_tag_cte_2.tag_url) AS tag_url, anyLast(with_countWindow1_tag_cte_2.countWindow1) AS countWindow1, count(*) AS countWindow2 FROM ldbc.Message AS message2 LEFT JOIN ldbc.Message_hasTag_Tag AS t99 ON t99.MessageId = message2.id LEFT JOIN with_countWindow1_tag_cte_2 AS tag ON countWindow1_tag.tag_id = t99.TagId GROUP BY tag.tag_id). (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-20",
      "status": "FAIL",
      "error": "Query syntax error: Unexpected tokens after query: ('bi20', {\n  sourceNode: person1,\n  targetNode: person2,\n  relationshipWeightProperty: 'weight'\n})\nYIELD totalCost\nWHERE person1.id <> $person2Id\nWITH person1.id AS person1Id, totalCost AS totalWeight\nORDER BY totalWeight ASC\nWITH collect({person1Id: person1Id, totalWeight: totalWeight}) AS results\nUNWIND results AS result\nWITH result.person1Id AS person1Id, result.totalWeight AS totalWeight\nWHERE totalWeight = results[0].totalWeight\nRETURN person1Id, totalWeight\nORDER BY person1Id ASC\nLIMIT 20\nUnparsed input: ('bi20', {\n  sourceNode: person1,\n  targetNode: person2,\n  relationshipWeightProperty: 'weight'\n})\nYIELD totalCost\nWHERE person1.id <> $person2Id\nWITH person1.id AS person1Id, totalCost AS totalWeight\nORDER BY totalWeight ASC\nWITH collect({person1Id: person1Id, totalWeight: totalWeight}) AS results\nUNWIND results AS result\nWITH result.person1Id AS person1Id, result.totalWeight AS totalWeight\nWHERE totalWeight = results[0].totalWeight\nRETURN person1Id, totalWeight\nORDER BY person1Id ASC\nLIMIT 20\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-3",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 179. DB::Exception: Multiple table expressions with same alias post. In scope WITH RECURSIVE vlp_cte40 AS (SELECT start_node.id AS start_id, start_node.id AS end_id, 0 AS hop_count, CAST([], 'Array(Tuple(UInt64, UInt64))') AS path_edges, CAST([], 'Array(String)') AS path_relationships, [start_node.id] AS path_nodes FROM ldbc.Message AS start_node UNION ALL SELECT vp.start_id, end_node.TargetMessageId AS end_id, vp.hop_count + 1 AS hop_count, arrayConcat(vp.path_edges, [(rel.MessageId, rel.TargetMessageId)]) AS path_edges, arrayConcat(vp.path_relationships, ['REPLY_OF']) AS path_relationships, arrayConcat(vp.path_nodes, [end_node.TargetMessageId]) AS path_nodes FROM vlp_cte40 AS vp INNER JOIN ldbc.Forum AS current_node ON vp.end_id = current_node.TargetMessageId INNER JOIN ldbc.Message_replyOf_Message AS rel ON current_node.TargetMessageId = rel.MessageId INNER JOIN ldbc.Forum AS end_node ON rel.TargetMessageId = end_node.TargetMessageId WHERE (vp.hop_count < 3) AND (NOT has(vp.path_edges, (rel.MessageId, rel.TargetMessageId)))) SELECT forum.id AS `forum.id`, forum.title AS `forum.title`, forum.creationDate AS `forum.creationDate`, person.id AS `person.id`, countDistinct(message.id) AS messageCount FROM vlp_cte40 AS vlp40 INNER JOIN ldbc.Message AS message ON vlp40.start_id = message.id INNER JOIN ldbc.Forum AS post ON vlp40.end_id = post.TargetMessageId INNER JOIN ldbc.Message_hasTag_Tag AS t109 ON t109.MessageId = message.id INNER JOIN ldbc.Tag AS t102 ON t102.id = t109.TagId INNER JOIN ldbc.Tag_hasType_TagClass AS t110 ON t110.TagId = t102.id INNER JOIN ldbc.TagClass AS t103 ON t103.id = t110.TagClassId INNER JOIN ldbc.Post AS post ON post.id = t107.PostId INNER JOIN ldbc.Forum_containerOf_Post AS t107 ON t107.ForumId = forum.id INNER JOIN ldbc.Person_isLocatedIn_Place AS t105 ON t105.CityId = t101.id INNER JOIN ldbc.Person AS person ON person.id = t105.PersonId INNER JOIN ldbc.Forum AS forum ON forum.id = t106.ForumId INNER JOIN ldbc.Message_replyOf_Message AS t108 ON t108.TargetMessageId = t107.PostId INNER JOIN ldbc.Forum_hasModerator_Person AS t106 ON t106.PersonId = person.id WHERE (((t103.name = 'MusicalArtist') AND (t100.name = 'Burma')) AND (t101.type = 'City')) AND (t100.type = 'Country') GROUP BY forum.id, forum.title, forum.creationDate, person.id ORDER BY messageCount DESC, forum.id ASC LIMIT 20 SETTINGS max_recursive_cte_evaluation_depth = 100. (MULTIPLE_EXPRESSIONS_FOR_ALIAS) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-4",
      "status": "FAIL",
      "error": "Query syntax error: Unexpected tokens after query: CALL {\n  WITH topForums\n  UNWIND topForums AS topForum1\n  MATCH (topForum1)-[:CONTAINER_OF]->(post:Post)<-[:REPLY_OF*0..]-(message:Message)-[:HAS_CREATOR]->(person:Person)<-[:HAS_MEMBER]-(topForum2:Forum)\n  WITH person, message, topForum2\n  WHERE topForum2 IN topForums\n  RETURN person, count(DISTINCT message) AS messageCount\nUNION ALL\n  WITH topForums\n  UNWIND topForums AS topForum1\n  MATCH (person:Person)<-[:HAS_MEMBER]-(topForum1:Forum)\n  RETURN person, 0 AS messageCount\n}\nRETURN\n  person.id AS personId,\n  person.firstName AS personFirstName,\n  person.lastName AS personLastName,\n  person.creationDate AS personCreationDate,\n  sum(messageCount) AS messageCount\nORDER BY\n  messageCount DESC,\n  person.id ASC\nLIMIT 100\nUnparsed input: CALL {\n  WITH topForums\n  UNWIND topForums AS topForum1\n  MATCH (topForum1)-[:CONTAINER_OF]->(post:Post)<-[:REPLY_OF*0..]-(message:Message)-[:HAS_CREATOR]->(person:Person)<-[:HAS_MEMBER]-(topForum2:Forum)\n  WITH person, message, topForum2\n  WHERE topForum2 IN topForums\n  RETURN person, count(DISTINCT message) AS messageCount\nUNION ALL\n  WITH topForums\n  UNWIND topForums AS topForum1\n  MATCH (person:Person)<-[:HAS_MEMBER]-(topForum1:Forum)\n  RETURN person, 0 AS messageCount\n}\nRETURN\n  person.id AS personId,\n  person.firstName AS personFirstName,\n  person.lastName AS personLastName,\n  person.creationDate AS personCreationDate,\n  sum(messageCount) AS messageCount\nORDER BY\n  messageCount DESC,\n  person.id ASC\nLIMIT 100\n. Check Cypher syntax before proceeding.",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-5",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Identifier 'message.browserUsed' cannot be resolved from table with name message. In scope with_likeCount_message_person_cte_3 AS (SELECT anyLast(person.birthday) AS person_birthday, anyLast(person.browserUsed) AS person_browserUsed, anyLast(person.creationDate) AS person_creationDate, anyLast(person.firstName) AS person_firstName, anyLast(person.gender) AS person_gender, person.id AS person_id, anyLast(person.lastName) AS person_lastName, anyLast(person.locationIP) AS person_locationIP, anyLast(message.browserUsed) AS message_browserUsed, anyLast(message.content) AS message_content, anyLast(message.creationDate) AS message_creationDate, message.id AS message_id, anyLast(message.imageFile) AS message_imageFile, anyLast(message.language) AS message_language, anyLast(message.length) AS message_length, anyLast(message.locationIP) AS message_locationIP, anyLast(message.type) AS message_type, count(*) AS likeCount FROM ldbc.Person AS t113 LEFT JOIN ldbc.Person_likes_Message AS likes ON likes.PersonId = t113.id LEFT JOIN ldbc.Message_hasTag_Tag AS message ON message.MessageId = likes.MessageId INNER JOIN ldbc.Message_hasCreator_Person AS t112 ON t112.MessageId = message.MessageId INNER JOIN ldbc.Person AS person ON person.id = t112.PersonId WHERE tag.name = 'Abbas_I_of_Persia' GROUP BY person.id, message.id). (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-6",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 179. DB::Exception: Multiple table expressions with same alias t116. In scope SELECT person1.id AS `person1.id`, countDistinct((like.PersonId, like.MessageId)) AS authorityScore FROM ldbc.Message_hasTag_Tag AS t115 INNER JOIN ldbc.Message_hasCreator_Person AS t116 ON t116.MessageId = t115.CommentId INNER JOIN ldbc.Message AS message1 ON message1.id = t116.MessageId LEFT JOIN ldbc.Person_likes_Message AS t117 ON t117.MessageId = message1.id LEFT JOIN ldbc.Person AS person2 ON person2.id = t117.PersonId LEFT JOIN Message_hasCreator_Person AS t118 ON t118.PersonId = person2.id LEFT JOIN ldbc.Message AS message2 ON message2.id = t118.MessageId LEFT JOIN ldbc.Person_likes_Message AS like ON like.MessageId = message2.id LEFT JOIN ldbc.Person AS person3 ON person3.id = like.PersonId INNER JOIN ldbc.Message_hasCreator_Person AS t116 ON t116.PersonId = person1.id WHERE tag.name = 'Arnold_Schwarzenegger' GROUP BY person1.id ORDER BY authorityScore DESC, person1.id ASC LIMIT 100. (MULTIPLE_EXPRESSIONS_FOR_ALIAS) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-7",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Unknown expression or function identifier `t120.CommentId` in scope SELECT relatedTag.name AS `relatedTag.name`, countDistinct(comment.id) AS count FROM ldbc.Message_hasTag_Tag AS t119 INNER JOIN ldbc.Comment AS comment ON comment.id = t120.CommentId INNER JOIN ldbc.Comment_replyOf_Message AS t120 ON t120.MessageId = message.id INNER JOIN ldbc.Comment_hasTag_Tag AS t121 ON t121.CommentId = comment.id INNER JOIN ldbc.Tag AS relatedTag ON relatedTag.id = t121.TagId WHERE (NOT exists((SELECT 1 FROM ldbc.Comment_hasTag_Tag WHERE (Comment_hasTag_Tag.CommentId = comment.id) AND (Comment_hasTag_Tag.TagId = tag.id)))) AND (tag.name = 'Enrique_Iglesias') GROUP BY relatedTag.name ORDER BY count DESC, relatedTag.name ASC LIMIT 100. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-8",
      "status": "ERROR",
      "error": "('Connection aborted.', RemoteDisconnected('Remote end closed connection without response'))",
      "rows": null
    },
    {
      "category": "bi",
      "query": "bi-9",
      "status": "FAIL",
      "error": "Clickhouse Error: bad response: {\"exception\": \"Code: 47. DB::Exception: Identifier 'current_node.TargetMessageId' cannot be resolved from table with name current_node. In scope SELECT vp.start_id, end_node.TargetMessageId AS end_id, vp.hop_count + 1 AS hop_count, arrayConcat(vp.path_edges, [(rel.MessageId, rel.TargetMessageId)]) AS path_edges, arrayConcat(vp.path_relationships, ['REPLY_OF']) AS path_relationships, arrayConcat(vp.path_nodes, [end_node.TargetMessageId]) AS path_nodes FROM vlp_cte41 AS vp INNER JOIN ldbc.Post AS current_node ON vp.end_id = current_node.TargetMessageId INNER JOIN ldbc.Message_replyOf_Message AS rel ON current_node.TargetMessageId = rel.MessageId INNER JOIN ldbc.Post AS end_node ON rel.TargetMessageId = end_node.TargetMessageId WHERE (vp.hop_count < 3) AND (NOT has(vp.path_edges, (rel.MessageId, rel.TargetMessageId))) AND ((end_node.creationDate >= 'datetime(\\\\'2011-10-01\\\\')') AND (end_node.creationDate <= 'datetime(\\\\'2011-10-15\\\\')')). Maybe you meant: ['current_node.language']. (UNKNOWN_IDENTIFIER) (version 25.8.11.66 (official build))\"}",
      "rows": null
    }
  ],
  "summary": {
    "total": 41,
    "pass": 7,
    "fail": 33,
    "error": 1,
    "timeout": 0
  }
}