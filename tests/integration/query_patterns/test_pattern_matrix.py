"""
Auto-generated Query Pattern Ã— Schema Variation Tests

Generated by: tests/integration/query_patterns/test_generator.py

This file tests every query pattern against every schema type.
"""

import pytest
import requests
import os


CLICKGRAPH_URL = os.environ.get("CLICKGRAPH_URL", "http://localhost:8080")


def execute_query(query: str, schema_name: str = None) -> dict:
    """Execute a Cypher query against ClickGraph"""
    payload = {"query": query}
    if schema_name:
        payload["schema_name"] = schema_name
    
    response = requests.post(
        f"{CLICKGRAPH_URL}/query",
        json=payload,
        headers={"Content-Type": "application/json"},
        timeout=30,
    )
    return response.json() if response.status_code == 200 else {"error": response.text}


class TestStandardSchema:
    """Tests for standard schema type"""

    SCHEMA_YAML = "benchmarks/social_network/schemas/social_benchmark.yaml"

    def test_node_scan_0(self):
        """
        Basic node scan with single property
        Schema: social_benchmark
        """
        query = "MATCH (n:User) RETURN n.country LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_scan_1(self):
        """
        Basic node scan with single property
        Schema: social_benchmark
        """
        query = "MATCH (n:User) RETURN n.country LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_scan_2(self):
        """
        Basic node scan with single property
        Schema: social_benchmark
        """
        query = "MATCH (n:User) RETURN n.country LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_node_0(self):
        """
        Return whole node (wildcard expansion)
        Schema: social_benchmark
        """
        query = "MATCH (n:User) RETURN n LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_node_1(self):
        """
        Return whole node (wildcard expansion)
        Schema: social_benchmark
        """
        query = "MATCH (n:User) RETURN n LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_node_2(self):
        """
        Return whole node (wildcard expansion)
        Schema: social_benchmark
        """
        query = "MATCH (n:User) RETURN n LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_filter_0(self):
        """
        Node scan with IS NOT NULL filter
        Schema: social_benchmark
        """
        query = "MATCH (n:User) WHERE n.email IS NOT NULL RETURN n.email LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_filter_1(self):
        """
        Node scan with IS NOT NULL filter
        Schema: social_benchmark
        """
        query = "MATCH (n:User) WHERE n.is_active IS NOT NULL RETURN n.is_active LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_filter_2(self):
        """
        Node scan with IS NOT NULL filter
        Schema: social_benchmark
        """
        query = "MATCH (n:User) WHERE n.name IS NOT NULL RETURN n.name LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_single_hop_0(self):
        """
        Single hop relationship
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) RETURN a.is_active, b.is_active LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_single_hop_1(self):
        """
        Single hop relationship
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) RETURN a.city, b.city LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_single_hop_2(self):
        """
        Single hop relationship
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) RETURN a.city, b.city LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_rel_0(self):
        """
        Return whole relationship
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) RETURN r LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_rel_1(self):
        """
        Return whole relationship
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) RETURN r LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_rel_2(self):
        """
        Return whole relationship
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) RETURN r LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_multi_hop_0(self):
        """
        Multi-hop traversal
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r1:FOLLOWS]->(b:User)-[r2:FOLLOWS]->(c:User) RETURN a.is_active, c.is_active LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_multi_hop_1(self):
        """
        Multi-hop traversal
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r1:FOLLOWS]->(b:User)-[r2:FOLLOWS]->(c:User) RETURN a.email, c.email LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_multi_hop_2(self):
        """
        Multi-hop traversal
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r1:FOLLOWS]->(b:User)-[r2:FOLLOWS]->(c:User) RETURN a.is_active, c.is_active LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_exact_0(self):
        """
        Variable-length path with exact hops
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[:FOLLOWS*2]->(b:User) RETURN a.is_active, b.is_active LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_exact_1(self):
        """
        Variable-length path with exact hops
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[:FOLLOWS*2]->(b:User) RETURN a.user_id, b.user_id LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_exact_2(self):
        """
        Variable-length path with exact hops
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[:FOLLOWS*2]->(b:User) RETURN a.name, b.name LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_range_0(self):
        """
        Variable-length path with range
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[:FOLLOWS*1..3]->(b:User) RETURN a.user_id, b.user_id LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_range_1(self):
        """
        Variable-length path with range
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[:FOLLOWS*1..3]->(b:User) RETURN a.country, b.country LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_range_2(self):
        """
        Variable-length path with range
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[:FOLLOWS*1..3]->(b:User) RETURN a.email, b.email LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_path_var_0(self):
        """
        Path variable with functions
        Schema: social_benchmark
        """
        query = "MATCH p = (a:User)-[:FOLLOWS*1..3]->(b:User) RETURN length(p), nodes(p) LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_path_var_1(self):
        """
        Path variable with functions
        Schema: social_benchmark
        """
        query = "MATCH p = (a:User)-[:FOLLOWS*1..3]->(b:User) RETURN length(p), nodes(p) LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_path_var_2(self):
        """
        Path variable with functions
        Schema: social_benchmark
        """
        query = "MATCH p = (a:User)-[:FOLLOWS*1..3]->(b:User) RETURN length(p), nodes(p) LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_simple_agg_0(self):
        """
        Simple count aggregation
        Schema: social_benchmark
        """
        query = "MATCH (n:User) RETURN count(n)"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_simple_agg_1(self):
        """
        Simple count aggregation
        Schema: social_benchmark
        """
        query = "MATCH (n:User) RETURN count(n)"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_simple_agg_2(self):
        """
        Simple count aggregation
        Schema: social_benchmark
        """
        query = "MATCH (n:User) RETURN count(n)"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_group_by_0(self):
        """
        GROUP BY with count
        Schema: social_benchmark
        """
        query = "MATCH (n:User) RETURN n.is_active, count(n) AS cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_group_by_1(self):
        """
        GROUP BY with count
        Schema: social_benchmark
        """
        query = "MATCH (n:User) RETURN n.email, count(n) AS cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_group_by_2(self):
        """
        GROUP BY with count
        Schema: social_benchmark
        """
        query = "MATCH (n:User) RETURN n.is_active, count(n) AS cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_with_agg_0(self):
        """
        WITH clause aggregation
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) WITH a.user_id AS prop, count(r) AS cnt RETURN prop, cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_with_agg_1(self):
        """
        WITH clause aggregation
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) WITH a.user_id AS prop, count(r) AS cnt RETURN prop, cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_with_agg_2(self):
        """
        WITH clause aggregation
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) WITH a.email AS prop, count(r) AS cnt RETURN prop, cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_optional_match_0(self):
        """
        OPTIONAL MATCH with aggregation
        Schema: social_benchmark
        """
        query = "MATCH (a:User) OPTIONAL MATCH (a)-[r:FOLLOWS]->(b) RETURN a.city, count(r) AS rel_count"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_optional_match_1(self):
        """
        OPTIONAL MATCH with aggregation
        Schema: social_benchmark
        """
        query = "MATCH (a:User) OPTIONAL MATCH (a)-[r:FOLLOWS]->(b) RETURN a.is_active, count(r) AS rel_count"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_optional_match_2(self):
        """
        OPTIONAL MATCH with aggregation
        Schema: social_benchmark
        """
        query = "MATCH (a:User) OPTIONAL MATCH (a)-[r:FOLLOWS]->(b) RETURN a.is_active, count(r) AS rel_count"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_graph_funcs_0(self):
        """
        Graph functions (type, id, labels)
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) RETURN type(r), id(a), labels(a) LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_graph_funcs_1(self):
        """
        Graph functions (type, id, labels)
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) RETURN type(r), id(a), labels(a) LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_graph_funcs_2(self):
        """
        Graph functions (type, id, labels)
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) RETURN type(r), id(a), labels(a) LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Standard schema has only one cyclic relationship type (FOLLOWS)")
    def test_multi_type_0(self):
        """
        Multiple relationship types
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r:FOLLOWS|FOLLOWS]->(b:User) RETURN type(r), count(*) AS cnt"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Standard schema has only one cyclic relationship type (FOLLOWS)")
    def test_multi_type_1(self):
        """
        Multiple relationship types
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r:FOLLOWS|FOLLOWS]->(b:User) RETURN type(r), count(*) AS cnt"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Standard schema has only one cyclic relationship type (FOLLOWS)")
    def test_multi_type_2(self):
        """
        Multiple relationship types
        Schema: social_benchmark
        """
        query = "MATCH (a:User)-[r:FOLLOWS|FOLLOWS]->(b:User) RETURN type(r), count(*) AS cnt"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_order_limit_0(self):
        """
        ORDER BY with LIMIT and SKIP
        Schema: social_benchmark
        """
        query = "MATCH (n:User) WHERE n.email IS NOT NULL RETURN n.email ORDER BY n.email DESC SKIP 5 LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_order_limit_1(self):
        """
        ORDER BY with LIMIT and SKIP
        Schema: social_benchmark
        """
        query = "MATCH (n:User) WHERE n.email IS NOT NULL RETURN n.email ORDER BY n.email DESC SKIP 5 LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_order_limit_2(self):
        """
        ORDER BY with LIMIT and SKIP
        Schema: social_benchmark
        """
        query = "MATCH (n:User) WHERE n.is_active IS NOT NULL RETURN n.is_active ORDER BY n.is_active DESC SKIP 5 LIMIT 10"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_shortest_path_0(self):
        """
        Shortest path query
        Schema: social_benchmark
        """
        query = "MATCH p = shortestPath((a:User)-[:FOLLOWS*1..5]->(b:User)) WHERE a.email <> b.email RETURN length(p) LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_shortest_path_1(self):
        """
        Shortest path query
        Schema: social_benchmark
        """
        query = "MATCH p = shortestPath((a:User)-[:FOLLOWS*1..5]->(b:User)) WHERE a.country <> b.country RETURN length(p) LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"

    def test_shortest_path_2(self):
        """
        Shortest path query
        Schema: social_benchmark
        """
        query = "MATCH p = shortestPath((a:User)-[:FOLLOWS*1..5]->(b:User)) WHERE a.country <> b.country RETURN length(p) LIMIT 5"
        result = execute_query(query, "social_benchmark")
        assert "error" not in result, f"Query failed: {result}"


class TestDenormalizedSchema:
    """Tests for denormalized schema type"""

    SCHEMA_YAML = "schemas/examples/ontime_denormalized.yaml"

    def test_node_scan_0(self):
        """
        Basic node scan with single property
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) RETURN n.code LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_scan_1(self):
        """
        Basic node scan with single property
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) RETURN n.state LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_scan_2(self):
        """
        Basic node scan with single property
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) RETURN n.city LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Bug: Wildcard expansion doesn't use from/to_node_properties")
    def test_return_node_0(self):
        """
        Return whole node (wildcard expansion)
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) RETURN n LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Bug: Wildcard expansion doesn't use from/to_node_properties")
    def test_return_node_1(self):
        """
        Return whole node (wildcard expansion)
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) RETURN n LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Bug: Wildcard expansion doesn't use from/to_node_properties")
    def test_return_node_2(self):
        """
        Return whole node (wildcard expansion)
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) RETURN n LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_filter_0(self):
        """
        Node scan with IS NOT NULL filter
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) WHERE n.state IS NOT NULL RETURN n.state LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_filter_1(self):
        """
        Node scan with IS NOT NULL filter
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) WHERE n.city IS NOT NULL RETURN n.city LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_filter_2(self):
        """
        Node scan with IS NOT NULL filter
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) WHERE n.city IS NOT NULL RETURN n.city LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_single_hop_0(self):
        """
        Single hop relationship
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r:FLIGHT]->(b:Airport) RETURN a.code, b.code LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_single_hop_1(self):
        """
        Single hop relationship
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r:FLIGHT]->(b:Airport) RETURN a.city, b.city LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_single_hop_2(self):
        """
        Single hop relationship
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r:FLIGHT]->(b:Airport) RETURN a.city, b.city LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_rel_0(self):
        """
        Return whole relationship
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r:FLIGHT]->(b:Airport) RETURN r LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_rel_1(self):
        """
        Return whole relationship
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r:FLIGHT]->(b:Airport) RETURN r LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_rel_2(self):
        """
        Return whole relationship
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r:FLIGHT]->(b:Airport) RETURN r LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_multi_hop_0(self):
        """
        Multi-hop traversal
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r1:FLIGHT]->(b:Airport)-[r2:FLIGHT]->(c:Airport) RETURN a.city, c.city LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_multi_hop_1(self):
        """
        Multi-hop traversal
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r1:FLIGHT]->(b:Airport)-[r2:FLIGHT]->(c:Airport) RETURN a.state, c.state LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_multi_hop_2(self):
        """
        Multi-hop traversal
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r1:FLIGHT]->(b:Airport)-[r2:FLIGHT]->(c:Airport) RETURN a.code, c.code LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_exact_0(self):
        """
        Variable-length path with exact hops
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[:FLIGHT*2]->(b:Airport) RETURN a.code, b.code LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_exact_1(self):
        """
        Variable-length path with exact hops
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[:FLIGHT*2]->(b:Airport) RETURN a.code, b.code LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_exact_2(self):
        """
        Variable-length path with exact hops
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[:FLIGHT*2]->(b:Airport) RETURN a.state, b.state LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_range_0(self):
        """
        Variable-length path with range
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[:FLIGHT*1..3]->(b:Airport) RETURN a.airport, b.airport LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_range_1(self):
        """
        Variable-length path with range
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[:FLIGHT*1..3]->(b:Airport) RETURN a.state, b.state LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_range_2(self):
        """
        Variable-length path with range
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[:FLIGHT*1..3]->(b:Airport) RETURN a.city, b.city LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_path_var_0(self):
        """
        Path variable with functions
        Schema: ontime_flights
        """
        query = "MATCH p = (a:Airport)-[:FLIGHT*1..3]->(b:Airport) RETURN length(p), nodes(p) LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_path_var_1(self):
        """
        Path variable with functions
        Schema: ontime_flights
        """
        query = "MATCH p = (a:Airport)-[:FLIGHT*1..3]->(b:Airport) RETURN length(p), nodes(p) LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_path_var_2(self):
        """
        Path variable with functions
        Schema: ontime_flights
        """
        query = "MATCH p = (a:Airport)-[:FLIGHT*1..3]->(b:Airport) RETURN length(p), nodes(p) LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_simple_agg_0(self):
        """
        Simple count aggregation
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) RETURN count(n)"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_simple_agg_1(self):
        """
        Simple count aggregation
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) RETURN count(n)"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_simple_agg_2(self):
        """
        Simple count aggregation
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) RETURN count(n)"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_group_by_0(self):
        """
        GROUP BY with count
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) RETURN n.state, count(n) AS cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_group_by_1(self):
        """
        GROUP BY with count
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) RETURN n.airport, count(n) AS cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_group_by_2(self):
        """
        GROUP BY with count
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) RETURN n.state, count(n) AS cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_with_agg_0(self):
        """
        WITH clause aggregation
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r:FLIGHT]->(b:Airport) WITH a.airport AS prop, count(r) AS cnt RETURN prop, cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_with_agg_1(self):
        """
        WITH clause aggregation
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r:FLIGHT]->(b:Airport) WITH a.state AS prop, count(r) AS cnt RETURN prop, cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_with_agg_2(self):
        """
        WITH clause aggregation
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r:FLIGHT]->(b:Airport) WITH a.airport AS prop, count(r) AS cnt RETURN prop, cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_optional_match_0(self):
        """
        OPTIONAL MATCH with aggregation
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport) OPTIONAL MATCH (a)-[r:FLIGHT]->(b) RETURN a.city, count(r) AS rel_count"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_optional_match_1(self):
        """
        OPTIONAL MATCH with aggregation
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport) OPTIONAL MATCH (a)-[r:FLIGHT]->(b) RETURN a.airport, count(r) AS rel_count"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_optional_match_2(self):
        """
        OPTIONAL MATCH with aggregation
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport) OPTIONAL MATCH (a)-[r:FLIGHT]->(b) RETURN a.state, count(r) AS rel_count"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_graph_funcs_0(self):
        """
        Graph functions (type, id, labels)
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r:FLIGHT]->(b:Airport) RETURN type(r), id(a), labels(a) LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_graph_funcs_1(self):
        """
        Graph functions (type, id, labels)
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r:FLIGHT]->(b:Airport) RETURN type(r), id(a), labels(a) LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_graph_funcs_2(self):
        """
        Graph functions (type, id, labels)
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r:FLIGHT]->(b:Airport) RETURN type(r), id(a), labels(a) LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="N/A: Denormalized schema has single relationship type")
    def test_multi_type_0(self):
        """
        Multiple relationship types
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r:FLIGHT|FLIGHT]->(b:Airport) RETURN type(r), count(*) AS cnt"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="N/A: Denormalized schema has single relationship type")
    def test_multi_type_1(self):
        """
        Multiple relationship types
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r:FLIGHT|FLIGHT]->(b:Airport) RETURN type(r), count(*) AS cnt"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="N/A: Denormalized schema has single relationship type")
    def test_multi_type_2(self):
        """
        Multiple relationship types
        Schema: ontime_flights
        """
        query = "MATCH (a:Airport)-[r:FLIGHT|FLIGHT]->(b:Airport) RETURN type(r), count(*) AS cnt"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_order_limit_0(self):
        """
        ORDER BY with LIMIT and SKIP
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) WHERE n.code IS NOT NULL RETURN n.code ORDER BY n.code DESC SKIP 5 LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_order_limit_1(self):
        """
        ORDER BY with LIMIT and SKIP
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) WHERE n.city IS NOT NULL RETURN n.city ORDER BY n.city DESC SKIP 5 LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_order_limit_2(self):
        """
        ORDER BY with LIMIT and SKIP
        Schema: ontime_flights
        """
        query = "MATCH (n:Airport) WHERE n.city IS NOT NULL RETURN n.city ORDER BY n.city DESC SKIP 5 LIMIT 10"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_shortest_path_0(self):
        """
        Shortest path query
        Schema: ontime_flights
        """
        query = "MATCH p = shortestPath((a:Airport)-[:FLIGHT*1..5]->(b:Airport)) WHERE a.airport <> b.airport RETURN length(p) LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_shortest_path_1(self):
        """
        Shortest path query
        Schema: ontime_flights
        """
        query = "MATCH p = shortestPath((a:Airport)-[:FLIGHT*1..5]->(b:Airport)) WHERE a.airport <> b.airport RETURN length(p) LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"

    def test_shortest_path_2(self):
        """
        Shortest path query
        Schema: ontime_flights
        """
        query = "MATCH p = shortestPath((a:Airport)-[:FLIGHT*1..5]->(b:Airport)) WHERE a.city <> b.city RETURN length(p) LIMIT 5"
        result = execute_query(query, "ontime_flights")
        assert "error" not in result, f"Query failed: {result}"


class TestPolymorphicSchema:
    """Tests for polymorphic schema type"""

    SCHEMA_YAML = "schemas/examples/social_polymorphic.yaml"

    def test_node_scan_0(self):
        """
        Basic node scan with single property
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) RETURN n.user_id LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_scan_1(self):
        """
        Basic node scan with single property
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) RETURN n.name LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_scan_2(self):
        """
        Basic node scan with single property
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) RETURN n.name LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_node_0(self):
        """
        Return whole node (wildcard expansion)
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) RETURN n LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_node_1(self):
        """
        Return whole node (wildcard expansion)
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) RETURN n LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_node_2(self):
        """
        Return whole node (wildcard expansion)
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) RETURN n LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_filter_0(self):
        """
        Node scan with IS NOT NULL filter
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) WHERE n.email IS NOT NULL RETURN n.email LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_filter_1(self):
        """
        Node scan with IS NOT NULL filter
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) WHERE n.user_id IS NOT NULL RETURN n.user_id LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_filter_2(self):
        """
        Node scan with IS NOT NULL filter
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) WHERE n.user_id IS NOT NULL RETURN n.user_id LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_single_hop_0(self):
        """
        Single hop relationship
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) RETURN a.user_id, b.user_id LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_single_hop_1(self):
        """
        Single hop relationship
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r:LIKES]->(b:User) RETURN a.email, b.email LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_single_hop_2(self):
        """
        Single hop relationship
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r:LIKES]->(b:User) RETURN a.name, b.name LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_rel_0(self):
        """
        Return whole relationship
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) RETURN r LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_rel_1(self):
        """
        Return whole relationship
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) RETURN r LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_rel_2(self):
        """
        Return whole relationship
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r:AUTHORED]->(b:User) RETURN r LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_multi_hop_0(self):
        """
        Multi-hop traversal
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r1:AUTHORED]->(b:User)-[r2:FOLLOWS]->(c:User) RETURN a.email, c.email LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_multi_hop_1(self):
        """
        Multi-hop traversal
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r1:FOLLOWS]->(b:User)-[r2:LIKES]->(c:User) RETURN a.name, c.name LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_multi_hop_2(self):
        """
        Multi-hop traversal
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r1:FOLLOWS]->(b:User)-[r2:LIKES]->(c:User) RETURN a.email, c.email LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_exact_0(self):
        """
        Variable-length path with exact hops
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[:AUTHORED*2]->(b:User) RETURN a.name, b.name LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_exact_1(self):
        """
        Variable-length path with exact hops
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[:AUTHORED*2]->(b:User) RETURN a.name, b.name LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_exact_2(self):
        """
        Variable-length path with exact hops
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[:FOLLOWS*2]->(b:User) RETURN a.name, b.name LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_range_0(self):
        """
        Variable-length path with range
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[:AUTHORED*1..3]->(b:User) RETURN a.user_id, b.user_id LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_range_1(self):
        """
        Variable-length path with range
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[:AUTHORED*1..3]->(b:User) RETURN a.user_id, b.user_id LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_range_2(self):
        """
        Variable-length path with range
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[:LIKES*1..3]->(b:User) RETURN a.name, b.name LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_path_var_0(self):
        """
        Path variable with functions
        Schema: social_polymorphic
        """
        query = "MATCH p = (a:User)-[:AUTHORED*1..3]->(b:User) RETURN length(p), nodes(p) LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_path_var_1(self):
        """
        Path variable with functions
        Schema: social_polymorphic
        """
        query = "MATCH p = (a:User)-[:FOLLOWS*1..3]->(b:User) RETURN length(p), nodes(p) LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_vlp_path_var_2(self):
        """
        Path variable with functions
        Schema: social_polymorphic
        """
        query = "MATCH p = (a:User)-[:LIKES*1..3]->(b:User) RETURN length(p), nodes(p) LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_simple_agg_0(self):
        """
        Simple count aggregation
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) RETURN count(n)"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_simple_agg_1(self):
        """
        Simple count aggregation
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) RETURN count(n)"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_simple_agg_2(self):
        """
        Simple count aggregation
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) RETURN count(n)"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_group_by_0(self):
        """
        GROUP BY with count
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) RETURN n.name, count(n) AS cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_group_by_1(self):
        """
        GROUP BY with count
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) RETURN n.email, count(n) AS cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_group_by_2(self):
        """
        GROUP BY with count
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) RETURN n.email, count(n) AS cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_with_agg_0(self):
        """
        WITH clause aggregation
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r:LIKES]->(b:User) WITH a.email AS prop, count(r) AS cnt RETURN prop, cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_with_agg_1(self):
        """
        WITH clause aggregation
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r:AUTHORED]->(b:User) WITH a.user_id AS prop, count(r) AS cnt RETURN prop, cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_with_agg_2(self):
        """
        WITH clause aggregation
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r:LIKES]->(b:User) WITH a.name AS prop, count(r) AS cnt RETURN prop, cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_optional_match_0(self):
        """
        OPTIONAL MATCH with aggregation
        Schema: social_polymorphic
        """
        query = "MATCH (a:User) OPTIONAL MATCH (a)-[r:FOLLOWS]->(b) RETURN a.email, count(r) AS rel_count"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_optional_match_1(self):
        """
        OPTIONAL MATCH with aggregation
        Schema: social_polymorphic
        """
        query = "MATCH (a:User) OPTIONAL MATCH (a)-[r:LIKES]->(b) RETURN a.user_id, count(r) AS rel_count"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_optional_match_2(self):
        """
        OPTIONAL MATCH with aggregation
        Schema: social_polymorphic
        """
        query = "MATCH (a:User) OPTIONAL MATCH (a)-[r:AUTHORED]->(b) RETURN a.email, count(r) AS rel_count"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_graph_funcs_0(self):
        """
        Graph functions (type, id, labels)
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) RETURN type(r), id(a), labels(a) LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_graph_funcs_1(self):
        """
        Graph functions (type, id, labels)
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r:LIKES]->(b:User) RETURN type(r), id(a), labels(a) LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_graph_funcs_2(self):
        """
        Graph functions (type, id, labels)
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r:FOLLOWS]->(b:User) RETURN type(r), id(a), labels(a) LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_multi_type_0(self):
        """
        Multiple relationship types
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r:LIKES|FOLLOWS]->(b:User) RETURN type(r), count(*) AS cnt"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_multi_type_1(self):
        """
        Multiple relationship types
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r:FOLLOWS|LIKES]->(b:User) RETURN type(r), count(*) AS cnt"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_multi_type_2(self):
        """
        Multiple relationship types
        Schema: social_polymorphic
        """
        query = "MATCH (a:User)-[r:AUTHORED|FOLLOWS]->(b:User) RETURN type(r), count(*) AS cnt"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_order_limit_0(self):
        """
        ORDER BY with LIMIT and SKIP
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) WHERE n.user_id IS NOT NULL RETURN n.user_id ORDER BY n.user_id DESC SKIP 5 LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_order_limit_1(self):
        """
        ORDER BY with LIMIT and SKIP
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) WHERE n.email IS NOT NULL RETURN n.email ORDER BY n.email DESC SKIP 5 LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_order_limit_2(self):
        """
        ORDER BY with LIMIT and SKIP
        Schema: social_polymorphic
        """
        query = "MATCH (n:User) WHERE n.email IS NOT NULL RETURN n.email ORDER BY n.email DESC SKIP 5 LIMIT 10"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_shortest_path_0(self):
        """
        Shortest path query
        Schema: social_polymorphic
        """
        query = "MATCH p = shortestPath((a:User)-[:LIKES*1..5]->(b:User)) WHERE a.name <> b.name RETURN length(p) LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_shortest_path_1(self):
        """
        Shortest path query
        Schema: social_polymorphic
        """
        query = "MATCH p = shortestPath((a:User)-[:AUTHORED*1..5]->(b:User)) WHERE a.user_id <> b.user_id RETURN length(p) LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"

    def test_shortest_path_2(self):
        """
        Shortest path query
        Schema: social_polymorphic
        """
        query = "MATCH p = shortestPath((a:User)-[:LIKES*1..5]->(b:User)) WHERE a.user_id <> b.user_id RETURN length(p) LIMIT 5"
        result = execute_query(query, "social_polymorphic")
        assert "error" not in result, f"Query failed: {result}"


class TestCoupledSchema:
    """Tests for coupled schema type"""

    SCHEMA_YAML = "schemas/examples/zeek_dns_log.yaml"

    def test_node_scan_0(self):
        """
        Basic node scan with single property
        Schema: zeek_dns
        """
        query = "MATCH (n:IP) RETURN n.ip_address LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_scan_1(self):
        """
        Basic node scan with single property
        Schema: zeek_dns
        """
        query = "MATCH (n:Domain) RETURN n.domain_name LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_scan_2(self):
        """
        Basic node scan with single property
        Schema: zeek_dns
        """
        query = "MATCH (n:Domain) RETURN n.domain_name LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_node_0(self):
        """
        Return whole node (wildcard expansion)
        Schema: zeek_dns
        """
        query = "MATCH (n:IP) RETURN n LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_node_1(self):
        """
        Return whole node (wildcard expansion)
        Schema: zeek_dns
        """
        query = "MATCH (n:IP) RETURN n LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_node_2(self):
        """
        Return whole node (wildcard expansion)
        Schema: zeek_dns
        """
        query = "MATCH (n:Domain) RETURN n LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_filter_0(self):
        """
        Node scan with IS NOT NULL filter
        Schema: zeek_dns
        """
        query = "MATCH (n:IP) WHERE n.ip_address IS NOT NULL RETURN n.ip_address LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_filter_1(self):
        """
        Node scan with IS NOT NULL filter
        Schema: zeek_dns
        """
        query = "MATCH (n:IP) WHERE n.ip_address IS NOT NULL RETURN n.ip_address LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_node_filter_2(self):
        """
        Node scan with IS NOT NULL filter
        Schema: zeek_dns
        """
        query = "MATCH (n:IP) WHERE n.ip_address IS NOT NULL RETURN n.ip_address LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_single_hop_0(self):
        """
        Single hop relationship
        Schema: zeek_dns
        """
        query = "MATCH (a:IP)-[r:REQUESTED]->(b:Domain) RETURN a.ip_address, b.domain_name LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_single_hop_1(self):
        """
        Single hop relationship
        Schema: zeek_dns
        """
        query = "MATCH (a:Domain)-[r:RESOLVED_TO]->(b:ResolvedIP) RETURN a.domain_name, b.resolved_ip LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_single_hop_2(self):
        """
        Single hop relationship
        Schema: zeek_dns
        """
        query = "MATCH (a:Domain)-[r:RESOLVED_TO]->(b:ResolvedIP) RETURN a.domain_name, b.resolved_ip LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_rel_0(self):
        """
        Return whole relationship
        Schema: zeek_dns
        """
        query = "MATCH (a:IP)-[r:REQUESTED]->(b:Domain) RETURN r LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_rel_1(self):
        """
        Return whole relationship
        Schema: zeek_dns
        """
        query = "MATCH (a:Domain)-[r:RESOLVED_TO]->(b:ResolvedIP) RETURN r LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_return_rel_2(self):
        """
        Return whole relationship
        Schema: zeek_dns
        """
        query = "MATCH (a:IP)-[r:REQUESTED]->(b:Domain) RETURN r LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for homogeneous multi-hop")
    def test_multi_hop_0(self):
        """
        Multi-hop traversal
        Schema: zeek_dns
        """
        query = "MATCH (a:IP)-[r1:REQUESTED]->(b:IP)-[r2:REQUESTED]->(c:IP) RETURN a.ip_address, c.ip_address LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for homogeneous multi-hop")
    def test_multi_hop_1(self):
        """
        Multi-hop traversal
        Schema: zeek_dns
        """
        query = "MATCH (a:Domain)-[r1:REQUESTED]->(b:Domain)-[r2:REQUESTED]->(c:Domain) RETURN a.domain_name, c.domain_name LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for homogeneous multi-hop")
    def test_multi_hop_2(self):
        """
        Multi-hop traversal
        Schema: zeek_dns
        """
        query = "MATCH (a:Domain)-[r1:REQUESTED]->(b:Domain)-[r2:REQUESTED]->(c:Domain) RETURN a.domain_name, c.domain_name LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for VLP")
    def test_vlp_exact_0(self):
        """
        Variable-length path with exact hops
        Schema: zeek_dns
        """
        query = "MATCH (a:IP)-[:REQUESTED*2]->(b:IP) RETURN a.ip_address, b.ip_address LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for VLP")
    def test_vlp_exact_1(self):
        """
        Variable-length path with exact hops
        Schema: zeek_dns
        """
        query = "MATCH (a:ResolvedIP)-[:REQUESTED*2]->(b:ResolvedIP) RETURN a.resolved_ip, b.resolved_ip LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for VLP")
    def test_vlp_exact_2(self):
        """
        Variable-length path with exact hops
        Schema: zeek_dns
        """
        query = "MATCH (a:Domain)-[:REQUESTED*2]->(b:Domain) RETURN a.domain_name, b.domain_name LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for VLP")
    def test_vlp_range_0(self):
        """
        Variable-length path with range
        Schema: zeek_dns
        """
        query = "MATCH (a:ResolvedIP)-[:REQUESTED*1..3]->(b:ResolvedIP) RETURN a.resolved_ip, b.resolved_ip LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for VLP")
    def test_vlp_range_1(self):
        """
        Variable-length path with range
        Schema: zeek_dns
        """
        query = "MATCH (a:Domain)-[:REQUESTED*1..3]->(b:Domain) RETURN a.domain_name, b.domain_name LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for VLP")
    def test_vlp_range_2(self):
        """
        Variable-length path with range
        Schema: zeek_dns
        """
        query = "MATCH (a:IP)-[:REQUESTED*1..3]->(b:IP) RETURN a.ip_address, b.ip_address LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for VLP")
    def test_vlp_path_var_0(self):
        """
        Path variable with functions
        Schema: zeek_dns
        """
        query = "MATCH p = (a:ResolvedIP)-[:REQUESTED*1..3]->(b:ResolvedIP) RETURN length(p), nodes(p) LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for VLP")
    def test_vlp_path_var_1(self):
        """
        Path variable with functions
        Schema: zeek_dns
        """
        query = "MATCH p = (a:IP)-[:REQUESTED*1..3]->(b:IP) RETURN length(p), nodes(p) LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for VLP")
    def test_vlp_path_var_2(self):
        """
        Path variable with functions
        Schema: zeek_dns
        """
        query = "MATCH p = (a:ResolvedIP)-[:REQUESTED*1..3]->(b:ResolvedIP) RETURN length(p), nodes(p) LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_simple_agg_0(self):
        """
        Simple count aggregation
        Schema: zeek_dns
        """
        query = "MATCH (n:IP) RETURN count(n)"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_simple_agg_1(self):
        """
        Simple count aggregation
        Schema: zeek_dns
        """
        query = "MATCH (n:Domain) RETURN count(n)"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_simple_agg_2(self):
        """
        Simple count aggregation
        Schema: zeek_dns
        """
        query = "MATCH (n:Domain) RETURN count(n)"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_group_by_0(self):
        """
        GROUP BY with count
        Schema: zeek_dns
        """
        query = "MATCH (n:IP) RETURN n.ip_address, count(n) AS cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_group_by_1(self):
        """
        GROUP BY with count
        Schema: zeek_dns
        """
        query = "MATCH (n:Domain) RETURN n.domain_name, count(n) AS cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_group_by_2(self):
        """
        GROUP BY with count
        Schema: zeek_dns
        """
        query = "MATCH (n:IP) RETURN n.ip_address, count(n) AS cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="No cyclic relationships available")
    def test_with_agg_0(self):
        """
        WITH clause aggregation
        Schema: zeek_dns
        """
        query = "MATCH (a:Domain)-[r:RESOLVED_TO]->(b:ResolvedIP) WITH a.domain_name AS prop, count(r) AS cnt RETURN prop, cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="No cyclic relationships available")
    def test_with_agg_1(self):
        """
        WITH clause aggregation
        Schema: zeek_dns
        """
        query = "MATCH (a:IP)-[r:REQUESTED]->(b:Domain) WITH a.ip_address AS prop, count(r) AS cnt RETURN prop, cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="No cyclic relationships available")
    def test_with_agg_2(self):
        """
        WITH clause aggregation
        Schema: zeek_dns
        """
        query = "MATCH (a:Domain)-[r:RESOLVED_TO]->(b:ResolvedIP) WITH a.domain_name AS prop, count(r) AS cnt RETURN prop, cnt ORDER BY cnt DESC LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_optional_match_0(self):
        """
        OPTIONAL MATCH with aggregation
        Schema: zeek_dns
        """
        query = "MATCH (a:Domain) OPTIONAL MATCH (a)-[r:RESOLVED_TO]->(b) RETURN a.domain_name, count(r) AS rel_count"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_optional_match_1(self):
        """
        OPTIONAL MATCH with aggregation
        Schema: zeek_dns
        """
        query = "MATCH (a:IP) OPTIONAL MATCH (a)-[r:REQUESTED]->(b) RETURN a.ip_address, count(r) AS rel_count"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_optional_match_2(self):
        """
        OPTIONAL MATCH with aggregation
        Schema: zeek_dns
        """
        query = "MATCH (a:Domain) OPTIONAL MATCH (a)-[r:RESOLVED_TO]->(b) RETURN a.domain_name, count(r) AS rel_count"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_graph_funcs_0(self):
        """
        Graph functions (type, id, labels)
        Schema: zeek_dns
        """
        query = "MATCH (a:IP)-[r:REQUESTED]->(b:Domain) RETURN type(r), id(a), labels(a) LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_graph_funcs_1(self):
        """
        Graph functions (type, id, labels)
        Schema: zeek_dns
        """
        query = "MATCH (a:IP)-[r:REQUESTED]->(b:Domain) RETURN type(r), id(a), labels(a) LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    def test_graph_funcs_2(self):
        """
        Graph functions (type, id, labels)
        Schema: zeek_dns
        """
        query = "MATCH (a:IP)-[r:REQUESTED]->(b:Domain) RETURN type(r), id(a), labels(a) LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for multi-type traversal")
    def test_multi_type_0(self):
        """
        Multiple relationship types
        Schema: zeek_dns
        """
        query = "MATCH (a:ResolvedIP)-[r:REQUESTED|REQUESTED]->(b:ResolvedIP) RETURN type(r), count(*) AS cnt"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for multi-type traversal")
    def test_multi_type_1(self):
        """
        Multiple relationship types
        Schema: zeek_dns
        """
        query = "MATCH (a:Domain)-[r:REQUESTED|REQUESTED]->(b:Domain) RETURN type(r), count(*) AS cnt"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for multi-type traversal")
    def test_multi_type_2(self):
        """
        Multiple relationship types
        Schema: zeek_dns
        """
        query = "MATCH (a:ResolvedIP)-[r:REQUESTED|REQUESTED]->(b:ResolvedIP) RETURN type(r), count(*) AS cnt"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for shortest path")
    def test_order_limit_0(self):
        """
        ORDER BY with LIMIT and SKIP
        Schema: zeek_dns
        """
        query = "MATCH (n:IP) WHERE n.ip_address IS NOT NULL RETURN n.ip_address ORDER BY n.ip_address DESC SKIP 5 LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for shortest path")
    def test_order_limit_1(self):
        """
        ORDER BY with LIMIT and SKIP
        Schema: zeek_dns
        """
        query = "MATCH (n:Domain) WHERE n.domain_name IS NOT NULL RETURN n.domain_name ORDER BY n.domain_name DESC SKIP 5 LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for shortest path")
    def test_order_limit_2(self):
        """
        ORDER BY with LIMIT and SKIP
        Schema: zeek_dns
        """
        query = "MATCH (n:IP) WHERE n.ip_address IS NOT NULL RETURN n.ip_address ORDER BY n.ip_address DESC SKIP 5 LIMIT 10"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for shortest path")
    def test_shortest_path_0(self):
        """
        Shortest path query
        Schema: zeek_dns
        """
        query = "MATCH p = shortestPath((a:ResolvedIP)-[:REQUESTED*1..5]->(b:ResolvedIP)) WHERE a.resolved_ip <> b.resolved_ip RETURN length(p) LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for shortest path")
    def test_shortest_path_1(self):
        """
        Shortest path query
        Schema: zeek_dns
        """
        query = "MATCH p = shortestPath((a:IP)-[:REQUESTED*1..5]->(b:IP)) WHERE a.ip_address <> b.ip_address RETURN length(p) LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"

    @pytest.mark.xfail(reason="Schema has no cyclic relationships for shortest path")
    def test_shortest_path_2(self):
        """
        Shortest path query
        Schema: zeek_dns
        """
        query = "MATCH p = shortestPath((a:ResolvedIP)-[:REQUESTED*1..5]->(b:ResolvedIP)) WHERE a.resolved_ip <> b.resolved_ip RETURN length(p) LIMIT 5"
        result = execute_query(query, "zeek_dns")
        assert "error" not in result, f"Query failed: {result}"


