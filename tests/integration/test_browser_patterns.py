"""
Comprehensive test suite for Neo4j Browser interaction patterns.

These tests cover all query patterns generated by Neo4j Browser when users:
- Click on nodes (expand relationships)
- Click on relationship types
- Click on relationship directions
- Filter by labels
- Use the query bar

Schema: social_integration (User, Post, FOLLOWS, AUTHORED, LIKED)
"""

import pytest
import requests

BASE_URL = "http://localhost:8080"
SCHEMA_NAME = "social_integration"

def query(cypher_query, schema_name=SCHEMA_NAME):
    """Execute a Cypher query against ClickGraph"""
    response = requests.post(
        f"{BASE_URL}/query",
        json={"query": cypher_query, "schema_name": schema_name}
    )
    return response

def query_sql_only(cypher_query, schema_name=SCHEMA_NAME):
    """Get generated SQL without executing"""
    response = requests.post(
        f"{BASE_URL}/query",
        json={"query": cypher_query, "schema_name": schema_name, "sql_only": True}
    )
    return response


class TestBrowserNodeExpansion:
    """Tests for clicking on nodes to expand relationships"""
    
    @pytest.mark.xfail(reason="Code bug: untyped undirected rel with type(r)/labels(m) generates invalid CTE column references")
    def test_expand_labeled_node_all_relationships(self):
        """Browser: Click node → Expand (shows all relationship types)"""
        # Browser generates: MATCH (n:User) WHERE id(n) = 123 MATCH (n)-[r]-(m) RETURN *
        # Simplified test version:
        response = query("MATCH (n:User)-[r]-(m) WHERE n.user_id = 1 RETURN type(r) as rel_type, labels(m)[0] as target_label")
        assert response.status_code == 200
        data = response.json()
        # Should show FOLLOWS, AUTHORED, LIKED relationships
        assert len(data["results"]) > 0
    
    def test_expand_node_specific_relationship_type(self):
        """Browser: Click node → Expand specific type (e.g., FOLLOWS only)"""
        response = query("MATCH (n:User)-[r:FOLLOWS]->(m) WHERE n.user_id = 1 RETURN count(*) as count")
        assert response.status_code == 200
        data = response.json()
        assert "count" in data["results"][0]
    
    @pytest.mark.xfail(reason="Code bug: untyped directed rel UNION CTE generates invalid column references")
    def test_expand_node_outgoing_only(self):
        """Browser: Click node → Expand outgoing relationships only"""
        response = query("MATCH (n:User)-[r]->(m) WHERE n.user_id = 1 RETURN count(*) as count")
        assert response.status_code == 200
        data = response.json()
        # User can have outgoing FOLLOWS, AUTHORED, LIKED
        assert data["results"][0]["count"] > 0
    
    def test_expand_node_incoming_only(self):
        """Browser: Click node → Expand incoming relationships only"""
        response = query("MATCH (n:User)<-[r]-(m) WHERE n.user_id = 1 RETURN count(*) as count")
        assert response.status_code == 200
        # User might have incoming FOLLOWS
        # Empty result is OK if user has no followers


class TestBrowserRelationshipTypeClick:
    """Tests for clicking on relationship type badges in browser"""
    
    def test_click_relationship_type_undirected(self):
        """Browser: Click FOLLOWS badge → Shows all FOLLOWS relationships (undirected)"""
        # THIS IS THE FAILING CASE!
        response = query("MATCH ()-[r:FOLLOWS]-() RETURN r LIMIT 25")
        assert response.status_code == 200
        data = response.json()
        assert len(data["results"]) > 0
    
    def test_click_relationship_type_directed_outgoing(self):
        """Browser: Click FOLLOWS badge → Filter to outgoing only"""
        response = query("MATCH ()-[r:FOLLOWS]->() RETURN r LIMIT 25")
        assert response.status_code == 200
        data = response.json()
        assert len(data["results"]) > 0
    
    def test_click_relationship_type_directed_incoming(self):
        """Browser: Click FOLLOWS badge → Filter to incoming only"""
        response = query("MATCH ()<-[r:FOLLOWS]-() RETURN r LIMIT 25")
        assert response.status_code == 200
        data = response.json()
        assert len(data["results"]) > 0
    
    def test_click_liked_relationship_undirected(self):
        """Browser: Click LIKED badge (User→Post relationship)"""
        # CRITICAL: LIKED only exists as User→Post in schema
        response = query("MATCH ()-[r:LIKED]-() RETURN r LIMIT 25")
        assert response.status_code == 200
        data = response.json()
        assert len(data["results"]) > 0
        # Verify all results are User→Post (not Post→User or User→User)
        # Note: We can't easily verify direction from results without property checks
    
    def test_click_liked_relationship_directed(self):
        """Browser: Click LIKED badge with direction filter"""
        response = query("MATCH ()-[r:LIKED]->() RETURN r LIMIT 25")
        assert response.status_code == 200
        data = response.json()
        assert len(data["results"]) > 0
    
    def test_click_authored_relationship(self):
        """Browser: Click AUTHORED badge (User→Post relationship)"""
        response = query("MATCH ()-[r:AUTHORED]-() RETURN r LIMIT 25")
        assert response.status_code == 200
        data = response.json()
        assert len(data["results"]) > 0


class TestBrowserLabelCombinations:
    """Tests for various label combinations"""
    
    def test_both_nodes_labeled(self):
        """Browser: Filter specific node types"""
        response = query("MATCH (u:User)-[r:FOLLOWS]->(f:User) RETURN count(*) as count")
        assert response.status_code == 200
    
    def test_one_node_labeled_left(self):
        """Browser: One side filtered"""
        response = query("MATCH (u:User)-[r:FOLLOWS]->() RETURN count(*) as count")
        assert response.status_code == 200
    
    def test_one_node_labeled_right(self):
        """Browser: Other side filtered"""
        response = query("MATCH ()-[r:FOLLOWS]->(u:User) RETURN count(*) as count")
        assert response.status_code == 200
    
    def test_unlabeled_nodes_labeled_relationship(self):
        """Browser: Only relationship type known (THE CRITICAL BUG!)"""
        # This should create ONLY valid combinations based on schema:
        # FOLLOWS: User→User only
        response = query("MATCH ()-[r:FOLLOWS]->() RETURN count(*) as count")
        assert response.status_code == 200
        
        # LIKED: User→Post only (NOT User→User or Post→User!)
        response = query("MATCH ()-[r:LIKED]->() RETURN count(*) as count")
        assert response.status_code == 200
        
        # AUTHORED: User→Post only
        response = query("MATCH ()-[r:AUTHORED]->() RETURN count(*) as count")
        assert response.status_code == 200
    
    def test_unlabeled_nodes_unlabeled_relationship(self):
        """Browser: No filters (show everything)"""
        response = query("MATCH ()-[r]-() RETURN count(*) as count")
        assert response.status_code == 200


class TestBrowserPathQueries:
    """Tests for path patterns (click and drag in browser)"""
    
    def test_path_return(self):
        """Browser: Return path object"""
        response = query("MATCH p=(u:User)-[r:FOLLOWS]->(f:User) RETURN p LIMIT 5")
        assert response.status_code == 200
    
    def test_path_with_unlabeled_nodes(self):
        """Browser: Path with unlabeled nodes"""
        response = query("MATCH p=()-[r:FOLLOWS]->() RETURN p LIMIT 5")
        assert response.status_code == 200
    
    @pytest.mark.xfail(reason="Code bug: VLP on social_integration generates invalid SQL")
    def test_variable_length_path(self):
        """Browser: Variable length exploration"""
        response = query("MATCH p=(u:User)-[:FOLLOWS*1..2]->(f:User) RETURN count(*) as count")
        assert response.status_code == 200


class TestBrowserDirectionValidation:
    """Tests specifically for direction validation (the consolidation fix)"""
    
    def test_valid_direction_user_to_post(self):
        """Schema defines User→Post for LIKED"""
        response = query("MATCH (u:User)-[r:LIKED]->(p:Post) RETURN count(*) as count")
        assert response.status_code == 200
        data = response.json()
        assert data["results"][0]["count"] > 0
    
    def test_invalid_direction_post_to_user(self):
        """Post→User for LIKED should return error (schema doesn't define this direction)"""
        response = query("MATCH (p:Post)-[r:LIKED]->(u:User) RETURN count(*) as count")
        # Returns 400 because schema only defines User→Post for LIKED
        assert response.status_code == 400
    
    def test_undirected_respects_schema_direction(self):
        """Undirected LIKED should only match User→Post, not reverse"""
        response = query("MATCH (u:User)-[r:LIKED]-(p:Post) RETURN count(*) as count")
        assert response.status_code == 200
        # Should match the same as directed query (schema only defines one direction)


class TestBrowserComplexPatterns:
    """Tests for complex browser-generated patterns"""
    
    def test_multiple_relationships(self):
        """Browser: Multiple relationship patterns in one query"""
        response = query("""
            MATCH (u:User)-[r1:AUTHORED]->(p:Post)
            MATCH (u)-[r2:FOLLOWS]->(f:User)
            RETURN count(*) as count
        """)
        assert response.status_code == 200
    
    def test_optional_match(self):
        """Browser: Optional relationships"""
        response = query("""
            MATCH (u:User)
            OPTIONAL MATCH (u)-[r:FOLLOWS]->(f:User)
            RETURN u.user_id, count(r) as follow_count
            LIMIT 5
        """)
        assert response.status_code == 200
    
    def test_aggregation_with_grouping(self):
        """Browser: Aggregate queries"""
        response = query("""
            MATCH (u:User)-[r:FOLLOWS]->()
            RETURN u.user_id, count(r) as follow_count
            ORDER BY follow_count DESC
            LIMIT 10
        """)
        assert response.status_code == 200


class TestBrowserErrorCases:
    """Tests for error handling in browser scenarios"""
    
    def test_nonexistent_label(self):
        """Browser: User types invalid label"""
        response = query("MATCH (n:NonExistent) RETURN n")
        assert response.status_code == 400  # Planning error: label not found
    
    def test_nonexistent_relationship_type(self):
        """Browser: User types invalid relationship type"""
        response = query("MATCH ()-[r:NONEXISTENT]->() RETURN r")
        assert response.status_code == 400  # Planning error: relationship type not found
    
    def test_impossible_pattern(self):
        """Browser: Pattern that violates schema"""
        # Post has no outgoing relationships in schema
        response = query("MATCH (p:Post)-[r]->(n) RETURN count(*) as count")
        assert response.status_code == 200
        # Should return 0 or empty


class TestBrowserSQLGeneration:
    """Tests that verify SQL generation for browser patterns"""
    
    def test_sql_for_unlabeled_relationship_click(self):
        """Verify SQL doesn't create invalid joins"""
        response = query_sql_only("MATCH ()-[r:LIKED]->() RETURN r LIMIT 25")
        assert response.status_code == 200
        sql = response.json()["generated_sql"]
        
        # SQL should reference the LIKED edge table (post_likes_test)
        assert "post_likes_test" in sql.lower()
        
        # SQL should NOT try to join users to users via post_id
        lines = sql.lower().split('\n')
        for i, line in enumerate(lines):
            if 'users_test as t' in line and i+2 < len(lines):
                next_lines = ' '.join(lines[i:i+3])
                if 'join' in next_lines and 'users_test' in next_lines:
                    assert 'post_id' not in next_lines, "Invalid join: users_test.post_id doesn't exist!"


if __name__ == "__main__":
    # Run with: python -m pytest tests/integration/test_browser_patterns.py -v
    pytest.main([__file__, "-v", "--tb=short"])
