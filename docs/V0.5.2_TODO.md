# v0.5.2 Release TODO

**Target**: Complete polymorphic edge support and code consolidation  
**Created**: November 28, 2025  
**Status**: In Progress

---

## âœ… Completed Features (v0.5.2)

| Feature | Date | Notes |
|---------|------|-------|
| Denormalized Edge Tables | Nov 27 | Full support including multi-hop, VLP, algorithms |
| Coupled Edges Optimization | Nov 28 | Alias unification, JOIN elimination |
| VLP + UNWIND | Nov 28 | Pulled forward from Phase 5 |
| Edge ID (single/composite) | Earlier | `edge_id: [col1, col2]` works |
| Property mapping to expressions | Earlier | Expression-based properties |
| Filter support | Earlier | Schema-level filters |
| Array support + UNWIND | Nov 28 | ARRAY JOIN generation |

---

## ðŸ“‹ TODO: Polymorphic Edge Query Support

### Phase 1: Standard Query Patterns
- [ ] **Single edge type filter**: `MATCH (a)-[:FOLLOWS]->(b)` â†’ `WHERE type_column = 'FOLLOWS'`
- [ ] **Multiple edge types**: `MATCH (a)-[:FOLLOWS|LIKES]->(b)` â†’ `WHERE type_column IN ('FOLLOWS', 'LIKES')`
- [ ] **Any edge type (wildcard)**: `MATCH (a)-[r]->(b)` â†’ No type filter (all types from polymorphic table)
- [ ] **Edge property access**: `RETURN r.type` â†’ Returns `type_column` value
- [ ] **Dynamic node type resolution**: Use `from_label_column`/`to_label_column` for JOIN

### Phase 2: VLP with Polymorphic Edges
- [ ] **Variable-length paths**: `MATCH (a)-[r*1..3]->(b)` with polymorphic table
- [ ] **Path with edge type filter**: `MATCH p = (a)-[:FOLLOWS*1..2]->(b)`

### Phase 3: Subgraph Extraction Pattern
- [ ] **Triple return format**: `RETURN head.id, r.type, tail.id`
- [ ] **Verify with VLP**: `MATCH (head)-[r*1..2]->(tail) WHERE head.id = X RETURN head.id, r.type, tail.id`
- [ ] **Document Nebula-equivalent syntax** in wiki

---

## ðŸ“‹ TODO: Code Consolidation

### Schema Loading Refactor
- [ ] **Extract shared logic** from `to_graph_schema()` and `to_graph_schema_with_client()`
  - `build_node_schema(node_def, discovered_cols: Option<Vec<String>>) -> NodeSchema`
  - `build_relationship_schema(rel_def, discovered_cols: Option<_>) -> RelationshipSchema`
  - `build_edge_schema(edge_def, nodes: &HashMap<_, NodeSchema>, discovered_cols: Option<_>) -> RelationshipSchema`
- [ ] **Refactor to_graph_schema()** to use shared builders (no discovery)
- [ ] **Refactor to_graph_schema_with_client()** to use shared builders (with discovery)
- [ ] **Add tests** to ensure both paths produce equivalent results (without auto-discovery features)

### Benefits
- Single source of truth for schema conversion logic
- Easier maintenance when adding new schema features
- Reduced risk of divergence between sync/async paths

---

## ðŸ“‹ TODO: Documentation

- [ ] Update `docs/wiki/Schema-Polymorphic-Edges.md` status from "Production-ready" to actual status
- [ ] Add subgraph extraction section to wiki (Nebula GET SUBGRAPH equivalent)
- [ ] Update `STATUS.md` when polymorphic edges complete
- [ ] Update `CHANGELOG.md` with v0.5.2 features

---

## ðŸ”® Future (Not v0.5.2)

### Nested Object Returns (v0.6.0+)
- Map literal syntax: `RETURN {head: head, edge: r, tail: tail}`
- JSON object generation in ClickHouse
- Useful for GraphRAG context extraction

### Subgraph Extraction for GraphRAG (Phase 5 / v0.8.0+)
- Context window extraction for LLM prompts
- Different from basic triple returns
- Requires more sophisticated result formatting

---

## Implementation Order

**Recommended sequence:**

1. **Code Consolidation** (1-2 hours)
   - Lower risk, improves maintainability
   - Do before adding new features to polymorphic edge handling

2. **Polymorphic Edge Phase 1** (2-3 hours)
   - Core query pattern support
   - Most impactful for users

3. **Polymorphic Edge Phase 2** (1-2 hours)
   - VLP support builds on Phase 1

4. **Subgraph Pattern Verification** (1 hour)
   - May already work once Phase 1-2 complete
   - Mostly documentation

5. **Documentation** (1 hour)
   - Update wiki and status docs

**Total estimated effort**: 6-9 hours

---

## Testing Checklist

### Polymorphic Edge Tests
- [ ] Unit tests for type_column filter generation
- [ ] Unit tests for multiple type filtering (IN clause)
- [ ] Unit tests for wildcard edge matching
- [ ] Integration test with polymorphic schema
- [ ] E2E test with actual ClickHouse data

### Schema Loading Tests
- [ ] Test sync path produces same schema as async (when no auto-discover)
- [ ] Test async path with auto-discover enabled
- [ ] Test polymorphic edge expansion (N schemas from 1 config)

---

## Quick Reference

### Polymorphic Edge Schema Example
```yaml
edges:
  - polymorphic: true
    table: interactions
    type_column: interaction_type      # Edge type stored here
    from_label_column: from_type       # Source node type
    to_label_column: to_type           # Target node type
    from_id: from_id
    to_id: to_id
    type_values: [FOLLOWS, LIKES, AUTHORED]
```

### Expected SQL Generation
```cypher
MATCH (a:User)-[:FOLLOWS]->(b)
```
Should generate:
```sql
SELECT ...
FROM interactions AS r
JOIN users AS a ON a.id = r.from_id
JOIN users AS b ON b.id = r.to_id  -- or dynamic based on to_label_column
WHERE r.interaction_type = 'FOLLOWS'
  AND r.from_type = 'User'
  AND r.to_type = 'User'  -- if node types specified
```
