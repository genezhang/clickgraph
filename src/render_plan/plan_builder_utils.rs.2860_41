//! Pure utility functions for plan building
//!
//! This module contains utility functions that have no dependencies on LogicalPlan
//! or complex state. These are safe to extract early in the refactoring process.
//!
//! Functions in this module should be:
//! - Pure (no side effects)
//! - Independent of LogicalPlan structure
//! - Reusable across different builder modules

use crate::render_plan::plan_builder::RenderPlanBuilder;
use crate::render_plan::plan_builder::rewrite_expression_simple;
use crate::query_planner::logical_plan::{LogicalPlan, GraphRel};
use crate::query_planner::logical_expr::{LogicalExpr, Direction};
use crate::graph_catalog::expression_parser::PropertyValue;
use std::collections::{HashMap, HashSet};
use std::sync::Arc;
use crate::render_plan::SelectItem;
use crate::render_plan::render_expr::{RenderExpr, Operator, OperatorApplication, PropertyAccess, TableAlias, AggregateFnCall, ScalarFnCall};
use crate::render_plan::errors::RenderBuildError;
use crate::render_plan::{ArrayJoin, RenderPlan, Cte};
use crate::render_plan::cte_extraction::{extract_relationship_columns, table_to_id_column, RelationshipColumns};
use crate::render_plan::OrderByItem;
use crate::render_plan::filter_pipeline::categorize_filters;
use crate::render_plan::{FromTable, ViewTableRef};
use crate::render_plan::view_table_ref::{from_table_to_view_ref, view_ref_to_from_table};
use log::{self, debug};

// Import ALL helper functions from the dedicated helpers module using glob import
// This allows existing code to call helpers without changes (e.g., extract_table_name())
// The compiler will use the module functions when available
#[allow(unused_imports)]
use super::plan_builder_helpers::*;

// Import ALL helper functions from the dedicated helpers module using glob import
// This allows existing code to call helpers without changes (e.g., extract_table_name())
// The compiler will use the module functions when available
#[allow(unused_imports)]
use super::plan_builder_helpers::*;

type RenderPlanBuilderResult<T> = Result<T, RenderBuildError>;

/// Build property mapping from select items for CTE column resolution.
/// Maps (alias, property) -> column_name for property access resolution.
///
/// This function handles three patterns:
/// 1. "alias.property" (dotted, used in VLP CTEs)
/// 2. "alias_property" (underscore, used in WITH CTEs)  
/// 3. No separator - aggregate column like "friends" from collect()
pub fn build_property_mapping_from_columns(
    select_items: &[SelectItem],
) -> HashMap<(String, String), String> {
    let mut property_mapping = HashMap::new();

    for item in select_items {
        if let Some(col_alias) = &item.col_alias {
            let col_name = &col_alias.0;

            // Pattern 1: "alias.property" (dotted, used in VLP CTEs)
            if let Some(dot_pos) = col_name.find('.') {
                let alias = col_name[..dot_pos].to_string();
                let property = col_name[dot_pos + 1..].to_string();
                property_mapping.insert((alias.clone(), property.clone()), col_name.clone());
                log::debug!(
                    "  Property mapping: ({}, {}) ‚Üí {}",
                    alias,
                    property,
                    col_name
                );
            }
            // Pattern 2: "alias_property" (underscore, used in WITH CTEs)
            else if let Some(underscore_pos) = col_name.find('_') {
                let alias = col_name[..underscore_pos].to_string();
                let property = col_name[underscore_pos + 1..].to_string();
                property_mapping.insert((alias.clone(), property.clone()), col_name.clone());
                log::debug!(
                    "  Property mapping: ({}, {}) ‚Üí {}",
                    alias,
                    property,
                    col_name
                );
            }
            // Pattern 3: No separator - aggregate column like "friends" from collect()
            // Store with empty alias so ARRAY JOIN can find it: ("", column_name) ‚Üí column_name
            else {
                property_mapping.insert(("".to_string(), col_name.clone()), col_name.clone());
                log::debug!(
                    "  Property mapping (aggregate): (\"\", {}) ‚Üí {}",
                    col_name,
                    col_name
                );
            }
        }
    }

    log::info!(
        "Built property mapping with {} entries",
        property_mapping.len()
    );
    property_mapping
}

/// Placeholder for strip_database_prefix function
/// Will be moved from plan_builder.rs lines 116-124
/// Strip database prefix from table name (e.g., "db.table" -> "table")
pub fn strip_database_prefix(table_name: &str) -> String {
    table_name
        .rsplit_once('.')
        .map(|(_, table)| table.to_string())
        .unwrap_or_else(|| table_name.to_string())
}

/// Recursively rewrite RenderExpr to use VLP table aliases
pub fn rewrite_render_expr_for_vlp(expr: &mut RenderExpr, mappings: &HashMap<String, String>) {
    match expr {
        RenderExpr::Column(column) => {
            // Path functions use bare Column("path_nodes") that get qualified as t.path_nodes during SQL generation
            // We need to convert them to PropertyAccessExp so they can be rewritten
            // Check if this is a path function column (path_nodes, hop_count, path_relationships)
            let col_name_str = column.0.raw().to_string(); // Clone to avoid borrow issues
            if matches!(
                col_name_str.as_str(),
                "path_nodes" | "hop_count" | "path_relationships" | "path_edges"
            ) {
                log::info!(
                    "üîÑ VLP: Converting Column({}) to PropertyAccessExp(t.{})",
                    col_name_str,
                    col_name_str
                );
                // Replace Column with PropertyAccessExp using "t" alias
                let new_prop_access = PropertyAccess {
                    table_alias: TableAlias("t".to_string()),
                    column: PropertyValue::Column(col_name_str.clone()),
                };

                // Rewrite the table alias if it's in the mappings
                let rewritten_alias = mappings
                    .get("t")
                    .cloned()
                    .unwrap_or_else(|| "t".to_string());
                log::info!(
                    "üîÑ Rewriting t.{} ‚Üí {}.{}",
                    col_name_str,
                    rewritten_alias,
                    col_name_str
                );

                *expr = RenderExpr::PropertyAccessExp(PropertyAccess {
                    table_alias: TableAlias(rewritten_alias),
                    column: PropertyValue::Column(col_name_str),
                });
            }
        }
        RenderExpr::PropertyAccessExp(prop_access) => {
            // Check if this table alias needs rewriting
            if let Some(new_alias) = mappings.get(&prop_access.table_alias.0) {
                log::info!(
                    "üîÑ Rewriting {}.{} ‚Üí {}.{}",
                    prop_access.table_alias.0,
                    prop_access.column.raw(),
                    new_alias,
                    prop_access.column.raw()
                );
                prop_access.table_alias.0 = new_alias.clone();
            }
        }
        RenderExpr::OperatorApplicationExp(op_app) => {
            for operand in &mut op_app.operands {
                rewrite_render_expr_for_vlp(operand, mappings);
            }
        }
        RenderExpr::ScalarFnCall(func) => {
            for arg in &mut func.args {
                rewrite_render_expr_for_vlp(arg, mappings);
            }
        }
        RenderExpr::AggregateFnCall(func) => {
            for arg in &mut func.args {
                rewrite_render_expr_for_vlp(arg, mappings);
            }
        }
        RenderExpr::InSubquery(in_exp) => {
            rewrite_render_expr_for_vlp(&mut in_exp.expr, mappings);
        }
        RenderExpr::Case(case_exp) => {
            for (when_expr, then_expr) in &mut case_exp.when_then {
                rewrite_render_expr_for_vlp(when_expr, mappings);
                rewrite_render_expr_for_vlp(then_expr, mappings);
            }
            if let Some(else_expr) = &mut case_exp.else_expr {
                rewrite_render_expr_for_vlp(else_expr, mappings);
            }
        }
        RenderExpr::List(items) => {
            for item in items {
                rewrite_render_expr_for_vlp(item, mappings);
            }
        }
        // Other expression types don't contain table aliases
        _ => {}
    }
}

pub fn extract_cte_references(plan: &LogicalPlan) -> HashMap<String, String> {
    let mut refs = HashMap::new();

    match plan {
        LogicalPlan::GraphJoins(gj) => {
            log::info!(
                "üîç extract_cte_references: Found GraphJoins with {} CTE refs: {:?}",
                gj.cte_references.len(),
                gj.cte_references
            );
            refs.extend(gj.cte_references.clone());
            refs.extend(extract_cte_references(&gj.input));
        }
        LogicalPlan::GraphRel(gr) => {
            refs.extend(extract_cte_references(&gr.left));
            refs.extend(extract_cte_references(&gr.center));
            refs.extend(extract_cte_references(&gr.right));
        }
        LogicalPlan::GraphNode(gn) => {
            refs.extend(extract_cte_references(&gn.input));
        }
        LogicalPlan::WithClause(wc) => {
            log::info!(
                "üîç extract_cte_references: Found WithClause with {} CTE refs: {:?}",
                wc.cte_references.len(),
                wc.cte_references
            );
            refs.extend(wc.cte_references.clone());
            refs.extend(extract_cte_references(&wc.input));
        }
        LogicalPlan::CartesianProduct(cp) => {
            refs.extend(extract_cte_references(&cp.left));
            refs.extend(extract_cte_references(&cp.right));
        }
        LogicalPlan::Union(u) => {
            for input in &u.inputs {
                refs.extend(extract_cte_references(input));
            }
        }
        _ => {}
    }

    log::info!(
        "üîç extract_cte_references: Returning {} refs total: {:?}",
        refs.len(),
        refs
    );
    refs
}

pub fn extract_correlation_predicates(
    plan: &LogicalPlan,
) -> Vec<crate::query_planner::logical_expr::LogicalExpr> {
    use crate::query_planner::logical_expr::LogicalExpr;
    let mut predicates = vec![];

    match plan {
        LogicalPlan::GraphJoins(gj) => {
            log::info!("üîç extract_correlation_predicates: Found GraphJoins with {} correlation predicates",
                       gj.correlation_predicates.len());
            predicates.extend(gj.correlation_predicates.clone());
            predicates.extend(extract_correlation_predicates(&gj.input));
        }
        LogicalPlan::GraphRel(gr) => {
            predicates.extend(extract_correlation_predicates(&gr.left));
            predicates.extend(extract_correlation_predicates(&gr.center));
            predicates.extend(extract_correlation_predicates(&gr.right));
        }
        LogicalPlan::GraphNode(gn) => {
            predicates.extend(extract_correlation_predicates(&gn.input));
        }
        LogicalPlan::WithClause(wc) => {
            predicates.extend(extract_correlation_predicates(&wc.input));
        }
        LogicalPlan::CartesianProduct(cp) => {
            predicates.extend(extract_correlation_predicates(&cp.left));
            predicates.extend(extract_correlation_predicates(&cp.right));
        }
        LogicalPlan::Union(u) => {
            for input in &u.inputs {
                predicates.extend(extract_correlation_predicates(input));
            }
        }
        _ => {}
    }

    log::info!(
        "üîç extract_correlation_predicates: Returning {} predicates total",
        predicates.len()
    );
    predicates
}

pub fn convert_correlation_predicates_to_joins(
    predicates: &[crate::query_planner::logical_expr::LogicalExpr],
    cte_references: &HashMap<String, String>,
) -> Vec<(String, String, String, String)> {
    use crate::query_planner::logical_expr::{LogicalExpr, Operator};

    let mut conditions = vec![];

    for pred in predicates {
        if let LogicalExpr::OperatorApplicationExp(op_app) = pred {
            if matches!(op_app.operator, Operator::Equal) && op_app.operands.len() == 2 {
                let left = &op_app.operands[0];
                let right = &op_app.operands[1];

                // Check if we have a CTE reference on one side and a table reference on the other
                if let Some(cond) = extract_join_from_logical_equality(left, right, cte_references)
                {
                    log::info!(
                        "üîß Converted correlation predicate to join: CTE {}.{} = {}.{}",
                        cond.0,
                        cond.1,
                        cond.2,
                        cond.3
                    );
                    conditions.push(cond);
                } else if let Some(cond) =
                    extract_join_from_logical_equality(right, left, cte_references)
                {
                    conditions.push(cond);
                }
            }
        }
    }

    log::info!(
        "üîß convert_correlation_predicates_to_joins: Converted {} predicates to join conditions",
        conditions.len()
    );
    conditions
}

/// Extract join condition from a LogicalExpr equality comparison.
/// Handles patterns like: src2.ip = source_ip (where source_ip is a CTE column)
pub fn extract_join_from_logical_equality(
    left: &crate::query_planner::logical_expr::LogicalExpr,
    right: &crate::query_planner::logical_expr::LogicalExpr,
    cte_references: &HashMap<String, String>,
) -> Option<(String, String, String, String)> {
    use crate::query_planner::logical_expr::LogicalExpr;

    // Pattern 1: Left is table.column (PropertyAccess), Right is CTE variable
    // Example: src2.ip = source_ip
    if let LogicalExpr::PropertyAccessExp(prop) = left {
        if let LogicalExpr::ColumnAlias(var_name) = right {
            // Check if variable references a CTE column
            if let Some(cte_name) = cte_references.get(&var_name.0) {
                return Some((
                    cte_name.clone(),
                    var_name.0.clone(),
                    prop.table_alias.0.clone(),
                    prop.column.raw().to_string(),
                ));
            }
        }
    }

    // Pattern 2: Left is CTE variable, Right is table.column
    // Example: source_ip = src2.ip
    if let LogicalExpr::ColumnAlias(var_name) = left {
        if let LogicalExpr::PropertyAccessExp(prop) = right {
            if let Some(cte_name) = cte_references.get(&var_name.0) {
                return Some((
                    cte_name.clone(),
                    var_name.0.clone(),
                    prop.table_alias.0.clone(),
                    prop.column.raw().to_string(),
                ));
            }
        }
    }

    None
}

/// Extract join condition from equality, for CTE correlation predicates
/// - Maps Cypher node aliases (u, x) to VLP internal aliases (start_node, end_node)
/// - Handles denormalized VLP patterns where both nodes are in the same table
/// - Maps path function aliases ("t") to actual VLP CTE aliases
/// - Skips multi-type VLP CTEs which use Cypher aliases directly
pub fn extract_vlp_alias_mappings(ctes: &crate::render_plan::CteItems) -> HashMap<String, String> {
    let mut mappings = HashMap::new();

    for (idx, cte) in ctes.0.iter().enumerate() {
        log::info!(
            "üîç CTE[{}]: name={}, vlp_start={:?}, vlp_cypher_start={:?}",
            idx,
            cte.cte_name,
            cte.vlp_start_alias,
            cte.vlp_cypher_start_alias
        );

        // Skip alias mappings for multi-type VLP CTEs - they use Cypher aliases directly
        // and properties are extracted via JSON_VALUE() using the Cypher alias
        if cte.cte_name.starts_with("vlp_multi_type_") {
            log::info!("üîÑ VLP: Skipping alias mapping for multi-type VLP CTE (uses Cypher alias directly)");
            continue;
        }

        // Check if this is a VLP CTE with metadata
        if let (Some(cypher_start), Some(vlp_start)) =
            (&cte.vlp_cypher_start_alias, &cte.vlp_start_alias)
        {
            // Check if this is a denormalized VLP (both nodes in same table)
            // ‚úÖ PHASE 2 APPROVED: Derives denormalization from schema structure, not flag
            let is_denormalized =
                cte.vlp_start_table == cte.vlp_end_table && cte.vlp_start_table.is_some();

            if is_denormalized {
                // For denormalized VLP, map Cypher alias directly to VLP CTE alias
                // (not to internal VLP aliases like "start_node")
                let vlp_cte_alias = cte
                    .cte_name
                    .replace("vlp_cte", "vlp")
                    .replace("chained_path_", "vlp");
                log::info!(
                    "üîÑ VLP mapping (denormalized): {} ‚Üí {}",
                    cypher_start,
                    vlp_cte_alias
                );
                mappings.insert(cypher_start.clone(), vlp_cte_alias.clone());
            } else {
                log::info!("üîÑ VLP mapping: {} ‚Üí {}", cypher_start, vlp_start);
                mappings.insert(cypher_start.clone(), vlp_start.clone());
            }
        }

        if let (Some(cypher_end), Some(vlp_end)) = (&cte.vlp_cypher_end_alias, &cte.vlp_end_alias) {
            // Check if this is a denormalized VLP (both nodes in same table)
            // ‚úÖ PHASE 2 APPROVED: Same structural check as above
            let is_denormalized =
                cte.vlp_start_table == cte.vlp_end_table && cte.vlp_start_table.is_some();

            if is_denormalized {
                // For denormalized VLP, map Cypher alias directly to VLP CTE alias
                let vlp_cte_alias = cte
                    .cte_name
                    .replace("vlp_cte", "vlp")
                    .replace("chained_path_", "vlp");
                log::info!(
                    "üîÑ VLP mapping (denormalized): {} ‚Üí {}",
                    cypher_end,
                    vlp_cte_alias
                );
                mappings.insert(cypher_end.clone(), vlp_cte_alias.clone());
            } else {
                log::info!("üîÑ VLP mapping: {} ‚Üí {}", cypher_end, vlp_end);
                mappings.insert(cypher_end.clone(), vlp_end.clone());
            }
        }

        // üîß FIX: Map "t" (generic path function alias) to the actual VLP CTE alias
        // When rewrite_logical_path_functions converts length(path) ‚Üí t.hop_count,
        // we need to rewrite "t" to the actual VLP alias (e.g., "vlp1", "vlp2")
        if cte.cte_name.starts_with("vlp_cte") || cte.cte_name.starts_with("chained_path_") {
            // Extract VLP alias from CTE name: vlp_cte1 ‚Üí vlp1, vlp_cte2 ‚Üí vlp2
            let vlp_alias = cte
                .cte_name
                .replace("vlp_cte", "vlp")
                .replace("chained_path_", "vlp");
            log::info!("üîÑ VLP path function mapping: t ‚Üí {}", vlp_alias);
            mappings.insert("t".to_string(), vlp_alias.clone());

            // ‚ö†Ô∏è TODO: REMOVE THIS FALLBACK - PROPER FIX REQUIRED
            // See notes/HOLISTIC_FIX_METHODOLOGY.md for details
            //
            // This fallback blindly maps relationship aliases (f, r, e, t1-t99) to VLP CTE aliases.
            // This is INCORRECT because:
            // 1. Relationship property filters (e.g., f.flight_number = 123) should be applied
            // ‚úÖ HOLISTIC FIX (Dec 26, 2025): Relationship filters now properly handled in CTE generation
            // - FK-edge patterns: Map to start_node/new_start/current_node in cte_extraction.rs
            // - Standard patterns: Map to rel alias in cte_extraction.rs
            // - Denormalized patterns: Map to rel alias in cte_extraction.rs
            // No fallback mapping needed - filters are applied inside the CTE where they belong.
            log::debug!(
                "VLP relationship filters handled in CTE generation - no fallback mapping needed"
            );
        }
    }

    mappings
}


/// Try to extract a CTE join condition from an equality comparison.
/// Returns: Some((cte_name, cte_column, main_table_alias, main_column)) if found
/// Returns the alias name if found, None otherwise.
pub fn extract_alias_from_expr(expr: &LogicalExpr) -> Option<String> {
    match expr {
        LogicalExpr::ColumnAlias(ca) => {
            log::info!("üîç extract_with_alias: ColumnAlias: {}", ca.0);
            Some(ca.0.clone())
        }
        LogicalExpr::TableAlias(ta) => {
            log::info!("üîç extract_with_alias: TableAlias: {}", ta.0);
            Some(ta.0.clone())
        }
        LogicalExpr::Column(col) => {
            // A bare column name - this is often the variable name in WITH
            // e.g., WITH friend -> Column("friend")
            // Skip "*" since it's not a real variable name
            if col.0 == "*" {
                log::info!("üîç extract_with_alias: Skipping Column('*')");
                None
            } else {
                log::info!("üîç extract_with_alias: Column: {}", col.0);
                Some(col.0.clone())
            }
        }
        LogicalExpr::PropertyAccessExp(pa) => {
            // For property access like `friend.name`, use the table alias
            log::info!(
                "üîç extract_with_alias: PropertyAccessExp: {}.{:?}",
                pa.table_alias.0,
                pa.column
            );
            Some(pa.table_alias.0.clone())
        }
        LogicalExpr::OperatorApplicationExp(op_app) => {
            // Handle operators like DISTINCT that wrap other expressions
            // Try to extract alias from the first operand
            log::info!("üîç extract_with_alias: OperatorApplicationExp with {:?}, checking operands", op_app.operator);
            for operand in &op_app.operands {
                if let Some(alias) = extract_alias_from_expr(operand) {
                    return Some(alias);
                }
            }
            None
        }
        other => {
            log::info!(
                "üîç extract_with_alias: Unhandled expression type in nested: {:?}",
                std::mem::discriminant(other)
            );
            None
        }
    }
}

/// Collect aliases from a single RenderExpr into a HashSet.
/// Recursively traverses PropertyAccessExp, OperatorApplicationExp, and ScalarFnCall expressions
/// to collect all table aliases referenced in the expression.
pub fn collect_aliases_from_single_render_expr(
    expr: &crate::render_plan::render_expr::RenderExpr,
    aliases: &mut std::collections::HashSet<String>,
) {
    match expr {
        crate::render_plan::render_expr::RenderExpr::PropertyAccessExp(prop) => {
            aliases.insert(prop.table_alias.0.clone());
        }
        crate::render_plan::render_expr::RenderExpr::OperatorApplicationExp(op) => {
            for operand in &op.operands {
                collect_aliases_from_single_render_expr(operand, aliases);
            }
        }
        crate::render_plan::render_expr::RenderExpr::ScalarFnCall(fn_call) => {
            for arg in &fn_call.args {
                collect_aliases_from_single_render_expr(arg, aliases);
            }
        }
        _ => {}
    }
}

/// Extract CTE references from a logical plan recursively.
/// Returns a HashMap of CTE references found in the plan.
pub fn extract_cte_references_from_plan(
    plan: &LogicalPlan,
) -> std::collections::HashMap<String, String> {
    match plan {
        LogicalPlan::GraphJoins(gj) => gj.cte_references.clone(),
        LogicalPlan::Projection(p) => extract_cte_references_from_plan(&p.input),
        LogicalPlan::Filter(f) => extract_cte_references_from_plan(&f.input),
        LogicalPlan::Unwind(u) => extract_cte_references_from_plan(&u.input),
        LogicalPlan::Limit(l) => extract_cte_references_from_plan(&l.input),
        LogicalPlan::Skip(s) => extract_cte_references_from_plan(&s.input),
        LogicalPlan::OrderBy(o) => extract_cte_references_from_plan(&o.input),
        LogicalPlan::GroupBy(g) => extract_cte_references_from_plan(&g.input),
        _ => std::collections::HashMap::new(),
    }
}

/// Extract DISTINCT flag from a logical plan recursively.
/// Returns true if any Projection in the plan has DISTINCT set.
pub fn extract_distinct(plan: &LogicalPlan) -> bool {
    // Extract distinct flag from Projection nodes
    let result = match plan {
        LogicalPlan::Projection(projection) => {
            crate::debug_println!(
                "DEBUG extract_distinct: Found Projection, distinct={}",
                projection.distinct
            );
            projection.distinct
        }
        LogicalPlan::OrderBy(order_by) => {
            crate::debug_println!("DEBUG extract_distinct: OrderBy, recursing");
            extract_distinct(&order_by.input)
        }
        LogicalPlan::Skip(skip) => {
            crate::debug_println!("DEBUG extract_distinct: Skip, recursing");
            extract_distinct(&skip.input)
        }
        LogicalPlan::Limit(limit) => {
            crate::debug_println!("DEBUG extract_distinct: Limit, recursing");
            extract_distinct(&limit.input)
        }
        LogicalPlan::GroupBy(group_by) => {
            crate::debug_println!("DEBUG extract_distinct: GroupBy, recursing");
            extract_distinct(&group_by.input)
        }
        LogicalPlan::GraphJoins(graph_joins) => {
            crate::debug_println!("DEBUG extract_distinct: GraphJoins, recursing");
            extract_distinct(&graph_joins.input)
        }
        LogicalPlan::Filter(filter) => {
            crate::debug_println!("DEBUG extract_distinct: Filter, recursing");
            extract_distinct(&filter.input)
        }
        _ => {
            crate::debug_println!("DEBUG extract_distinct: Other variant, returning false");
            false
        }
    };
    crate::debug_println!("DEBUG extract_distinct: Returning {}", result);
    result
}

/// Extract filters from a LogicalPlan node.
/// 
/// This function recursively traverses the plan tree to collect all filter predicates
/// that should be applied to the query, including view filters, schema filters,
/// WHERE predicates, and cycle prevention filters for variable-length paths.
pub fn extract_filters(plan: &LogicalPlan) -> RenderPlanBuilderResult<Option<RenderExpr>> {
    let filters = match plan {
        LogicalPlan::Empty => None,
        LogicalPlan::ViewScan(scan) => {
            // ViewScan.view_filter should be None after CleanupViewScanFilters optimizer.
            // All filters are consolidated in GraphRel.where_predicate.
            // This case handles standalone ViewScans outside of GraphRel contexts.
            let mut filters = Vec::new();

            // Add view_filter if present
            if let Some(ref filter) = scan.view_filter {
                let mut expr: RenderExpr = filter.clone().try_into()?;
                apply_property_mapping_to_expr(&mut expr, &LogicalPlan::ViewScan(scan.clone()));
                filters.push(expr);
            }

            // Add schema_filter if present (defined in YAML schema)
            if let Some(ref schema_filter) = scan.schema_filter {
                // Use a default alias for standalone ViewScans
                // In practice, these will be wrapped in GraphNode which provides the alias
                if let Ok(sql) = schema_filter.to_sql("t") {
                    log::debug!("ViewScan: Adding schema filter: {}", sql);
                    filters.push(RenderExpr::Raw(sql));
                }
            }

            if filters.is_empty() {
                None
            } else if filters.len() == 1 {
                Some(filters.into_iter().next().unwrap())
            } else {
                // Combine with AND
                let combined = filters
                    .into_iter()
                    .reduce(|acc, pred| {
                        RenderExpr::OperatorApplicationExp(OperatorApplication {
                            operator: Operator::And,
                            operands: vec![acc, pred],
                        })
                    })
                    .unwrap();
                Some(combined)
            }
        }
        LogicalPlan::GraphNode(graph_node) => {
            // For node-only queries, extract both view_filter and schema_filter from the input ViewScan
            if let LogicalPlan::ViewScan(scan) = graph_node.input.as_ref() {
                log::info!(
                    "üîç GraphNode '{}' extract_filters: ViewScan table={}",
                    graph_node.alias,
                    scan.source_table
                );

                let mut filters = Vec::new();

                // Extract view_filter (user's WHERE clause, injected by optimizer)
                if let Some(ref view_filter) = scan.view_filter {
                    log::debug!(
                        "extract_filters: view_filter BEFORE conversion: {:?}",
                        view_filter
                    );
                    let mut expr: RenderExpr = view_filter.clone().try_into()?;
                    log::debug!("extract_filters: view_filter AFTER conversion: {:?}", expr);
                    apply_property_mapping_to_expr(&mut expr, &graph_node.input);
                    log::debug!(
                        "extract_filters: view_filter AFTER property mapping: {:?}",
                        expr
                    );
                    log::info!(
                        "GraphNode '{}': Adding view_filter: {:?}",
                        graph_node.alias,
                        expr
                    );
                    filters.push(expr);
                }

                // Extract schema_filter (from YAML schema)
                // Wrap in parentheses to ensure correct operator precedence when combined with user filters
                if let Some(ref schema_filter) = scan.schema_filter {
                    if let Ok(sql) = schema_filter.to_sql(&graph_node.alias) {
                        log::info!(
                            "GraphNode '{}': Adding schema filter: {}",
                            graph_node.alias,
                            sql
                        );
                        // Always wrap schema filter in parentheses for safe combination
                        filters.push(RenderExpr::Raw(format!("({})", sql)));
                    }
                }

                // Combine filters with AND if multiple
                // Use explicit AND combination - each operand will be wrapped appropriately
                if filters.is_empty() {
                    return Ok(None);
                } else if filters.len() == 1 {
                    return Ok(Some(filters.into_iter().next().unwrap()));
                } else {
                    // When combining filters, wrap non-Raw expressions in parentheses
                    // to handle AND/OR precedence correctly
                    let combined = filters
                        .into_iter()
                        .reduce(|acc, pred| {
                            // The OperatorApplicationExp will render as "(left) AND (right)"
                            // due to the render_expr_to_sql_string logic
                            RenderExpr::OperatorApplicationExp(OperatorApplication {
                                operator: Operator::And,
                                operands: vec![acc, pred],
                            })
                        })
                        .unwrap();
                    return Ok(Some(combined));
                }
            }
            None
        }
        LogicalPlan::GraphRel(graph_rel) => {
            log::trace!(
                "GraphRel node detected, collecting filters from ALL nested where_predicates"
            );

            // Collect all where_predicates from this GraphRel and nested GraphRel nodes
            // Using helper functions from plan_builder_helpers module
            let all_predicates =
                collect_graphrel_predicates(&LogicalPlan::GraphRel(graph_rel.clone()));

            let mut all_predicates = all_predicates;

            // üîí Add schema-level filters from ViewScans
            let schema_filters =
                collect_schema_filters(&LogicalPlan::GraphRel(graph_rel.clone()), None);
            if !schema_filters.is_empty() {
                log::info!(
                    "Adding {} schema filter(s) to WHERE clause",
                    schema_filters.len()
                );
                all_predicates.extend(schema_filters);
            }

            // TODO: Add relationship uniqueness filters for undirected multi-hop patterns
            // This requires fixing Issue #1 (Undirected Multi-Hop Patterns Generate Broken SQL) first.
            // See KNOWN_ISSUES.md for details.
            // Currently, undirected multi-hop patterns generate broken SQL with wrong aliases,
            // so adding uniqueness filters here would not work correctly.

            // üöÄ ADD CYCLE PREVENTION for fixed-length paths (only for 2+ hops)
            // Single hop (*1) can't have cycles - no need for cycle prevention
            if let Some(spec) = &graph_rel.variable_length {
                if let Some(exact_hops) = spec.exact_hop_count() {
                    // Skip cycle prevention for *1 - single hop can't cycle
                    if exact_hops >= 2 && graph_rel.shortest_path_mode.is_none() {
                        crate::debug_println!("DEBUG: extract_filters - Adding cycle prevention for fixed-length *{}", exact_hops);

                        // Check if this is a denormalized pattern
                        let is_denormalized = is_node_denormalized(&graph_rel.left)
                            && is_node_denormalized(&graph_rel.right);

                        // Extract table/column info for cycle prevention
                        // Use extract_table_name directly to avoid wrong fallbacks
                        let start_table =
                            extract_table_name(&graph_rel.left).ok_or_else(|| {
                                RenderBuildError::MissingTableInfo(
                                    "start node in cycle prevention".to_string(),
                                )
                            })?;
                        let end_table =
                            extract_table_name(&graph_rel.right).ok_or_else(|| {
                                RenderBuildError::MissingTableInfo(
                                    "end node in cycle prevention".to_string(),
                                )
                            })?;

                        let rel_cols = extract_relationship_columns(&graph_rel.center)
                            .unwrap_or(RelationshipColumns {
                                from_id: "from_node_id".to_string(),
                                to_id: "to_node_id".to_string(),
                            });

                        // For denormalized, use relationship columns directly
                        // For normal, use node ID columns
                        let (start_id_col, end_id_col) = if is_denormalized {
                            (rel_cols.from_id.clone(), rel_cols.to_id.clone())
                        } else {
                            let start = extract_id_column(&graph_rel.left)
                                .unwrap_or_else(|| table_to_id_column(&start_table));
                            let end = extract_id_column(&graph_rel.right)
                                .unwrap_or_else(|| table_to_id_column(&end_table));
                            (start, end)
                        };

                        // Generate cycle prevention filters
                        if let Some(cycle_filter) = crate::render_plan::cte_extraction::generate_cycle_prevention_filters(
                            exact_hops,
                            &start_id_col,
                            &rel_cols.to_id,
                            &rel_cols.from_id,
                            &end_id_col,
                            &graph_rel.left_connection,
                            &graph_rel.right_connection,
                        ) {
                            crate::debug_println!("DEBUG: extract_filters - Generated cycle prevention filter");
                            all_predicates.push(cycle_filter);
                        }
                    }
                }
            }

            if all_predicates.is_empty() {
                None
            } else if all_predicates.len() == 1 {
                log::trace!("Found 1 GraphRel predicate");
                Some(all_predicates.into_iter().next().unwrap())
            } else {
                // Combine with AND
                log::trace!(
                    "Found {} GraphRel predicates, combining with AND",
                    all_predicates.len()
                );
                let combined = all_predicates
                    .into_iter()
                    .reduce(|acc, pred| {
                        RenderExpr::OperatorApplicationExp(OperatorApplication {
                            operator: Operator::And,
                            operands: vec![acc, pred],
                        })
                    })
                    .unwrap();
                Some(combined)
            }
        }
        LogicalPlan::Filter(filter) => {
            println!(
                "DEBUG: extract_filters - Found Filter node with predicate: {:?}",
                filter.predicate
            );
            println!(
                "DEBUG: extract_filters - Filter input type: {:?}",
                std::mem::discriminant(&*filter.input)
            );
            let mut expr: RenderExpr = filter.predicate.clone().try_into()?;
            // Apply property mapping to the filter expression
            apply_property_mapping_to_expr(&mut expr, &filter.input);

            // Also check for schema filters from the input (e.g., GraphNode ‚Üí ViewScan)
            if let Some(input_filter) = extract_filters(&filter.input)? {
                crate::debug_println!("DEBUG: extract_filters - Combining Filter predicate with input schema filter");
                // Combine the Filter predicate with input's schema filter using AND
                Some(RenderExpr::OperatorApplicationExp(OperatorApplication {
                    operator: Operator::And,
                    operands: vec![input_filter, expr],
                }))
            } else {
                crate::debug_println!("DEBUG: extract_filters - Returning Filter predicate only (no input filter)");
                Some(expr)
            }
        }
        LogicalPlan::Projection(projection) => {
            crate::debug_println!(
                "DEBUG: extract_filters - Projection, recursing to input type: {:?}",
                std::mem::discriminant(&*projection.input)
            );
            extract_filters(&projection.input)?
        }
        LogicalPlan::GroupBy(group_by) => extract_filters(&group_by.input)?,
        LogicalPlan::OrderBy(order_by) => extract_filters(&order_by.input)?,
        LogicalPlan::Skip(skip) => extract_filters(&skip.input)?,
        LogicalPlan::Limit(limit) => extract_filters(&limit.input)?,
        LogicalPlan::Cte(cte) => extract_filters(&cte.input)?,
        LogicalPlan::GraphJoins(graph_joins) => extract_filters(&graph_joins.input)?,
        LogicalPlan::Union(_) => None,
        LogicalPlan::PageRank(_) => None,
        LogicalPlan::Unwind(u) => extract_filters(&u.input)?,
        LogicalPlan::CartesianProduct(cp) => {
            // Combine filters from both sides with AND
            let left_filters = extract_filters(&cp.left)?;
            let right_filters = extract_filters(&cp.right)?;

            // DEBUG: Log what we're extracting
            log::info!("üîç CartesianProduct extract_filters:");
            log::info!("  Left filters: {:?}", left_filters);
            log::info!("  Right filters: {:?}", right_filters);

            match (left_filters, right_filters) {
                (None, None) => None,
                (Some(l), None) => {
                    log::info!("  ‚úÖ Returning left filters only");
                    Some(l)
                }
                (None, Some(r)) => {
                    log::info!("  ‚úÖ Returning right filters only");
                    Some(r)
                }
                (Some(l), Some(r)) => {
                    log::warn!("  ‚ö†Ô∏è BOTH sides have filters - combining with AND!");
                    log::warn!("  ‚ö†Ô∏è This may cause duplicates if filters are the same!");
                    Some(RenderExpr::OperatorApplicationExp(OperatorApplication {
                        operator: Operator::And,
                        operands: vec![l, r],
                    }))
                }
            }
        }
        LogicalPlan::WithClause(wc) => extract_filters(&wc.input)?,
    };
    Ok(filters)
}

/// Extract final filters from a LogicalPlan.
///
/// This function extracts filters that should be applied to the final query,
/// specifically focusing on path function filters from GraphRel nodes.
/// Unlike extract_filters, this only extracts specific filter types for final application.
pub fn extract_final_filters(plan: &LogicalPlan) -> RenderPlanBuilderResult<Option<RenderExpr>> {
    let final_filters = match plan {
        LogicalPlan::Limit(limit) => extract_final_filters(&limit.input)?,
        LogicalPlan::Skip(skip) => extract_final_filters(&skip.input)?,
        LogicalPlan::OrderBy(order_by) => extract_final_filters(&order_by.input)?,
        LogicalPlan::GroupBy(group_by) => extract_final_filters(&group_by.input)?,
        LogicalPlan::GraphJoins(graph_joins) => extract_final_filters(&graph_joins.input)?,
        LogicalPlan::Projection(projection) => extract_final_filters(&projection.input)?,
        LogicalPlan::Filter(filter) => {
            let mut expr: RenderExpr = filter.predicate.clone().try_into()?;
            // Apply property mapping to the filter expression
            apply_property_mapping_to_expr(&mut expr, &filter.input);
            Some(expr)
        }
        LogicalPlan::GraphRel(graph_rel) => {
            // For GraphRel, extract path function filters that should be applied to the final query
            if let Some(logical_expr) = &graph_rel.where_predicate {
                let mut filter_expr: RenderExpr = logical_expr.clone().try_into()?;
                // Apply property mapping to the where predicate
                apply_property_mapping_to_expr(
                    &mut filter_expr,
                    &LogicalPlan::GraphRel(graph_rel.clone()),
                );
                let start_alias = graph_rel.left_connection.clone();
                let end_alias = graph_rel.right_connection.clone();

                // For extract_final_filters, we only need to categorize path function filters
                // Schema-aware categorization is not needed here since this is just for
                // separating path functions from other filters. Use a dummy categorization.
                let rel_labels = graph_rel.labels.clone().unwrap_or_default();

                // Try to get schema for proper categorization
                use crate::server::GLOBAL_SCHEMAS;
                let schemas_lock = GLOBAL_SCHEMAS.get().expect("Schemas not initialized");
                let schemas = schemas_lock
                    .try_read()
                    .expect("Failed to acquire schema lock");

                // Try to find a schema that has this relationship type
                let schema_for_categorization = if !rel_labels.is_empty() {
                    schemas.values().find(|s| {
                        rel_labels
                            .iter()
                            .any(|label| s.get_rel_schema(label).is_ok())
                    })
                } else {
                    None
                };

                let schema_ref = schema_for_categorization.unwrap_or_else(|| {
                    schemas
                        .values()
                        .next()
                        .expect("At least one schema must be loaded")
                });

                let categorized = categorize_filters(
                    Some(&filter_expr),
                    &start_alias,
                    &end_alias,
                    &graph_rel.alias,
                    schema_ref,
                    &rel_labels,
                );

                categorized.path_function_filters
            } else {
                None
            }
        }
        _ => None,
    };
    Ok(final_filters)
}

/// Extract FROM clause from a LogicalPlan
///
/// This function determines which table should be the FROM table in the generated SQL.
/// It handles various LogicalPlan types and applies different logic based on the plan structure.
pub fn extract_from(plan: &LogicalPlan) -> RenderPlanBuilderResult<Option<FromTable>> {
    log::debug!(
        "üîç extract_from START: plan type={:?}",
        std::mem::discriminant(plan)
    );

    let from_ref = match plan {
        LogicalPlan::Empty => None,
        LogicalPlan::ViewScan(scan) => {
            // Check if this is a relationship ViewScan (has from_id/to_id)
            if scan.from_id.is_some() && scan.to_id.is_some() {
                // For denormalized edges, use the actual table name directly
                // CTE references (rel_*) are only needed for standard edges with separate node tables
                // Denormalized ViewScans have from_node_properties/to_node_properties indicating
                // node data is stored on the edge table itself
                let use_actual_table =
                    scan.from_node_properties.is_some() && scan.to_node_properties.is_some();

                debug!("üìä extract_from ViewScan: source_table={}, from_props={:?}, to_props={:?}, use_actual_table={}",
                    scan.source_table,
                    scan.from_node_properties.as_ref().map(|p| p.len()),
                    scan.to_node_properties.as_ref().map(|p| p.len()),
                    use_actual_table);

                if use_actual_table {
                    // Denormalized: use actual table name
                    debug!("‚úÖ Using actual table name: {}", scan.source_table);
                    Some(ViewTableRef::new_table(
                        scan.as_ref().clone(),
                        scan.source_table.clone(),
                    ))
                } else {
                    // Standard edge: use CTE reference
                    let cte_name =
                        format!("rel_{}", scan.source_table.replace([' ', '-', '_'], ""));
                    debug!("üîÑ Using CTE reference: {}", cte_name);
                    Some(ViewTableRef::new_table(scan.as_ref().clone(), cte_name))
                }
            } else {
                // For node ViewScans, use the table name
                Some(ViewTableRef::new_table(
                    scan.as_ref().clone(),
                    scan.source_table.clone(),
                ))
            }
        }
        LogicalPlan::GraphNode(graph_node) => {
            // For GraphNode, extract FROM from the input but use this GraphNode's alias
            // CROSS JOINs for multiple standalone nodes are handled in extract_joins
            println!(
                "DEBUG: GraphNode.extract_from() - alias: {}, input: {:?}",
                graph_node.alias, graph_node.input
            );
            match &*graph_node.input {
                LogicalPlan::ViewScan(scan) => {
                    println!(
                        "DEBUG: GraphNode.extract_from() - matched ViewScan, table: {}",
                        scan.source_table
                    );
                    // Check if this is a relationship ViewScan (has from_id/to_id)
                    let table_or_cte_name = if scan.from_id.is_some() && scan.to_id.is_some() {
                        // For denormalized edges, use actual table; for standard edges, use CTE
                        let use_actual_table = scan.from_node_properties.is_some()
                            && scan.to_node_properties.is_some();
                        if use_actual_table {
                            scan.source_table.clone()
                        } else {
                            format!("rel_{}", scan.source_table.replace([' ', '-', '_'], ""))
                        }
                    } else {
                        // For node ViewScans, use the table name
                        scan.source_table.clone()
                    };
                    // ViewScan already returns ViewTableRef, just update the alias
                    let mut view_ref =
                        ViewTableRef::new_table(scan.as_ref().clone(), table_or_cte_name);
                    view_ref.alias = Some(graph_node.alias.clone());
                    println!(
                        "DEBUG: GraphNode.extract_from() - created ViewTableRef: {:?}",
                        view_ref
                    );
                    Some(view_ref)
                }
                _ => {
                    println!(
                        "DEBUG: GraphNode.extract_from() - not a ViewScan, input type: {:?}",
                        graph_node.input
                    );
                    // For other input types, extract FROM and convert
                    let mut from_ref = from_table_to_view_ref(extract_from(&graph_node.input)?);
                    // Use this GraphNode's alias
                    if let Some(ref mut view_ref) = from_ref {
                        view_ref.alias = Some(graph_node.alias.clone());
                    }
                    from_ref
                }
            }
        }
        LogicalPlan::GraphRel(graph_rel) => {
            // DENORMALIZED EDGE TABLE CHECK
            // For denormalized patterns, both nodes are virtual - use relationship table as FROM
            let left_is_denormalized = is_node_denormalized(&graph_rel.left);
            let right_is_denormalized = is_node_denormalized(&graph_rel.right);

            log::debug!(
                "üîç extract_from GraphRel: alias='{}', left_is_denorm={}, right_is_denorm={}",
                graph_rel.alias,
                left_is_denormalized,
                right_is_denormalized
            );

            if left_is_denormalized && right_is_denormalized {
                log::debug!("‚úì DENORMALIZED pattern: both nodes on edge table, using edge table as FROM");

                // For multi-hop denormalized, find the first (leftmost) relationship
                fn find_first_graph_rel(
                    graph_rel: &crate::query_planner::logical_plan::GraphRel,
                ) -> &crate::query_planner::logical_plan::GraphRel {
                    match graph_rel.left.as_ref() {
                        LogicalPlan::GraphRel(left_rel) => find_first_graph_rel(left_rel),
                        _ => graph_rel,
                    }
                }

                let first_graph_rel = find_first_graph_rel(graph_rel);

                // Try ViewScan first (normal case)
                if let LogicalPlan::ViewScan(scan) = first_graph_rel.center.as_ref() {
                    log::debug!(
                        "‚úì Using ViewScan edge table '{}' AS '{}'",
                        scan.source_table,
                        first_graph_rel.alias
                    );
                    return Ok(Some(FromTable::new(Some(ViewTableRef {
                        source: first_graph_rel.center.clone(),
                        name: scan.source_table.clone(),
                        alias: Some(first_graph_rel.alias.clone()),
                        use_final: scan.use_final,
                    }))));
                }

                log::debug!(
                    "‚ö†Ô∏è  Could not extract edge table from center (type: {:?})",
                    std::mem::discriminant(first_graph_rel.center.as_ref())
                );
            }

            // Check if both nodes are anonymous (edge-driven query)
            let left_table_name = extract_table_name(&graph_rel.left);
            let right_table_name = extract_table_name(&graph_rel.right);

            // If both nodes are anonymous, use the relationship table as FROM
            if left_table_name.is_none() && right_table_name.is_none() {
                // Edge-driven query: use relationship table directly (not as CTE)
                // Extract table name from the relationship ViewScan
                if let LogicalPlan::ViewScan(scan) = graph_rel.center.as_ref() {
                    // Use actual table name, not CTE name
                    return Ok(Some(FromTable::new(Some(ViewTableRef::new_table(
                        scan.as_ref().clone(),
                        scan.source_table.clone(),
                    )))));
                }
                // Fallback to normal extraction if not a ViewScan
                return Ok(None);
            }

            // For GraphRel with labeled nodes, we need to include the start node in the FROM clause
            // This handles simple relationship queries where the start node should be FROM

            // ALWAYS use left node as FROM for relationship patterns.
            // The is_optional flag determines JOIN type (INNER vs LEFT), not FROM table selection.
            //
            // For `MATCH (a) OPTIONAL MATCH (a)-[:R]->(b)`:
            //   - a is the left connection (required, already defined)
            //   - b is the right connection (optional, newly introduced)
            //   - FROM should be `a`, with LEFT JOIN to relationship and `b`
            //
            // For `MATCH (a) OPTIONAL MATCH (b)-[:R]->(a)`:
            //   - b is the left connection (optional, newly introduced)
            //   - a is the right connection (required, already defined)
            //   - FROM should be `a` (the required one), but the pattern structure has `b` on left
            //   - This case needs special handling: find which connection is NOT optional

            println!("DEBUG: graph_rel.is_optional = {:?}", graph_rel.is_optional);

            // Use left as primary, right as fallback
            let (primary_from, fallback_from) = (
                extract_from(&graph_rel.left),
                extract_from(&graph_rel.right),
            );

            crate::debug_println!("DEBUG: primary_from = {:?}", primary_from);
            crate::debug_println!("DEBUG: fallback_from = {:?}", fallback_from);

            if let Ok(Some(from_table)) = primary_from {
                from_table_to_view_ref(Some(from_table))
            } else {
                // If primary node doesn't have FROM, try fallback
                let right_from = fallback_from;
                crate::debug_println!("DEBUG: Using fallback FROM");
                crate::debug_println!("DEBUG: right_from = {:?}", right_from);

                if let Ok(Some(from_table)) = right_from {
                    from_table_to_view_ref(Some(from_table))
                } else {
                    // If right also doesn't have FROM, check if right contains a nested GraphRel
                    if let LogicalPlan::GraphRel(nested_graph_rel) = graph_rel.right.as_ref() {
                        // Extract FROM from the nested GraphRel's left node
                        let nested_left_from = extract_from(&nested_graph_rel.left);
                        crate::debug_println!(
                            "DEBUG: nested_graph_rel.left = {:?}",
                            nested_graph_rel.left
                        );
                        crate::debug_println!(
                            "DEBUG: nested_left_from = {:?}",
                            nested_left_from
                        );

                        if let Ok(Some(nested_from_table)) = nested_left_from {
                            from_table_to_view_ref(Some(nested_from_table))
                        } else {
                            // If nested left also doesn't have FROM, create one from the nested left_connection alias
                            let table_name = extract_table_name(&nested_graph_rel.left)
                                .ok_or_else(|| {
                                    super::errors::RenderBuildError::TableNameNotFound(format!(
                                    "Could not resolve table name for alias '{}', plan: {:?}",
                                    nested_graph_rel.left_connection, nested_graph_rel.left
                                ))
                                })?;

                            Some(super::ViewTableRef {
                                source: std::sync::Arc::new(LogicalPlan::Empty),
                                name: table_name,
                                alias: Some(nested_graph_rel.left_connection.clone()),
                                use_final: false,
                            })
                        }
                    } else {
                        // If right doesn't have FROM, we need to determine which node should be the anchor
                        // Use find_anchor_node logic to choose the correct anchor
                        let all_connections = get_all_relationship_connections(plan);
                        let optional_aliases = std::collections::HashSet::new();
                        let denormalized_aliases = std::collections::HashSet::new();

                        if let Some(anchor_alias) = find_anchor_node(
                            &all_connections,
                            &optional_aliases,
                            &denormalized_aliases,
                        ) {
                            // Determine which node (left or right) the anchor corresponds to
                            let (table_plan, connection_alias) =
                                if anchor_alias == graph_rel.left_connection {
                                    (&graph_rel.left, &graph_rel.left_connection)
                                } else {
                                    (&graph_rel.right, &graph_rel.right_connection)
                                };

                            let table_name = extract_table_name(table_plan)
                                .ok_or_else(|| super::errors::RenderBuildError::TableNameNotFound(format!(
                                    "Could not resolve table name for anchor alias '{}', plan: {:?}",
                                    connection_alias, table_plan
                                )))?;

                            Some(super::ViewTableRef {
                                source: std::sync::Arc::new(LogicalPlan::Empty),
                                name: table_name,
                                alias: Some(connection_alias.clone()),
                                use_final: false,
                            })
                        } else {
                            // Fallback: use left_connection as anchor (traditional behavior)
                            let table_name =
                                extract_table_name(&graph_rel.left).ok_or_else(|| {
                                    super::errors::RenderBuildError::TableNameNotFound(format!(
                                    "Could not resolve table name for alias '{}', plan: {:?}",
                                    graph_rel.left_connection, graph_rel.left
                                ))
                                })?;

                            Some(super::ViewTableRef {
                                source: std::sync::Arc::new(LogicalPlan::Empty),
                                name: table_name,
                                alias: Some(graph_rel.left_connection.clone()),
                                use_final: false,
                            })
                        }
                    }
                }
            }
        }
        LogicalPlan::Filter(filter) => {
            log::debug!(
                "  ‚Üí Filter, recursing to input type={:?}",
                std::mem::discriminant(filter.input.as_ref())
            );
            from_table_to_view_ref(extract_from(&filter.input)?)
        }
        LogicalPlan::Projection(projection) => {
            log::debug!(
                "  ‚Üí Projection, recursing to input type={:?}",
                std::mem::discriminant(projection.input.as_ref())
            );
            from_table_to_view_ref(extract_from(&projection.input)?)
        }
        LogicalPlan::GraphJoins(graph_joins) => {
            // ============================================================================
            // CLEAN DESIGN: FROM table determination for GraphJoins
            // ============================================================================
            //
            // The logical model is simple:
            // 1. Every table in a graph query is represented as a Join in graph_joins.joins
            // 2. A Join with EMPTY joining_on is a FROM marker (no join conditions = base table)
            // 3. A Join with NON-EMPTY joining_on is a real JOIN
            // 4. There should be exactly ONE FROM marker per GraphJoins
            //
            // This function finds that FROM marker and returns it.
            // NO FALLBACKS. If there's no FROM marker, something is wrong upstream.
            // ============================================================================

            log::debug!(
                "üîç GraphJoins.extract_from: {} joins, anchor_table={:?}",
                graph_joins.joins.len(),
                graph_joins.anchor_table
            );

            // üîß PARAMETERIZED VIEW FIX: Get parameterized table references from input plan
            let parameterized_tables = extract_rel_and_node_tables(&graph_joins.input);

            // STEP 1: Find FROM marker (Join with empty joining_on)
            // This is the authoritative source - it was set by graph_join_inference
            for join in &graph_joins.joins {
                if join.joining_on.is_empty() {
                    // üîß PARAMETERIZED VIEW FIX: Use parameterized table reference if available
                    let table_name = parameterized_tables
                        .get(&join.table_alias)
                        .cloned()
                        .unwrap_or_else(|| join.table_name.clone());

                    log::info!(
                        "‚úÖ Found FROM marker: table='{}' (original='{}') alias='{}'",
                        table_name,
                        join.table_name,
                        join.table_alias
                    );
                    return Ok(Some(FromTable::new(Some(ViewTableRef {
                        source: std::sync::Arc::new(LogicalPlan::Empty),
                        name: table_name,
                        alias: Some(join.table_alias.clone()),
                        use_final: false,
                    }))));
                }
            }

            // STEP 2: No FROM marker found - check special cases that don't use joins

            // Helper to find GraphRel through wrappers
            fn find_graph_rel(plan: &LogicalPlan) -> Option<&GraphRel> {
                match plan {
                    LogicalPlan::GraphRel(gr) => Some(gr),
                    LogicalPlan::Projection(proj) => find_graph_rel(&proj.input),
                    LogicalPlan::Filter(filter) => find_graph_rel(&filter.input),
                    LogicalPlan::Unwind(u) => find_graph_rel(&u.input),
                    LogicalPlan::GraphJoins(gj) => find_graph_rel(&gj.input),
                    _ => None,
                }
            }

            // Helper to find GraphNode for node-only queries
            fn find_graph_node(
                plan: &LogicalPlan,
            ) -> Option<&crate::query_planner::logical_plan::GraphNode> {
                match plan {
                    LogicalPlan::GraphNode(gn) => Some(gn),
                    LogicalPlan::Projection(proj) => find_graph_node(&proj.input),
                    LogicalPlan::Filter(filter) => find_graph_node(&filter.input),
                    LogicalPlan::Unwind(u) => find_graph_node(&u.input),
                    LogicalPlan::GraphJoins(gj) => find_graph_node(&gj.input),
                    _ => None,
                }
            }

            // Helper to find CartesianProduct
            fn find_cartesian_product(
                plan: &LogicalPlan,
            ) -> Option<&crate::query_planner::logical_plan::CartesianProduct> {
                match plan {
                    LogicalPlan::CartesianProduct(cp) => Some(cp),
                    LogicalPlan::Filter(f) => find_cartesian_product(&f.input),
                    LogicalPlan::Projection(p) => find_cartesian_product(&p.input),
                    _ => None,
                }
            }

            fn is_cte_reference(plan: &LogicalPlan) -> bool {
                match plan {
                    LogicalPlan::WithClause(_) => true,
                    LogicalPlan::ViewScan(vs) => vs.source_table.starts_with("with_"),
                    LogicalPlan::GraphNode(gn) => is_cte_reference(&gn.input),
                    LogicalPlan::Projection(p) => is_cte_reference(&p.input),
                    LogicalPlan::Filter(f) => is_cte_reference(&f.input),
                    _ => false,
                }
            }

            // CASE A: Empty joins - check for denormalized edge or node-only patterns
            if graph_joins.joins.is_empty() {
                log::debug!("üìã No joins - checking for special patterns");

                // A.1: Denormalized edge pattern - use edge table directly
                if let Some(graph_rel) = find_graph_rel(&graph_joins.input) {
                    if let LogicalPlan::ViewScan(rel_scan) = graph_rel.center.as_ref() {
                        if rel_scan.from_node_properties.is_some()
                            || rel_scan.to_node_properties.is_some()
                        {
                            log::info!(
                                "üéØ DENORMALIZED: Using edge table '{}' as FROM",
                                rel_scan.source_table
                            );
                            return Ok(Some(FromTable::new(Some(ViewTableRef {
                                source: graph_rel.center.clone(),
                                name: rel_scan.source_table.clone(),
                                alias: Some(graph_rel.alias.clone()),
                                use_final: rel_scan.use_final,
                            }))));
                        }
                    }

                    // A.2: Polymorphic edge - use the labeled node
                    if let LogicalPlan::GraphNode(left_node) = graph_rel.left.as_ref() {
                        if let LogicalPlan::ViewScan(scan) = left_node.input.as_ref() {
                            log::info!(
                                "üéØ POLYMORPHIC: Using left node '{}' as FROM",
                                left_node.alias
                            );
                            return Ok(Some(FromTable::new(Some(ViewTableRef {
                                source: std::sync::Arc::new(LogicalPlan::GraphNode(
                                    left_node.clone(),
                                )),
                                name: scan.source_table.clone(),
                                alias: Some(left_node.alias.clone()),
                                use_final: scan.use_final,
                            }))));
                        }
                    }
                    if let LogicalPlan::GraphNode(right_node) = graph_rel.right.as_ref() {
                        if let LogicalPlan::ViewScan(scan) = right_node.input.as_ref() {
                            log::info!(
                                "üéØ POLYMORPHIC: Using right node '{}' as FROM",
                                right_node.alias
                            );
                            return Ok(Some(FromTable::new(Some(ViewTableRef {
                                source: std::sync::Arc::new(LogicalPlan::GraphNode(
                                    right_node.clone(),
                                )),
                                name: scan.source_table.clone(),
                                alias: Some(right_node.alias.clone()),
                                use_final: scan.use_final,
                            }))));
                        }
                    }
                }

                // A.3: Node-only query (MATCH (n:Label) RETURN n)
                if let Some(graph_node) = find_graph_node(&graph_joins.input) {
                    if let LogicalPlan::ViewScan(scan) = graph_node.input.as_ref() {
                        log::info!("üéØ NODE-ONLY: Using node '{}' as FROM", graph_node.alias);
                        let view_ref = ViewTableRef::new_table_with_alias(
                            scan.as_ref().clone(),
                            scan.source_table.clone(),
                            graph_node.alias.clone(),
                        );
                        return Ok(Some(FromTable::new(Some(view_ref))));
                    }
                }

                // A.4: CartesianProduct (WITH...MATCH or comma patterns)
                if let Some(cp) = find_cartesian_product(&graph_joins.input) {
                    if is_cte_reference(&cp.left) {
                        log::info!("üéØ WITH...MATCH: FROM comes from right side");
                        return extract_from(&cp.right);
                    } else {
                        log::info!("üéØ COMMA PATTERN: FROM comes from left side");
                        return extract_from(&cp.left);
                    }
                }

                // No valid FROM found for empty joins - this is unexpected
                log::warn!("‚ö†Ô∏è GraphJoins has empty joins and no recognizable pattern - returning None");
                return Ok(None);
            }

            // CASE B: Has joins but no FROM marker
            // This happens for OPTIONAL MATCH where the anchor comes from a prior MATCH
            // The anchor_table is set but the anchor table info is in the input plan, not in joins
            //
            // ALSO: After WITH scope barriers, anchor_table may be None if the original anchor
            // was not exported by the WITH. In this case, pick the first join as anchor.
            if let Some(anchor_alias) = &graph_joins.anchor_table {
                log::info!(
                    "üîç No FROM marker in joins, looking for anchor '{}' in input plan",
                    anchor_alias
                );

                // Try to find the anchor table in the input plan tree
                // For OPTIONAL MATCH, the anchor is from the first MATCH (which is in input)
                let rel_tables = extract_rel_and_node_tables(&graph_joins.input);
                if let Some(table_name) = rel_tables.get(anchor_alias) {
                    log::info!(
                        "‚úÖ Found anchor '{}' table '{}' in input plan",
                        anchor_alias,
                        table_name
                    );
                    return Ok(Some(FromTable::new(Some(ViewTableRef {
                        source: std::sync::Arc::new(LogicalPlan::Empty),
                        name: table_name.clone(),
                        alias: Some(anchor_alias.clone()),
                        use_final: false,
                    }))));
                }

                // Also check CTE references
                if let Some(cte_name) = graph_joins.cte_references.get(anchor_alias) {
                    log::info!(
                        "‚úÖ Anchor '{}' has CTE reference: '{}'",
                        anchor_alias,
                        cte_name
                    );
                    return Ok(Some(FromTable::new(Some(ViewTableRef {
                        source: std::sync::Arc::new(LogicalPlan::Empty),
                        name: cte_name.clone(),
                        alias: Some(anchor_alias.clone()),
                        use_final: false,
                    }))));
                }

                // Try find_table_name_for_alias as last resort
                if let Some(table_name) =
                    find_table_name_for_alias(&graph_joins.input, anchor_alias)
                {
                    log::info!(
                        "‚úÖ Found anchor '{}' via find_table_name_for_alias: '{}'",
                        anchor_alias,
                        table_name
                    );
                    return Ok(Some(FromTable::new(Some(ViewTableRef {
                        source: std::sync::Arc::new(LogicalPlan::Empty),
                        name: table_name,
                        alias: Some(anchor_alias.clone()),
                        use_final: false,
                    }))));
                }
            } else {
                // No anchor_table - likely cleared due to scope barrier
                // PRIORITY: If we have CTE references, use the LATEST CTE as FROM
                // The CTE references represent variables that are in scope after WITH clauses
                // We want the LAST CTE (highest sequence number) as it represents the final scope

                if !graph_joins.cte_references.is_empty() {
                    log::warn!(
                        "üîç anchor_table is None, but have {} CTE references - finding latest CTE as FROM",
                        graph_joins.cte_references.len()
                    );

                    // Find the CTE with the highest sequence number (format: with_*_cte_N)
                    // This is the most recent WITH clause's output
                    let mut best_cte: Option<(&String, &String, usize)> = None;
                    for (alias, cte_name) in &graph_joins.cte_references {
                        // Extract sequence number from CTE name
                        // Format: "with_tag_cte_1" or "with_inValidPostCount_postCount_tag_cte_1"
                        let seq_num = if let Some(pos) = cte_name.rfind("_cte_") {
                            cte_name[pos + 5..].parse::<usize>().unwrap_or(0)
                        } else {
                            0
                        };

                        // Keep the CTE with highest sequence number (latest in the chain)
                        // Tie-breaker: prefer longer CTE names (more aliases = more complete)
                        match &best_cte {
                            None => best_cte = Some((alias, cte_name, seq_num)),
                            Some((_, current_name, current_seq)) => {
                                if seq_num > *current_seq
                                    || (seq_num == *current_seq
                                        && cte_name.len() > current_name.len())
                                {
                                    best_cte = Some((alias, cte_name, seq_num));
                                }
                            }
                        }
                    }

                    if let Some((alias, cte_name, _)) = best_cte {
                        log::info!(
                            "‚úÖ Using latest CTE '{}' AS '{}' as FROM (from cte_references)",
                            cte_name,
                            alias
                        );
                        return Ok(Some(FromTable::new(Some(ViewTableRef {
                            source: std::sync::Arc::new(LogicalPlan::Empty),
                            name: cte_name.clone(),
                            alias: Some(alias.clone()),
                            use_final: false,
                        }))));
                    }
                }

                // SECONDARY FALLBACK: Pick first join as FROM table
                log::warn!(
                    "üîç anchor_table is None and no CTE references, using first join as FROM"
                );
                if let Some(first_join) = graph_joins.joins.first() {
                    // Check if this join has a CTE reference
                    if let Some(cte_name) =
                        graph_joins.cte_references.get(&first_join.table_alias)
                    {
                        log::info!(
                            "‚úÖ Using first join '{}' ‚Üí CTE '{}' as FROM",
                            first_join.table_alias,
                            cte_name
                        );
                        return Ok(Some(FromTable::new(Some(ViewTableRef {
                            source: std::sync::Arc::new(LogicalPlan::Empty),
                            name: cte_name.clone(),
                            alias: Some(first_join.table_alias.clone()),
                            use_final: false,
                        }))));
                    } else {
                        log::info!(
                            "‚úÖ Using first join '{}' (table '{}') as FROM",
                            first_join.table_alias,
                            first_join.table_name
                        );
                        return Ok(Some(FromTable::new(Some(ViewTableRef {
                            source: std::sync::Arc::new(LogicalPlan::Empty),
                            name: first_join.table_name.clone(),
                            alias: Some(first_join.table_alias.clone()),
                            use_final: false,
                        }))));
                    }
                }
            }

            // If we still can't find FROM, this is a real bug
            log::error!("‚ùå BUG: GraphJoins has {} joins but NO FROM marker and couldn't resolve anchor! anchor_table={:?}",
                graph_joins.joins.len(), graph_joins.anchor_table);
            for (i, join) in graph_joins.joins.iter().enumerate() {
                log::error!(
                    "  join[{}]: table='{}' alias='{}' conditions={}",
                    i,
                    join.table_name,
                    join.table_alias,
                    join.joining_on.len()
                );
            }

            // Return None to surface the bug
            None
        }
        LogicalPlan::GroupBy(group_by) => {
            from_table_to_view_ref(extract_from(&group_by.input)?)
        }
        LogicalPlan::OrderBy(order_by) => {
            from_table_to_view_ref(extract_from(&order_by.input)?)
        }
        LogicalPlan::Skip(skip) => from_table_to_view_ref(extract_from(&skip.input)?),
        LogicalPlan::Limit(limit) => from_table_to_view_ref(extract_from(&limit.input)?),
        LogicalPlan::Cte(cte) => from_table_to_view_ref(extract_from(&cte.input)?),
        LogicalPlan::Union(_) => None,
        LogicalPlan::PageRank(_) => None,
        LogicalPlan::Unwind(u) => from_table_to_view_ref(extract_from(&u.input)?),
        LogicalPlan::CartesianProduct(cp) => {
            // Try left side first (for most queries)
            let left_from = extract_from(&cp.left)?;
            if left_from.is_some() {
                // Left has a table, use it (normal case)
                from_table_to_view_ref(left_from)
            } else {
                // Left has no FROM (e.g., WITH clause creating a CTE)
                // Use right side as FROM source (e.g., new MATCH after WITH)
                log::info!(
                    "CartesianProduct: Left side has no FROM (likely CTE), using right side"
                );
                from_table_to_view_ref(extract_from(&cp.right)?)
            }
        }
        LogicalPlan::WithClause(wc) => from_table_to_view_ref(extract_from(&wc.input)?),
    };
    Ok(view_ref_to_from_table(from_ref))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_placeholder_functions() {
        // Basic tests to ensure module compiles
        assert_eq!(strip_database_prefix("test"), "test");
        assert_eq!(strip_database_prefix("db.table"), "table");
        
        // Note: has_multi_type_vlp requires a schema, tested elsewhere
        assert_eq!(get_anchor_alias_from_plan(&Arc::new(LogicalPlan::Empty)), None);
    }
}
pub fn extract_group_by(plan: &LogicalPlan) -> RenderPlanBuilderResult<Vec<RenderExpr>> {
    use crate::graph_catalog::expression_parser::PropertyValue;

    log::info!(
        "üîß GROUP BY: extract_group_by() called for plan type {:?}",
        std::mem::discriminant(plan)
    );

    /// Helper to find node properties when the alias is a relationship alias with "*" column.
    /// For denormalized schemas, the node alias gets remapped to the relationship alias,
    /// so we need to look up which node this represents and get its properties.
    fn find_node_properties_for_rel_alias(
        plan: &LogicalPlan,
        rel_alias: &str,
    ) -> Option<(Vec<(String, String)>, String)> {
        match plan {
            LogicalPlan::GraphRel(rel) if rel.alias == rel_alias => {
                // This relationship matches - get the left node's properties (most common case)
                // Left node is typically the one being grouped in WITH clause
                if let LogicalPlan::ViewScan(scan) = rel.center.as_ref() {
                    // Check direction to determine which properties to use
                    let is_incoming = rel.direction == Direction::Incoming;
                    let props = if is_incoming {
                        &scan.to_node_properties
                    } else {
                        &scan.from_node_properties
                    };

                    if let Some(node_props) = props {
                        let properties: Vec<(String, String)> = node_props
                            .iter()
                            .map(|(prop_name, prop_value)| {
                                (prop_name.clone(), prop_value.raw().to_string())
                            })
                            .collect();
                        if !properties.is_empty() {
                            // Return properties and the actual table alias to use
                            return Some((properties, rel.alias.clone()));
                        }
                    }
                }
                None
            }
            LogicalPlan::GraphRel(rel) => {
                // Not this relationship - search children
                if let Some(result) = find_node_properties_for_rel_alias(&rel.left, rel_alias) {
                    return Some(result);
                }
                if let Some(result) = find_node_properties_for_rel_alias(&rel.center, rel_alias)
                {
                    return Some(result);
                }
                find_node_properties_for_rel_alias(&rel.right, rel_alias)
            }
            LogicalPlan::Projection(proj) => {
                find_node_properties_for_rel_alias(&proj.input, rel_alias)
            }
            LogicalPlan::Filter(filter) => {
                find_node_properties_for_rel_alias(&filter.input, rel_alias)
            }
            LogicalPlan::GroupBy(gb) => {
                find_node_properties_for_rel_alias(&gb.input, rel_alias)
            }
            LogicalPlan::GraphJoins(joins) => {
                find_node_properties_for_rel_alias(&joins.input, rel_alias)
            }
            LogicalPlan::OrderBy(order) => {
                find_node_properties_for_rel_alias(&order.input, rel_alias)
            }
            LogicalPlan::Skip(skip) => {
                find_node_properties_for_rel_alias(&skip.input, rel_alias)
            }
            LogicalPlan::Limit(limit) => {
                find_node_properties_for_rel_alias(&limit.input, rel_alias)
            }
            _ => None,
        }
    }

    let group_by = match plan {
        LogicalPlan::Limit(limit) => extract_group_by(&limit.input)?,
        LogicalPlan::Skip(skip) => extract_group_by(&skip.input)?,
        LogicalPlan::OrderBy(order_by) => extract_group_by(&order_by.input)?,
        LogicalPlan::Projection(projection) => extract_group_by(&projection.input)?,
        LogicalPlan::Filter(filter) => extract_group_by(&filter.input)?,
        LogicalPlan::GraphJoins(graph_joins) => extract_group_by(&graph_joins.input)?,
        LogicalPlan::GraphNode(node) => extract_group_by(&node.input)?,
        LogicalPlan::GraphRel(rel) => {
            // For relationships, try left first, then center, then right
            extract_group_by(&rel.left)
                .or_else(|_| extract_group_by(&rel.center))
                .or_else(|_| extract_group_by(&rel.right))?
        }
        LogicalPlan::GroupBy(group_by) => {
            log::info!(
                "üîß GROUP BY: Found GroupBy plan, processing {} expressions",
                group_by.expressions.len()
            );
            let mut result: Vec<RenderExpr> = vec![];

            // Track which aliases we've already added to GROUP BY
            // This is used for the optimization: GROUP BY only the ID column
            let mut seen_group_by_aliases: std::collections::HashSet<String> =
                std::collections::HashSet::new();

            for expr in &group_by.expressions {
                // Check if this is a TableAlias that needs expansion
                if let crate::query_planner::logical_expr::LogicalExpr::TableAlias(alias) = expr
                {
                    // OPTIMIZATION: For node aliases in GROUP BY, we only need the ID column.
                    // All other columns are functionally dependent on the ID.
                    // This reduces GROUP BY from 8+ columns to just 1, improving performance.
                    let (properties, actual_table_alias): (Vec<(String, String)>, Option<String>) =
                        match group_by.input.get_properties_with_table_alias(&alias.0) {
                            Ok(result) => result,
                            Err(_) => continue,
                        };
                    if !properties.is_empty() {
                        let table_alias_to_use =
                            actual_table_alias.unwrap_or_else(|| alias.0.clone());

                        // Skip if we've already added this alias (avoid duplicates)
                        if seen_group_by_aliases.contains(&table_alias_to_use) {
                            continue;
                        }
                        seen_group_by_aliases.insert(table_alias_to_use.clone());

                        // Get the ID column from the schema (via ViewScan.id_column)
                        // This is the proper way - use schema definition, not pattern matching
                        let id_col = group_by.input.find_id_column_for_alias(&alias.0)
                            .unwrap_or_else(|_| {
                                log::warn!("‚ö†Ô∏è Could not find ID column for alias '{}', using fallback", alias.0);
                                "id".to_string()
                            });

                        log::debug!("üîß GROUP BY optimization: Using ID column '{}' from schema instead of {} properties for alias '{}'",
                            id_col, properties.len(), table_alias_to_use);

                        result.push(RenderExpr::PropertyAccessExp(PropertyAccess {
                            table_alias: TableAlias(table_alias_to_use.clone()),
                            column: PropertyValue::Column(id_col),
                        }));
                        continue;
                    }
                }

                // Check if this is a PropertyAccessExp with wildcard column "*"
                // This happens when ProjectionTagging converts TableAlias to PropertyAccessExp(alias.*)
                if let crate::query_planner::logical_expr::LogicalExpr::PropertyAccessExp(
                    prop_access,
                ) = expr
                {
                    if prop_access.column.raw() == "*" {
                        // OPTIMIZATION: For node alias wildcards in GROUP BY, we only need the ID column.
                        // All other columns are functionally dependent on the ID.
                        let (properties, actual_table_alias): (Vec<(String, String)>, Option<String>) =
                            match group_by.input.get_properties_with_table_alias(&prop_access.table_alias.0) {
                                Ok(result) => result,
                                Err(_) => continue,
                            };
                        let table_alias_to_use = actual_table_alias
                            .unwrap_or_else(|| prop_access.table_alias.0.clone());

                        // Skip if we've already added this alias (avoid duplicates)
                        if seen_group_by_aliases.contains(&table_alias_to_use) {
                            continue;
                        }
                        seen_group_by_aliases.insert(table_alias_to_use.clone());

                        // Better approach: try to find node properties for this rel alias
                        if let Some((node_props, table_alias)) =
                            find_node_properties_for_rel_alias(
                                &group_by.input,
                                &prop_access.table_alias.0,
                            )
                        {
                            // Found denormalized node properties - get ID from schema (MUST succeed)
                            let id_col = group_by.input.find_id_column_for_alias(&prop_access.table_alias.0)
                                .map_err(|e| RenderBuildError::InvalidRenderPlan(
                                    format!("Cannot find ID column for denormalized alias '{}': {}", prop_access.table_alias.0, e)
                                ))?;

                            log::debug!("üîß GROUP BY optimization: Using ID column '{}' from schema for denormalized alias '{}'",
                                id_col, table_alias);

                            result.push(RenderExpr::PropertyAccessExp(PropertyAccess {
                                table_alias: TableAlias(table_alias.clone()),
                                column: PropertyValue::Column(id_col),
                            }));
                            continue;
                        }

                        // Fallback: use ID column from schema
                        if !properties.is_empty() {
                            let id_col = group_by
                                .input
                                .find_id_column_for_alias(&prop_access.table_alias.0)
                                .map_err(|e| {
                                    RenderBuildError::InvalidRenderPlan(format!(
                                        "Cannot find ID column for alias '{}': {}",
                                        prop_access.table_alias.0, e
                                    ))
                                })?;
                            log::debug!("üîß GROUP BY optimization: Using ID column '{}' instead of {} properties for alias '{}'",
                                id_col, properties.len(), table_alias_to_use);

                            result.push(RenderExpr::PropertyAccessExp(PropertyAccess {
                                table_alias: TableAlias(table_alias_to_use.clone()),
                                column: PropertyValue::Column(id_col),
                            }));
                            continue;
                        }
                    }
                }

                // Not a TableAlias/wildcard or couldn't expand - convert normally
                let mut render_expr: RenderExpr = expr.clone().try_into()?;
                apply_property_mapping_to_expr(&mut render_expr, &group_by.input);
                result.push(render_expr);
            }

            result
        }
        _ => vec![],
    };
    Ok(group_by)
}

pub fn extract_having(plan: &LogicalPlan) -> RenderPlanBuilderResult<Option<RenderExpr>> {
    let having_clause = match plan {
        LogicalPlan::Limit(limit) => extract_having(&limit.input)?,
        LogicalPlan::Skip(skip) => extract_having(&skip.input)?,
        LogicalPlan::OrderBy(order_by) => extract_having(&order_by.input)?,
        LogicalPlan::Projection(projection) => extract_having(&projection.input)?,
        LogicalPlan::GroupBy(group_by) => {
            if let Some(having) = &group_by.having_clause {
                let mut render_expr: RenderExpr = having.clone().try_into()?;
                // Apply property mapping to the HAVING expression
                apply_property_mapping_to_expr(&mut render_expr, &group_by.input);
                Some(render_expr)
            } else {
                None
            }
        }
        _ => None,
    };
    Ok(having_clause)
}

pub fn extract_order_by(plan: &LogicalPlan) -> RenderPlanBuilderResult<Vec<OrderByItem>> {
    let order_by = match plan {
        LogicalPlan::Limit(limit) => extract_order_by(&limit.input)?,
        LogicalPlan::Skip(skip) => extract_order_by(&skip.input)?,
        LogicalPlan::OrderBy(order_by) => order_by
            .items
            .iter()
            .cloned()
            .map(|item| {
                let mut order_item: OrderByItem = item.try_into()?;
                // Apply property mapping to the order by expression
                apply_property_mapping_to_expr(&mut order_item.expression, &order_by.input);
                Ok(order_item)
            })
            .collect::<Result<Vec<OrderByItem>, RenderBuildError>>()?,
        _ => vec![],
    };
    Ok(order_by)
}

pub fn extract_limit(plan: &LogicalPlan) -> Option<i64> {
    match plan {
        LogicalPlan::Limit(limit) => Some(limit.count),
        _ => None,
    }
}

pub fn extract_skip(plan: &LogicalPlan) -> Option<i64> {
    match plan {
        LogicalPlan::Limit(limit) => extract_skip(&limit.input),
        LogicalPlan::Skip(skip) => Some(skip.count),
        _ => None,
    }
}

/// Helper function to find the label for a given alias in the logical plan.
pub fn find_label_for_alias(plan: &LogicalPlan, target_alias: &str) -> Option<String> {
    match plan {
        LogicalPlan::GraphNode(node) => {
            if node.alias == target_alias {
                // label is Option<String>, unwrap it
                node.label.clone()
            } else {
                None
            }
        }
        LogicalPlan::GraphRel(rel) => {
            // Check left and right connections
            // Note: GraphRel doesn't have nested plans, just connection strings
            None
        }
        LogicalPlan::Filter(filter) => find_label_for_alias(&filter.input, target_alias),
        LogicalPlan::WithClause(wc) => find_label_for_alias(&wc.input, target_alias),
        LogicalPlan::Projection(proj) => find_label_for_alias(&proj.input, target_alias),
        _ => None,
    }
}

pub fn get_anchor_alias_from_plan(plan: &Arc<LogicalPlan>) -> Option<String> {
    match plan.as_ref() {
        LogicalPlan::GraphNode(node) => Some(node.alias.clone()),
        LogicalPlan::GraphRel(rel) => Some(rel.left_connection.clone()),
        LogicalPlan::Projection(proj) => get_anchor_alias_from_plan(&proj.input),
        LogicalPlan::Filter(filter) => get_anchor_alias_from_plan(&filter.input),
        LogicalPlan::GroupBy(gb) => get_anchor_alias_from_plan(&gb.input),
        LogicalPlan::CartesianProduct(cp) => get_anchor_alias_from_plan(&cp.left),
        _ => None,
    }
}

pub fn get_end_table_name_or_cte(
    plan: &LogicalPlan,
) -> Result<String, crate::render_plan::errors::RenderBuildError> {
    // First, try to get source_table directly from ViewScan (handles CTE references)
    if let Some(table_name) = crate::render_plan::plan_builder_helpers::extract_end_node_table_name(plan) {
        // Check if this looks like a CTE (starts with "with_")
        if table_name.starts_with("with_") {
            return Ok(table_name);
        }
    }
    // Extract END NODE table name - handles nested GraphRel correctly
    crate::render_plan::plan_builder_helpers::extract_end_node_table_name(plan).ok_or_else(|| {
        crate::render_plan::errors::RenderBuildError::MissingTableInfo(
            "end node table in extract_joins".to_string(),
        )
    })
}

pub fn get_start_table_name_or_cte(
    plan: &LogicalPlan,
) -> Result<String, crate::render_plan::errors::RenderBuildError> {
    // First, try to get source_table directly from ViewScan (handles CTE references)
    if let Some(table_name) = crate::render_plan::plan_builder_helpers::extract_table_name(plan) {
        // Check if this looks like a CTE (starts with "with_")
        if table_name.starts_with("with_") {
            return Ok(table_name);
        }
    }
    // Extract table name from ViewScan - no fallback
    crate::render_plan::plan_builder_helpers::extract_table_name(plan).ok_or_else(|| {
        crate::render_plan::errors::RenderBuildError::MissingTableInfo(
            "start node table in extract_joins".to_string(),
        )
    })
}

pub fn extract_sorted_properties(
    property_map: &std::collections::HashMap<
        String,
        crate::graph_catalog::expression_parser::PropertyValue,
    >,
) -> Vec<(String, String)> {
    let mut properties: Vec<(String, String)> = property_map
        .iter()
        .map(|(prop_name, prop_value)| (prop_name.clone(), prop_value.raw().to_string()))
        .collect();
    properties.sort_by(|a, b| a.0.cmp(&b.0));
    properties
}

// ============================================================================
// CTE Expression Rewriting Functions
// ============================================================================

/// Apply CTE name remapping to RenderExpr recursively
///
/// # Arguments
/// * `expr` - The expression to rewrite
/// * `cte_name_mapping` - Maps analyzer CTE names to actual CTE names
pub fn remap_cte_names_in_expr(
    expr: crate::render_plan::render_expr::RenderExpr,
    cte_name_mapping: &std::collections::HashMap<String, String>,
) -> crate::render_plan::render_expr::RenderExpr {
    use crate::render_plan::render_expr::*;

    match expr {
        RenderExpr::PropertyAccessExp(pa) => {
            let table_alias = &pa.table_alias.0;

            // Check if this table_alias is a CTE name that needs remapping
            if let Some(actual_cte_name) = cte_name_mapping.get(table_alias) {
                log::debug!("üîß remap_cte_names: {} ‚Üí {}", table_alias, actual_cte_name);
                RenderExpr::PropertyAccessExp(PropertyAccess {
                    table_alias: TableAlias(actual_cte_name.clone()),
                    column: pa.column,
                })
            } else {
                RenderExpr::PropertyAccessExp(pa)
            }
        }
        RenderExpr::AggregateFnCall(agg) => {
            let new_args = agg
                .args
                .into_iter()
                .map(|arg| remap_cte_names_in_expr(arg, cte_name_mapping))
                .collect();
            RenderExpr::AggregateFnCall(AggregateFnCall {
                name: agg.name,
                args: new_args,
            })
        }
        RenderExpr::ScalarFnCall(func) => {
            let new_args = func
                .args
                .into_iter()
                .map(|arg| remap_cte_names_in_expr(arg, cte_name_mapping))
                .collect();
            RenderExpr::ScalarFnCall(ScalarFnCall {
                name: func.name,
                args: new_args,
            })
        }
        RenderExpr::OperatorApplicationExp(op) => {
            let new_operands = op
                .operands
                .into_iter()
                .map(|operand| remap_cte_names_in_expr(operand, cte_name_mapping))
                .collect();
            RenderExpr::OperatorApplicationExp(OperatorApplication {
                operator: op.operator,
                operands: new_operands,
            })
        }
        RenderExpr::Case(case) => {
            let new_when_then = case
                .when_then
                .into_iter()
                .map(|(when, then)| {
                    (
                        remap_cte_names_in_expr(when, cte_name_mapping),
                        remap_cte_names_in_expr(then, cte_name_mapping),
                    )
                })
                .collect();
            let new_expr = case
                .expr
                .map(|e| Box::new(remap_cte_names_in_expr(*e, cte_name_mapping)));
            let new_else = case
                .else_expr
                .map(|e| Box::new(remap_cte_names_in_expr(*e, cte_name_mapping)));
            RenderExpr::Case(RenderCase {
                expr: new_expr,
                when_then: new_when_then,
                else_expr: new_else,
            })
        }
        other => other,
    }
}

/// Apply CTE name remapping to all expressions in a RenderPlan
pub fn remap_cte_names_in_render_plan(
    plan: &mut crate::render_plan::RenderPlan,
    cte_name_mapping: &std::collections::HashMap<String, String>,
) {
    use crate::render_plan::render_expr::RenderExpr;

    if cte_name_mapping.is_empty() {
        return;
    }

    log::info!(
        "üîß remap_cte_names_in_render_plan: Applying {} CTE name mappings",
        cte_name_mapping.len()
    );
    for (from, to) in cte_name_mapping {
        log::info!("üîß   {} ‚Üí {}", from, to);
    }

    // Rewrite SELECT items
    for item in &mut plan.select.items {
        item.expression = remap_cte_names_in_expr(item.expression.clone(), cte_name_mapping);
    }

    // Rewrite JOIN conditions
    for join in &mut plan.joins.0 {
        for op in &mut join.joining_on {
            // Recursively rewrite the OperatorApplication
            if let RenderExpr::OperatorApplicationExp(new_op) = remap_cte_names_in_expr(
                RenderExpr::OperatorApplicationExp(op.clone()),
                cte_name_mapping,
            ) {
                *op = new_op;
            }
        }
    }

    // Rewrite WHERE clause
    if let Some(filter) = &plan.filters.0 {
        plan.filters.0 = Some(remap_cte_names_in_expr(filter.clone(), cte_name_mapping));
    }

    // Rewrite GROUP BY
    plan.group_by.0 = plan
        .group_by
        .0
        .iter()
        .map(|expr| remap_cte_names_in_expr(expr.clone(), cte_name_mapping))
        .collect();

    // Rewrite ORDER BY
    for item in &mut plan.order_by.0 {
        item.expression = remap_cte_names_in_expr(item.expression.clone(), cte_name_mapping);
    }
}

/// Rewrite expressions to use the FROM alias and CTE column names
///
/// Handles three cases:
/// 1. PropertyAccess with WITH alias (e.g., "a.full_name") ‚Üí rewrite to FROM alias + CTE column (e.g., "a_age.a_name")
/// 2. PropertyAccess with CTE name (e.g., "with_a_age_cte_1.age") ‚Üí rewrite to FROM alias (e.g., "a_age.age")
/// 3. Other expressions ‚Üí recursively rewrite nested expressions
pub fn rewrite_cte_expression(
    expr: crate::render_plan::render_expr::RenderExpr,
    cte_name: &str,
    from_alias: &str,
    with_aliases: &std::collections::HashSet<String>,
    reverse_mapping: &std::collections::HashMap<(String, String), String>,
) -> crate::render_plan::render_expr::RenderExpr {
    use crate::render_plan::render_expr::*;

    match expr {
        RenderExpr::PropertyAccessExp(pa) => {
            let table_alias = &pa.table_alias.0;

            // Case 1: Table alias is a WITH alias (e.g., "a")
            if with_aliases.contains(table_alias) {
                // Look up the CTE column name from reverse mapping
                let column_name = match &pa.column {
                    PropertyValue::Column(col) => col.clone(),
                    _ => return RenderExpr::PropertyAccessExp(pa), // Don't rewrite complex columns
                };

                let key = (table_alias.clone(), column_name.clone());
                if let Some(cte_column) = reverse_mapping.get(&key) {
                    log::debug!(
                        "üîß Rewriting {}.{} ‚Üí {}.{}",
                        table_alias,
                        column_name,
                        from_alias,
                        cte_column
                    );
                    RenderExpr::PropertyAccessExp(PropertyAccess {
                        table_alias: TableAlias(from_alias.to_string()),
                        column: PropertyValue::Column(cte_column.clone()),
                    })
                } else {
                    // No mapping found - might be an aggregate column, use as-is
                    log::debug!(
                        "üîß Rewriting {}.{} ‚Üí {}.{} (no mapping)",
                        table_alias,
                        column_name,
                        from_alias,
                        column_name
                    );
                    RenderExpr::PropertyAccessExp(PropertyAccess {
                        table_alias: TableAlias(from_alias.to_string()),
                        column: PropertyValue::Column(column_name),
                    })
                }
            }
            // Case 2: Table alias is the CTE name itself
            else if table_alias == cte_name {
                log::debug!(
                    "üîß Rewriting CTE reference {}.{:?} ‚Üí {}.{:?}",
                    table_alias,
                    pa.column,
                    from_alias,
                    pa.column
                );
                RenderExpr::PropertyAccessExp(PropertyAccess {
                    table_alias: TableAlias(from_alias.to_string()),
                    column: pa.column,
                })
            }
            // Case 3: Keep as-is
            else {
                RenderExpr::PropertyAccessExp(pa)
            }
        }
        RenderExpr::AggregateFnCall(agg) => {
            // Recursively rewrite arguments
            let new_args = agg
                .args
                .into_iter()
                .map(|arg| {
                    rewrite_cte_expression(arg, cte_name, from_alias, with_aliases, reverse_mapping)
                })
                .collect();
            RenderExpr::AggregateFnCall(AggregateFnCall {
                name: agg.name,
                args: new_args,
            })
        }
        RenderExpr::ScalarFnCall(func) => {
            // Recursively rewrite arguments
            let new_args = func
                .args
                .into_iter()
                .map(|arg| {
                    rewrite_cte_expression(arg, cte_name, from_alias, with_aliases, reverse_mapping)
                })
                .collect();
            RenderExpr::ScalarFnCall(ScalarFnCall {
                name: func.name,
                args: new_args,
            })
        }
        RenderExpr::OperatorApplicationExp(op) => {
            // Recursively rewrite operands
            let new_operands = op
                .operands
                .into_iter()
                .map(|operand| {
                    rewrite_cte_expression(
                        operand,
                        cte_name,
                        from_alias,
                        with_aliases,
                        reverse_mapping,
                    )
                })
                .collect();
            RenderExpr::OperatorApplicationExp(OperatorApplication {
                operator: op.operator,
                operands: new_operands,
            })
        }
        RenderExpr::Case(case_expr) => {
            // Recursively rewrite CASE expression
            let new_expr = case_expr.expr.map(|e| {
                Box::new(rewrite_cte_expression(
                    *e,
                    cte_name,
                    from_alias,
                    with_aliases,
                    reverse_mapping,
                ))
            });
            let new_when_then: Vec<(RenderExpr, RenderExpr)> = case_expr
                .when_then
                .into_iter()
                .map(|(when, then)| {
                    (
                        rewrite_cte_expression(
                            when,
                            cte_name,
                            from_alias,
                            with_aliases,
                            reverse_mapping,
                        ),
                        rewrite_cte_expression(
                            then,
                            cte_name,
                            from_alias,
                            with_aliases,
                            reverse_mapping,
                        ),
                    )
                })
                .collect();
            let new_else = case_expr.else_expr.map(|e| {
                Box::new(rewrite_cte_expression(
                    *e,
                    cte_name,
                    from_alias,
                    with_aliases,
                    reverse_mapping,
                ))
            });
            RenderExpr::Case(RenderCase {
                expr: new_expr,
                when_then: new_when_then,
                else_expr: new_else,
            })
        }
        // Other expression types don't need rewriting
        other => other,
    }
}

// ============================================================================
// VLP and Scope Analysis Functions
// ============================================================================

/// Check if the plan contains a multi-type VLP pattern
/// Returns true if there's a variable-length path with multiple relationship types
pub fn has_multi_type_vlp(
    plan: &crate::query_planner::logical_plan::LogicalPlan,
    schema: &crate::graph_catalog::graph_schema::GraphSchema,
) -> bool {
    use crate::query_planner::logical_plan::LogicalPlan;

    match plan {
        LogicalPlan::GraphRel(graph_rel) => {
            // Check if it's a VLP pattern
            if graph_rel.variable_length.is_some() {
                let rel_types: Vec<String> = graph_rel.labels.clone().unwrap_or_default();
                // Use the same logic as CTE extraction
                crate::render_plan::cte_extraction::should_use_join_expansion_public(
                    graph_rel, &rel_types, schema,
                )
            } else {
                false
            }
        }
        LogicalPlan::Projection(proj) => has_multi_type_vlp(&proj.input, schema),
        LogicalPlan::Filter(filter) => has_multi_type_vlp(&filter.input, schema),
        LogicalPlan::GroupBy(gb) => has_multi_type_vlp(&gb.input, schema),
        LogicalPlan::OrderBy(order) => has_multi_type_vlp(&order.input, schema),
        LogicalPlan::Limit(limit) => has_multi_type_vlp(&limit.input, schema),
        LogicalPlan::Skip(skip) => has_multi_type_vlp(&skip.input, schema),
        LogicalPlan::GraphJoins(joins) => has_multi_type_vlp(&joins.input, schema),
        _ => false,
    }
}

/// Collect all aliases from the inner scope of a WITH clause (before aggregation)
/// Used to identify which filters should be pushed inside the WITH's CTE
pub fn collect_inner_scope_aliases(
    group_by_plan: &crate::query_planner::logical_plan::LogicalPlan,
) -> std::collections::HashSet<String> {
    use crate::query_planner::logical_plan::LogicalPlan;

    let mut aliases = std::collections::HashSet::new();

    fn collect_from_graph_rel(
        plan: &LogicalPlan,
        aliases: &mut std::collections::HashSet<String>,
    ) {
        match plan {
            LogicalPlan::GraphRel(gr) => {
                aliases.insert(gr.alias.clone()); // relationship alias
                aliases.insert(gr.left_connection.clone()); // left node alias
                aliases.insert(gr.right_connection.clone()); // right node alias
                collect_from_graph_rel(&gr.left, aliases);
                collect_from_graph_rel(&gr.right, aliases);
            }
            LogicalPlan::GraphNode(gn) => {
                aliases.insert(gn.alias.clone());
                collect_from_graph_rel(&gn.input, aliases);
            }
            LogicalPlan::Projection(p) => collect_from_graph_rel(&p.input, aliases),
            LogicalPlan::Filter(f) => collect_from_graph_rel(&f.input, aliases),
            _ => {}
        }
    }

    // First unwrap GroupBy and GraphJoins to find the actual GraphRel structure
    fn find_graph_rel_in_plan(
        plan: &LogicalPlan,
        aliases: &mut std::collections::HashSet<String>,
    ) {
        match plan {
            LogicalPlan::GroupBy(gb) => find_graph_rel_in_plan(&gb.input, aliases),
            LogicalPlan::GraphJoins(gj) => find_graph_rel_in_plan(&gj.input, aliases),
            LogicalPlan::Projection(p) => {
                // This is likely the WITH projection - look at its input GraphRel
                collect_from_graph_rel(&p.input, aliases);
            }
            LogicalPlan::Filter(f) => find_graph_rel_in_plan(&f.input, aliases),
            LogicalPlan::GraphRel(_gr) => {
                collect_from_graph_rel(plan, aliases);
            }
            _ => {}
        }
    }

    find_graph_rel_in_plan(group_by_plan, &mut aliases);
    aliases
}

/// Check if a RenderExpr references any alias in the given set
pub fn cond_references_alias(
    cond: &crate::render_plan::render_expr::RenderExpr,
    aliases: &std::collections::HashSet<String>,
) -> bool {
    use crate::render_plan::render_expr::RenderExpr;

    match cond {
        RenderExpr::PropertyAccessExp(pa) => aliases.contains(&pa.table_alias.0),
        RenderExpr::OperatorApplicationExp(op) => op
            .operands
            .iter()
            .any(|o| cond_references_alias(o, aliases)),
        _ => false,
    }
}

/// Check if an OperatorApplication references any alias in the given set
pub fn operator_references_alias(
    op: &crate::render_plan::render_expr::OperatorApplication,
    aliases: &std::collections::HashSet<String>,
) -> bool {
    op.operands
        .iter()
        .any(|o| cond_references_alias(o, aliases))
}

// ============================================================================

// ============================================================================
// Utility Functions - CTE Management
// ============================================================================

/// Hoist nested CTEs from a RenderPlan to a parent CTE list.
/// This is used to flatten CTE hierarchies.
pub fn hoist_nested_ctes(from: &mut RenderPlan, to: &mut Vec<Cte>) {
    let nested_ctes = std::mem::take(&mut from.ctes.0);
    if !nested_ctes.is_empty() {
        log::info!(
            "üîß hoist_nested_ctes: Hoisting {} nested CTEs",
            nested_ctes.len()
        );
        to.extend(nested_ctes);
    }
}

/// Find the alias of a GraphNode whose ViewScan references the given CTE.
///
/// This is used to find the anchor alias for a CTE reference. For example, if we have:
///   GraphNode { alias: "a_b", input: ViewScan { source_table: "with_a_b_cte2", ... } }
/// And cte_name is "with_a_b_cte2", this returns Some("a_b").
pub fn find_cte_reference_alias(plan: &LogicalPlan, cte_name: &str) -> Option<String> {
    use crate::query_planner::logical_plan::*;

    match plan {
        LogicalPlan::GraphNode(node) => {
            // Check if this GraphNode's ViewScan references the CTE
            if let LogicalPlan::ViewScan(vs) = node.input.as_ref() {
                if vs.source_table == cte_name {
                    return Some(node.alias.clone());
                }
            }
            // Recurse into input
            find_cte_reference_alias(&node.input, cte_name)
        }
        LogicalPlan::GraphRel(rel) => {
            // Search in all branches
            find_cte_reference_alias(&rel.left, cte_name)
                .or_else(|| find_cte_reference_alias(&rel.right, cte_name))
        }
        LogicalPlan::Projection(proj) => find_cte_reference_alias(&proj.input, cte_name),
        LogicalPlan::Limit(limit) => find_cte_reference_alias(&limit.input, cte_name),
        LogicalPlan::OrderBy(order) => find_cte_reference_alias(&order.input, cte_name),
        LogicalPlan::GraphJoins(gj) => find_cte_reference_alias(&gj.input, cte_name),
        LogicalPlan::Filter(filter) => find_cte_reference_alias(&filter.input, cte_name),
        LogicalPlan::GroupBy(gb) => find_cte_reference_alias(&gb.input, cte_name),
        _ => None,
    }
}

/// Collect all aliases from a logical plan (GraphNode, GraphRel, GraphJoins).
pub fn collect_aliases_from_plan(plan: &LogicalPlan) -> std::collections::HashSet<String> {
    use std::collections::HashSet;

    fn collect_recursive(plan: &LogicalPlan, aliases: &mut HashSet<String>) {
        match plan {
            LogicalPlan::GraphNode(node) => {
                aliases.insert(node.alias.clone());
                collect_recursive(&node.input, aliases);
            }
            LogicalPlan::GraphRel(rel) => {
                // GraphRel alias is the relationship alias (e.g., "t1")
                if !rel.alias.is_empty() {
                    aliases.insert(rel.alias.clone());
                }
                collect_recursive(&rel.left, aliases);
                collect_recursive(&rel.center, aliases);
                collect_recursive(&rel.right, aliases);
            }
            LogicalPlan::Projection(proj) => {
                collect_recursive(&proj.input, aliases);
            }
            LogicalPlan::Filter(filter) => {
                collect_recursive(&filter.input, aliases);
            }
            LogicalPlan::GroupBy(gb) => {
                collect_recursive(&gb.input, aliases);
            }
            LogicalPlan::GraphJoins(gj) => {
                collect_recursive(&gj.input, aliases);
                for join in &gj.joins {
                    aliases.insert(join.table_alias.clone());
                }
            }
            LogicalPlan::Limit(limit) => collect_recursive(&limit.input, aliases),
            LogicalPlan::OrderBy(order) => collect_recursive(&order.input, aliases),
            LogicalPlan::Skip(skip) => collect_recursive(&skip.input, aliases),
            LogicalPlan::Union(union) => {
                for input in &union.inputs {
                    collect_recursive(input, aliases);
                }
            }
            LogicalPlan::ViewScan(_) => {}
            LogicalPlan::Unwind(_) => {}
            LogicalPlan::Cte(_) => {}
            _ => {} // Handle other variants (Empty, Scan, PageRank, CartesianProduct, etc.)
        }
    }

    let mut aliases = HashSet::new();
    collect_recursive(plan, &mut aliases);
    aliases
}

/// Rewrite operator application expressions with reverse alias mapping.
pub fn rewrite_operator_application(
    op: OperatorApplication,
    reverse_mapping: &HashMap<(String, String), String>,
) -> OperatorApplication {
    let new_operands: Vec<RenderExpr> = op
        .operands
        .into_iter()
        .map(|operand| rewrite_expression_simple(&operand, reverse_mapping))
        .collect();
    OperatorApplication {
        operator: op.operator,
        operands: new_operands,
    }
}

/// Check if a join is for the inner scope (part of the pre-WITH pattern).
/// This is determined by checking if the join references aliases that are
/// part of the first MATCH (before WITH).
pub fn is_join_for_inner_scope(
    _plan: &LogicalPlan,
    join: &crate::query_planner::logical_plan::Join,
    _with_alias: &str,
) -> bool {
    // For WITH+aggregation patterns, joins with aliases p, t1 are for the inner scope
    // Joins with aliases t2, post are for the outer scope
    // We detect inner scope joins by checking if they reference aliases that are:
    // 1. Part of the first MATCH (before WITH)
    // 2. Not the with_alias itself

    // Simple heuristic: inner joins typically have aliases like p, t1
    // Outer joins have aliases like t2, post
    // A more robust approach would track which aliases are defined in which scope

    // For now, use a simple heuristic based on join table alias pattern
    // Inner scope joins are the first N joins where N is determined by examining the plan
    // This is a simplification - in production, we should track scope properly

    // Actually, let's check if the join references a table that exists in the inner scope
    // For the pattern: p -> f (inner), f -> post (outer)
    // Joins for t1 (KNOWS) and f should be inner
    // Joins for t2 (HAS_CREATOR) and post should be outer

    // For now, return false (no filtering) - this is a placeholder
    // In production, we'd need proper scope tracking
    false
}
// CTE Join Condition Extraction Functions
// ============================================================================

/// Extract CTE join conditions from WHERE clause filters
/// Analyzes filter expressions to find equality comparisons between CTE columns and table columns
/// Returns: Vec<(cte_name, cte_column, main_table_alias, main_column)>
pub fn extract_cte_join_conditions(
    filters: &Option<crate::render_plan::render_expr::RenderExpr>,
    cte_references: &std::collections::HashMap<String, String>,
) -> Vec<(String, String, String, String)> {
    let mut conditions = vec![];

    if let Some(filter_expr) = filters {
        extract_cte_conditions_recursive(filter_expr, cte_references, &mut conditions);
    }

    log::info!(
        "üîß extract_cte_join_conditions: Found {} CTE join conditions: {:?}",
        conditions.len(),
        conditions
    );
    conditions
}

/// Recursively search filter expressions for CTE equality comparisons
pub fn extract_cte_conditions_recursive(
    expr: &crate::render_plan::render_expr::RenderExpr,
    cte_references: &std::collections::HashMap<String, String>,
    conditions: &mut Vec<(String, String, String, String)>,
) {
    use crate::render_plan::render_expr::*;

    match expr {
        RenderExpr::OperatorApplicationExp(op_app) => {
            // Look for Equal operator
            if matches!(op_app.operator, Operator::Equal) && op_app.operands.len() == 2 {
                let left = &op_app.operands[0];
                let right = &op_app.operands[1];

                // Check if one side is a CTE column and the other is a table column
                if let Some(cond) = extract_join_from_equality(left, right, cte_references) {
                    log::info!(
                        "üîß Found CTE join condition: CTE {}. {} = {}.{}",
                        cond.0,
                        cond.1,
                        cond.2,
                        cond.3
                    );
                    conditions.push(cond);
                } else if let Some(cond) = extract_join_from_equality(right, left, cte_references) {
                    // Try reversed order
                    conditions.push(cond);
                }
            }

            // Check for AND/OR - recurse into operands
            if matches!(op_app.operator, Operator::And | Operator::Or) {
                for operand in &op_app.operands {
                    extract_cte_conditions_recursive(operand, cte_references, conditions);
                }
            }
        }
        _ => {}
    }
}

/// Try to extract a CTE join condition from an equality comparison (RenderExpr version)
/// Returns: Some((cte_name, cte_column, main_table_alias, main_column)) if found
pub fn extract_join_from_equality(
    left: &crate::render_plan::render_expr::RenderExpr,
    right: &crate::render_plan::render_expr::RenderExpr,
    cte_references: &std::collections::HashMap<String, String>,
) -> Option<(String, String, String, String)> {
    use crate::render_plan::render_expr::*;

    // Pattern 1: left is CTE column, right is table column
    // Example: source_ip = conn.orig_h
    if let RenderExpr::ColumnAlias(col_alias) = left {
        // Check if this column alias references a CTE
        if let Some(cte_name) = cte_references.get(&col_alias.0) {
            // Right side should be a property access (table.column)
            if let RenderExpr::PropertyAccessExp(prop) = right {
                return Some((
                    cte_name.clone(),
                    col_alias.0.clone(),
                    prop.table_alias.0.clone(),
                    match &prop.column {
                        PropertyValue::Column(col) => col.clone(),
                        _ => return None,
                    },
                ));
            }
        }
    }

    // Pattern 2: left is table column, right is CTE column
    // Example: conn.orig_h = source_ip
    if let RenderExpr::PropertyAccessExp(prop) = left {
        if let RenderExpr::ColumnAlias(col_alias) = right {
            if let Some(cte_name) = cte_references.get(&col_alias.0) {
                return Some((
                    cte_name.clone(),
                    col_alias.0.clone(),
                    prop.table_alias.0.clone(),
                    match &prop.column {
                        PropertyValue::Column(col) => col.clone(),
                        _ => return None,
                    },
                ));
            }
        }
    }

    None
}

/// Rewrite CTE column references to include alias prefix
/// Converts "friend.id" ‚Üí "friend.friend_id" for consistency
pub fn rewrite_cte_column_references(expr: &mut crate::render_plan::render_expr::RenderExpr) {
    use crate::render_plan::render_expr::*;

    match expr {
        RenderExpr::PropertyAccessExp(pa) => {
            let table_alias = &pa.table_alias.0;
            let column_name = match &pa.column {
                PropertyValue::Column(col) => col.clone(),
                _ => return,
            };

            // Check if this looks like a simple property reference (no underscore prefix)
            // If so, rewrite it to include the alias prefix: "friend.id" ‚Üí "friend.friend_id"
            if !column_name.starts_with(&format!("{}_", table_alias)) {
                let new_column = format!("{}_{}", table_alias, column_name);
                log::debug!(
                    "üîß rewrite_cte_column_references: {}.{} ‚Üí {}.{}",
                    table_alias,
                    column_name,
                    table_alias,
                    new_column
                );
                pa.column = PropertyValue::Column(new_column);
            }
        }
        RenderExpr::AggregateFnCall(agg) => {
            // Recursively rewrite arguments
            for arg in &mut agg.args {
                rewrite_cte_column_references(arg);
            }
        }
        RenderExpr::ScalarFnCall(func) => {
            // Recursively rewrite arguments
            for arg in &mut func.args {
                rewrite_cte_column_references(arg);
            }
        }
        RenderExpr::OperatorApplicationExp(op) => {
            // Recursively rewrite all operands
            for operand in &mut op.operands {
                rewrite_cte_column_references(operand);
            }
        }
        _ => {
            // Other expression types don't need rewriting
        }
    }
}

