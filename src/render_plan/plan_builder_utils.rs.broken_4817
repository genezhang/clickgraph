//! Pure utility functions for plan building
//!
//! This module contains utility functions that have no dependencies on LogicalPlan
//! or complex state. These are safe to extract early in the refactoring process.
//!
//! Functions in this module should be:
//! - Pure (no side effects)
//! - Independent of LogicalPlan structure
//! - Reusable across different builder modules

use crate::graph_catalog::graph_schema::GraphSchema;
use crate::query_planner::logical_plan::LogicalPlan;
use crate::query_planner::logical_expr::LogicalExpr;
use crate::query_planner::plan_ctx::PlanCtx;
use std::collections::{HashMap, HashSet};
use crate::render_plan::SelectItem;
use log::debug;
use crate::render_plan::plan_builder::RenderPlanBuilder;
use crate::render_plan::errors::RenderBuildError;
use crate::render_plan::{
    RenderPlan, SelectItems, FromTableItem, JoinItems, ArrayJoinItem, ArrayJoin, FilterItems,
    GroupByExpressions, OrderByItems, SkipItem, LimitItem, UnionItems,
    CteItems, Cte, CteContent, Join, JoinType, OrderByItem, OrderByOrder,
    FromTable, ViewTableRef, ColumnAlias, render_expr::{RenderExpr, OperatorApplication, Operator, PropertyAccess, TableAlias}
};
use crate::query_planner::logical_plan::{
    GroupBy, Projection, Filter, Limit, OrderBy, Skip, GraphJoins, GraphRel, GraphNode, Unwind
};
use crate::graph_catalog::expression_parser::PropertyValue;
use crate::render_plan::plan_builder_helpers::{
    find_table_name_for_alias, apply_property_mapping_to_expr, is_invalid_filter_expression, sort_joins_by_dependency,
    collect_graphrel_predicates, collect_schema_filters, is_node_denormalized, extract_table_name, extract_id_column,
    get_all_relationship_connections, find_anchor_node, extract_rel_and_node_tables,
    has_with_clause_in_graph_rel, update_graph_joins_cte_refs, render_without_with_detection,
    expand_table_alias_to_group_by_id_only, rewrite_vlp_union_branch_aliases
};
use crate::render_plan::cte_extraction::{
    build_vlp_context, expand_fixed_length_joins_with_context, VlpSchemaType,
    RelationshipColumns, table_to_id_column, generate_cycle_prevention_filters, extract_relationship_columns
};
use crate::render_plan::cte_generation::analyze_property_requirements;
use crate::render_plan::view_table_ref::{from_table_to_view_ref, view_ref_to_from_table};
use crate::server::GLOBAL_SCHEMAS;
use crate::render_plan::filter_pipeline::{categorize_filters, CategorizedFilters};
use std::sync::Arc;

pub type RenderPlanBuilderResult<T> = Result<T, RenderBuildError>;

/// Build property mapping from select items for CTE column resolution.
/// Maps (alias, property) -> column_name for property access resolution.
///
/// This function handles three patterns:
/// 1. "alias.property" (dotted, used in VLP CTEs)
/// 2. "alias_property" (underscore, used in WITH CTEs)  
/// 3. No separator - aggregate column like "friends" from collect()
pub fn build_property_mapping_from_columns(
    select_items: &[SelectItem],
) -> HashMap<(String, String), String> {
    let mut property_mapping = HashMap::new();

    for item in select_items {
        if let Some(col_alias) = &item.col_alias {
            let col_name = &col_alias.0;

            // Pattern 1: "alias.property" (dotted, used in VLP CTEs)
            if let Some(dot_pos) = col_name.find('.') {
                let alias = col_name[..dot_pos].to_string();
                let property = col_name[dot_pos + 1..].to_string();
                property_mapping.insert((alias.clone(), property.clone()), col_name.clone());
                log::debug!(
                    "  Property mapping: ({}, {}) ‚Üí {}",
                    alias,
                    property,
                    col_name
                );
            }
            // Pattern 2: "alias_property" (underscore, used in WITH CTEs)
            else if let Some(underscore_pos) = col_name.find('_') {
                let alias = col_name[..underscore_pos].to_string();
                let property = col_name[underscore_pos + 1..].to_string();
                property_mapping.insert((alias.clone(), property.clone()), col_name.clone());
                log::debug!(
                    "  Property mapping: ({}, {}) ‚Üí {}",
                    alias,
                    property,
                    col_name
                );
            }
            // Pattern 3: No separator - aggregate column like "friends" from collect()
            // Store with empty alias so ARRAY JOIN can find it: ("", column_name) ‚Üí column_name
            else {
                property_mapping.insert(("".to_string(), col_name.clone()), col_name.clone());
                log::debug!(
                    "  Property mapping (aggregate): (\"\", {}) ‚Üí {}",
                    col_name,
                    col_name
                );
            }
        }
    }

    log::info!(
        "Built property mapping with {} entries",
        property_mapping.len()
    );
    property_mapping
}

/// Strip database prefix from table name for use in CTE names.
/// Converts "ldbc.Comment" -> "Comment", "Message" -> "Message"
pub fn strip_database_prefix(table_name: &str) -> String {
    table_name
        .rsplit_once('.')
        .map(|(_, table)| table.to_string())
        .unwrap_or_else(|| table_name.to_string())
}

/// Collect all table/node aliases defined in a logical plan.
/// This is used to identify which aliases are in the pre-WITH scope.
pub fn collect_aliases_from_plan(plan: &LogicalPlan) -> HashSet<String> {
    fn collect_recursive(plan: &LogicalPlan, aliases: &mut HashSet<String>) {
        match plan {
            LogicalPlan::GraphNode(node) => {
                aliases.insert(node.alias.clone());
                collect_recursive(&node.input, aliases);
            }
            LogicalPlan::GraphRel(rel) => {
                // GraphRel alias is the relationship alias (e.g., "t1")
                if !rel.alias.is_empty() {
                    aliases.insert(rel.alias.clone());
                }
                collect_recursive(&rel.left, aliases);
                collect_recursive(&rel.center, aliases);
                collect_recursive(&rel.right, aliases);
            }
            LogicalPlan::Projection(proj) => {
                collect_recursive(&proj.input, aliases);
            }
            LogicalPlan::Filter(filter) => {
                collect_recursive(&filter.input, aliases);
            }
            LogicalPlan::GroupBy(gb) => {
                collect_recursive(&gb.input, aliases);
            }
            LogicalPlan::GraphJoins(gj) => {
                collect_recursive(&gj.input, aliases);
                for join in &gj.joins {
                    aliases.insert(join.table_alias.clone());
                }
            }
            LogicalPlan::Limit(limit) => collect_recursive(&limit.input, aliases),
            LogicalPlan::OrderBy(order) => collect_recursive(&order.input, aliases),
            LogicalPlan::Skip(skip) => collect_recursive(&skip.input, aliases),
            LogicalPlan::Union(union) => {
                for input in &union.inputs {
                    collect_recursive(input, aliases);
                }
            }
            LogicalPlan::ViewScan(_) => {}
            LogicalPlan::Unwind(_) => {}
            LogicalPlan::Cte(_) => {}
            _ => {} // Handle other variants (Empty, Scan, PageRank, CartesianProduct, etc.)
        }
    }

    let mut aliases = HashSet::new();
    collect_recursive(plan, &mut aliases);
    aliases
}

/// Placeholder for get_anchor_alias_from_plan function
/// Will be moved from plan_builder.rs lines 157-178
pub fn get_anchor_alias_from_plan(_plan: &LogicalPlan) -> Option<String> {
    // TODO: Implement when moving from plan_builder.rs
    None
}

/// Placeholder for extract_vlp_alias_mappings function
/// Will be moved from plan_builder.rs lines 651-789
pub fn extract_vlp_alias_mappings(_ctes: &crate::render_plan::CteItems) -> HashMap<String, String> {
    // TODO: Implement when moving from plan_builder.rs
    HashMap::new()
}

/// Placeholder for rewrite_render_expr_for_vlp function
/// Will be moved from plan_builder.rs lines 790-901
pub fn rewrite_render_expr_for_vlp(
    _expr: &mut crate::render_plan::render_expr::RenderExpr,
    _mappings: &HashMap<String, String>,
) {
    // TODO: Implement when moving from plan_builder.rs
}

/// Check if a logical plan contains a multi-type variable-length path (VLP).
/// Multi-type VLPs require special join expansion logic when they have multiple relationship types.
///
/// This recursively traverses the plan to find GraphRel nodes with variable_length patterns
/// and determines if they should use join expansion based on relationship type count.
pub fn has_multi_type_vlp(
    plan: &LogicalPlan,
    schema: &GraphSchema,
) -> bool {
    match plan {
        LogicalPlan::GraphRel(graph_rel) => {
            // Check if it's a VLP pattern
            if graph_rel.variable_length.is_some() {
                let rel_types: Vec<String> = graph_rel.labels.clone().unwrap_or_default();
                // Use the same logic as CTE extraction
                crate::render_plan::cte_extraction::should_use_join_expansion_public(
                    graph_rel, &rel_types, schema,
                )
            } else {
                false
            }
        }
        LogicalPlan::Projection(proj) => has_multi_type_vlp(&proj.input, schema),
        LogicalPlan::Filter(filter) => has_multi_type_vlp(&filter.input, schema),
        LogicalPlan::GroupBy(gb) => has_multi_type_vlp(&gb.input, schema),
        LogicalPlan::OrderBy(order) => has_multi_type_vlp(&order.input, schema),
        LogicalPlan::Limit(limit) => has_multi_type_vlp(&limit.input, schema),
        LogicalPlan::Skip(skip) => has_multi_type_vlp(&skip.input, schema),
        LogicalPlan::GraphJoins(joins) => has_multi_type_vlp(&joins.input, schema),
        _ => false,
    }
}

/// Extract alias from a logical expression
pub fn extract_alias_from_expr(expr: &LogicalExpr) -> Option<String> {
    match expr {
        LogicalExpr::ColumnAlias(ca) => {
            log::info!("üîç extract_with_alias: ColumnAlias: {}", ca.0);
            Some(ca.0.clone())
        }
        LogicalExpr::TableAlias(ta) => {
            log::info!("üîç extract_with_alias: TableAlias: {}", ta.0);
            Some(ta.0.clone())
        }
        LogicalExpr::Column(col) => {
            // A bare column name - this is often the variable name in WITH
            // e.g., WITH friend -> Column("friend")
            // Skip "*" since it's not a real variable name
            if col.0 == "*" {
                log::info!("üîç extract_with_alias: Skipping Column('*')");
                None
            } else {
                log::info!("üîç extract_with_alias: Column: {}", col.0);
                Some(col.0.clone())
            }
        }
        LogicalExpr::PropertyAccessExp(pa) => {
            // For property access like `friend.name`, use the table alias
            log::info!(
                "üîç extract_with_alias: PropertyAccessExp: {}.{:?}",
                pa.table_alias.0,
                pa.column
            );
            Some(pa.table_alias.0.clone())
        }
        LogicalExpr::OperatorApplicationExp(op_app) => {
            // Handle operators like DISTINCT that wrap other expressions
            // Try to extract alias from the first operand
            log::info!("üîç extract_with_alias: OperatorApplicationExp with {:?}, checking operands", op_app.operator);
            for operand in &op_app.operands {
                if let Some(alias) = extract_alias_from_expr(operand) {
                    return Some(alias);
                }
            }
            None
        }
        other => {
            log::info!(
                "üîç extract_with_alias: Unhandled expression type in nested: {:?}",
                std::mem::discriminant(other)
            );
            None
        }
    }
}

pub fn collapse_passthrough_with(
    plan: &LogicalPlan,
    target_alias: &str,
    target_cte_name: &str, // Analyzer's CTE name (e.g., "with_lnm_cte_4")
) -> RenderPlanBuilderResult<LogicalPlan> {
    use crate::query_planner::logical_plan::*;
    use std::sync::Arc;

    /// Generate a key for a WithClause (same logic as find_all_with_clauses_grouped)
    fn get_with_key(wc: &WithClause) -> String {
        if !wc.exported_aliases.is_empty() {
            let mut aliases = wc.exported_aliases.clone();
            aliases.sort();
            return aliases.join("_");
        }
        "with_var".to_string()
    }

    match plan {
        LogicalPlan::WithClause(wc) => {
            let key = get_with_key(wc);
            let this_cte_name = wc
                .cte_references
                .get(target_alias)
                .map(|s| s.as_str())
                .unwrap_or("");
            log::warn!(
                "üîß collapse_passthrough_with: Checking WithClause key='{}' target='{}' this_cte='{}' target_cte='{}'",
                key, target_alias, this_cte_name, target_cte_name
            );
            if key == target_alias && this_cte_name == target_cte_name {
                // This is the exact passthrough WITH to collapse - return its input
                log::warn!(
                    "üîß collapse_passthrough_with: Found target WITH '{}' with CTE '{}', replacing with input type {:?}",
                    target_alias, target_cte_name, std::mem::discriminant(wc.input.as_ref())
                );
                Ok(wc.input.as_ref().clone())
            } else {
                // Not the target - recurse into input
                let new_input =
                    collapse_passthrough_with(&wc.input, target_alias, target_cte_name)?;
                Ok(LogicalPlan::WithClause(WithClause {
                    input: Arc::new(new_input),
                    items: wc.items.clone(),
                    order_by: wc.order_by.clone(),
                    skip: wc.skip,
                    limit: wc.limit,
                    where_clause: wc.where_clause.clone(),
                    distinct: wc.distinct,
                    exported_aliases: wc.exported_aliases.clone(),
                    cte_references: wc.cte_references.clone(),
                }))
            }
        }
        LogicalPlan::Projection(proj) => {
            let new_input = collapse_passthrough_with(&proj.input, target_alias, target_cte_name)?;
            Ok(LogicalPlan::Projection(Projection {
                input: Arc::new(new_input),
                items: proj.items.clone(),
                distinct: proj.distinct,
            }))
        }
        LogicalPlan::Filter(f) => {
            let new_input = collapse_passthrough_with(&f.input, target_alias, target_cte_name)?;
            Ok(LogicalPlan::Filter(Filter {
                input: Arc::new(new_input),
                predicate: f.predicate.clone(),
            }))
        }
        LogicalPlan::Limit(lim) => {
            let new_input = collapse_passthrough_with(&lim.input, target_alias, target_cte_name)?;
            Ok(LogicalPlan::Limit(Limit {
                input: Arc::new(new_input),
                count: lim.count,
            }))
        }
        LogicalPlan::GraphJoins(gj) => {
            let new_input = collapse_passthrough_with(&gj.input, target_alias, target_cte_name)?;
            Ok(LogicalPlan::GraphJoins(GraphJoins {
                input: Arc::new(new_input),
                joins: gj.joins.clone(),
                optional_aliases: gj.optional_aliases.clone(),
                anchor_table: gj.anchor_table.clone(),
                cte_references: gj.cte_references.clone(),
                correlation_predicates: gj.correlation_predicates.clone(),
            }))
        }
        LogicalPlan::Skip(skip) => {
            let new_input = collapse_passthrough_with(&skip.input, target_alias, target_cte_name)?;
            Ok(LogicalPlan::Skip(Skip {
                input: Arc::new(new_input),
                count: skip.count,
            }))
        }
        LogicalPlan::OrderBy(ob) => {
            let new_input = collapse_passthrough_with(&ob.input, target_alias, target_cte_name)?;
            Ok(LogicalPlan::OrderBy(OrderBy {
                input: Arc::new(new_input),
                items: ob.items.clone(),
            }))
        }
        LogicalPlan::GroupBy(gb) => {
            let new_input = collapse_passthrough_with(&gb.input, target_alias, target_cte_name)?;
            Ok(LogicalPlan::GroupBy(GroupBy {
                input: Arc::new(new_input),
                expressions: gb.expressions.clone(),
                having_clause: gb.having_clause.clone(),
                is_materialization_boundary: gb.is_materialization_boundary,
                exposed_alias: gb.exposed_alias.clone(),
            }))
        }
        // For other node types that don't contain WITH clauses, return unchanged
        other => Ok(other.clone()),
    }
}

pub fn extract_cte_references(plan: &LogicalPlan) -> std::collections::HashMap<String, String> {
    let mut refs = std::collections::HashMap::new();

    match plan {
        LogicalPlan::GraphJoins(gj) => {
            log::info!(
                "üîç extract_cte_references: Found GraphJoins with {} CTE refs: {:?}",
                gj.cte_references.len(),
                gj.cte_references
            );
            refs.extend(gj.cte_references.clone());
            refs.extend(extract_cte_references(&gj.input));
        }
        LogicalPlan::GraphRel(gr) => {
            refs.extend(extract_cte_references(&gr.left));
            refs.extend(extract_cte_references(&gr.center));
            refs.extend(extract_cte_references(&gr.right));
        }
        LogicalPlan::GraphNode(gn) => {
            refs.extend(extract_cte_references(&gn.input));
        }
        LogicalPlan::WithClause(wc) => {
            log::info!(
                "üîç extract_cte_references: Found WithClause with {} CTE refs: {:?}",
                wc.cte_references.len(),
                wc.cte_references
            );
            refs.extend(wc.cte_references.clone());
            refs.extend(extract_cte_references(&wc.input));
        }
        LogicalPlan::CartesianProduct(cp) => {
            refs.extend(extract_cte_references(&cp.left));
            refs.extend(extract_cte_references(&cp.right));
        }
        LogicalPlan::Union(u) => {
            for input in &u.inputs {
                refs.extend(extract_cte_references(input));
            }
        }
        _ => {}
    }

    log::info!(
        "üîç extract_cte_references: Returning {} refs total: {:?}",
        refs.len(),
        refs
    );
    refs
}

pub fn extract_correlation_predicates(
    plan: &LogicalPlan,
) -> Vec<LogicalExpr> {
    let mut predicates = vec![];

    match plan {
        LogicalPlan::GraphJoins(gj) => {
            log::info!("üîç extract_correlation_predicates: Found GraphJoins with {} correlation predicates",
                       gj.correlation_predicates.len());
            predicates.extend(gj.correlation_predicates.clone());
            predicates.extend(extract_correlation_predicates(&gj.input));
        }
        LogicalPlan::GraphRel(gr) => {
            predicates.extend(extract_correlation_predicates(&gr.left));
            predicates.extend(extract_correlation_predicates(&gr.center));
            predicates.extend(extract_correlation_predicates(&gr.right));
        }
        LogicalPlan::GraphNode(gn) => {
            predicates.extend(extract_correlation_predicates(&gn.input));
        }
        LogicalPlan::WithClause(wc) => {
            predicates.extend(extract_correlation_predicates(&wc.input));
        }
        LogicalPlan::CartesianProduct(cp) => {
            predicates.extend(extract_correlation_predicates(&cp.left));
            predicates.extend(extract_correlation_predicates(&cp.right));
        }
        LogicalPlan::Union(u) => {
            for input in &u.inputs {
                predicates.extend(extract_correlation_predicates(input));
            }
        }
        _ => {}
    }

    log::info!(
        "üîç extract_correlation_predicates: Returning {} predicates total",
        predicates.len()
    );
    predicates
}

pub fn convert_correlation_predicates_to_joins(
    predicates: &[LogicalExpr],
    cte_references: &std::collections::HashMap<String, String>,
) -> Vec<(String, String, String, String)> {
    use crate::query_planner::logical_expr::Operator;

    let mut conditions = vec![];

    for pred in predicates {
        if let LogicalExpr::OperatorApplicationExp(op_app) = pred {
            if matches!(op_app.operator, Operator::Equal) && op_app.operands.len() == 2 {
                let left = &op_app.operands[0];
                let right = &op_app.operands[1];

                // Check if we have a CTE reference on one side and a table reference on the other
                if let Some(cond) = extract_join_from_logical_equality(left, right, cte_references)
                {
                    log::info!(
                        "üîß Converted correlation predicate to join: CTE {}.{} = {}.{}",
                        cond.0,
                        cond.1,
                        cond.2,
                        cond.3
                    );
                    conditions.push(cond);
                } else if let Some(cond) =
                    extract_join_from_logical_equality(right, left, cte_references)
                {
                    conditions.push(cond);
                }
            }
        }
    }

    log::info!(
        "üîß convert_correlation_predicates_to_joins: Converted {} predicates to join conditions",
        conditions.len()
    );
    conditions
}

pub fn extract_cte_join_conditions(
    filters: &Option<RenderExpr>,
    cte_references: &std::collections::HashMap<String, String>,
) -> Vec<(String, String, String, String)> {
    let mut conditions = vec![];

    if let Some(filter_expr) = filters {
        extract_cte_conditions_recursive(filter_expr, cte_references, &mut conditions);
    }

    log::info!(
        "üîß extract_cte_join_conditions: Found {} CTE join conditions: {:?}",
        conditions.len(),
        conditions
    );
    conditions
}

pub fn extract_cte_conditions_recursive(
    expr: &RenderExpr,
    cte_references: &std::collections::HashMap<String, String>,
    conditions: &mut Vec<(String, String, String, String)>,
) {
    match expr {
        RenderExpr::OperatorApplicationExp(op_app) => {
            // Look for Equal operator
            if matches!(op_app.operator, Operator::Equal) && op_app.operands.len() == 2 {
                let left = &op_app.operands[0];
                let right = &op_app.operands[1];

                // Check if one side is a CTE column and the other is a table column
                if let Some(cond) = extract_join_from_equality(left, right, cte_references) {
                    log::info!(
                        "üîß Found CTE join condition: CTE {}. {} = {}.{}",
                        cond.0,
                        cond.1,
                        cond.2,
                        cond.3
                    );
                    conditions.push(cond);
                } else if let Some(cond) = extract_join_from_equality(right, left, cte_references) {
                    // Try reversed order
                    conditions.push(cond);
                }
            }

            // Check for AND/OR - recurse into operands
            if matches!(op_app.operator, Operator::And | Operator::Or) {
                for operand in &op_app.operands {
                    extract_cte_conditions_recursive(operand, cte_references, conditions);
                }
            }
        }
        _ => {}
    }
}

pub fn build_simple_relationship_render_plan(
    plan: &LogicalPlan,
    distinct_override: Option<bool>,
    schema: &GraphSchema,
) -> RenderPlanBuilderResult<RenderPlan> {
    println!(
        "DEBUG: build_simple_relationship_render_plan START - plan type: {:?}",
        std::mem::discriminant(plan)
    );

    // Extract distinct flag from the outermost Projection BEFORE unwrapping
    // This must be done first because unwrapping will replace self with core_plan
    // However, if distinct_override is provided, use that instead
    let distinct = distinct_override.unwrap_or_else(|| extract_distinct(plan));
    println!(
        "DEBUG: build_simple_relationship_render_plan - extracted distinct (early): {}",
        distinct
    );

    // Special case: Detect Projection over GroupBy
    // This can be wrapped in OrderBy/Limit/Skip nodes
    // CTE is needed when RETURN items require data not available from WITH output

    // Unwrap OrderBy, Limit, Skip to find the core Projection
    let (core_plan, order_by, limit_val, skip_val) = match plan {
        LogicalPlan::Limit(limit_node) => {
            crate::debug_println!("DEBUG: Unwrapping Limit node, count={}", limit_node.count);
            let limit_val = limit_node.count;
            match limit_node.input.as_ref() {
                LogicalPlan::OrderBy(order_node) => {
                    crate::debug_println!("DEBUG: Found OrderBy inside Limit");
                    (
                        order_node.input.as_ref(),
                        Some(&order_node.items),
                        Some(limit_val),
                        None,
                    )
                }
                LogicalPlan::Skip(skip_node) => {
                    crate::debug_println!("DEBUG: Found Skip inside Limit");
                    (
                        skip_node.input.as_ref(),
                        None,
                        Some(limit_val),
                        Some(skip_node.count),
                    )
                }
                other => {
                    println!(
                        "DEBUG: Limit contains other type: {:?}",
                        std::mem::discriminant(other)
                    );
                    (other, None, Some(limit_val), None)
                }
            }
        }
        LogicalPlan::OrderBy(order_node) => {
            crate::debug_println!("DEBUG: Unwrapping OrderBy node");
            (
                order_node.input.as_ref(),
                Some(&order_node.items),
                None,
                None,
            )
        }
        LogicalPlan::Skip(skip_node) => {
            crate::debug_println!("DEBUG: Unwrapping Skip node");
            (skip_node.input.as_ref(), None, None, Some(skip_node.count))
        }
        other => {
            println!(
                "DEBUG: No unwrapping needed, plan type: {:?}",
                std::mem::discriminant(other)
            );
            (other, None, None, None)
        }
    };

    println!(
        "DEBUG: After unwrapping - core_plan type: {:?}, has_order_by: {}, has_limit: {}, has_skip: {}",
        std::mem::discriminant(core_plan),
        order_by.is_some(),
        limit_val.is_some(),
        skip_val.is_some()
    );

    // Check for nested GroupBy pattern: GroupBy(GraphJoins(Projection(GroupBy(...))))
    // This happens with two-level aggregation: WITH has aggregation, RETURN has aggregation
    // Both need their own GROUP BY, requiring a subquery structure
    if let LogicalPlan::GroupBy(outer_group_by) = core_plan {
        // Check if there's an inner GroupBy (indicating two-level aggregation)
        fn find_inner_group_by(plan: &LogicalPlan) -> Option<&GroupBy> {
            match plan {
                LogicalPlan::GroupBy(gb) => Some(gb),
                LogicalPlan::GraphJoins(gj) => find_inner_group_by(&gj.input),
                LogicalPlan::Projection(p) => find_inner_group_by(&p.input),
                LogicalPlan::Filter(f) => find_inner_group_by(&f.input),
                _ => None,
            }
        }

        // Also find the Projection that contains the RETURN items (between outer GroupBy and inner GroupBy)
        fn find_return_projection(plan: &LogicalPlan) -> Option<&Projection> {
            match plan {
                LogicalPlan::Projection(p) => Some(p),
                LogicalPlan::GraphJoins(gj) => find_return_projection(&gj.input),
                LogicalPlan::Filter(f) => find_return_projection(&f.input),
                _ => None,
            }
        }

        if let Some(inner_group_by) = find_inner_group_by(&outer_group_by.input) {
            println!("DEBUG: Detected nested GroupBy pattern (two-level aggregation)");

            // Find the RETURN projection items
            let return_projection = find_return_projection(&outer_group_by.input);

            // Extract WITH aliases from the inner GroupBy's input Projection
            // Also collect table aliases that refer to nodes passed through WITH
            fn extract_inner_with_aliases(
                plan: &LogicalPlan,
            ) -> (
                std::collections::HashSet<String>,
                std::collections::HashSet<String>,
            ) {
                match plan {
                    LogicalPlan::Projection(proj) => {
                        let mut aliases = std::collections::HashSet::new();
                        let mut table_aliases = std::collections::HashSet::new();
                        for item in &proj.items {
                            if let Some(a) = item.col_alias.as_ref() {
                                aliases.insert(a.0.clone());
                            }
                            // Also track table aliases used in WITH (like "person" in "WITH person, count(...)")
                            match &item.expression {
                                crate::query_planner::logical_expr::LogicalExpr::TableAlias(ta) => {
                                    table_aliases.insert(ta.0.clone());
                                }
                                crate::query_planner::logical_expr::LogicalExpr::PropertyAccessExp(pa) => {
                                    table_aliases.insert(pa.table_alias.0.clone());
                                }
                                _ => {}
                            }
                        }
                        (aliases, table_aliases)
                    }
                    LogicalPlan::GraphJoins(gj) => extract_inner_with_aliases(&gj.input),
                    LogicalPlan::Filter(f) => extract_inner_with_aliases(&f.input),
                    _ => (
                        std::collections::HashSet::new(),
                        std::collections::HashSet::new(),
                    ),
                }
            }
            let (with_aliases, with_table_aliases) =
                extract_inner_with_aliases(&inner_group_by.input);
            println!("DEBUG: Found WITH aliases: {:?}", with_aliases);
            println!("DEBUG: Found WITH table aliases: {:?}", with_table_aliases);

            // Build the inner query (WITH clause result) as a CTE
            // Structure: SELECT <with_items> FROM <tables> GROUP BY <non-aggregates>
            // üîß FIX: Use the schema parameter instead of creating an empty schema

            // Build render plan for the inner GroupBy's input (the WITH clause query)
            let inner_render_plan = inner_group_by.input.to_render_plan(schema)?;

            // Extract GROUP BY expressions from SELECT items (non-aggregates)
            // For node variables (WITH a where a is a table alias), only GROUP BY ID columns
            // For other expressions, include them in GROUP BY as normal
            log::info!(
                "üîß Extracting GROUP BY from {} SELECT items, with_table_aliases: {:?}",
                inner_render_plan.select.items.len(),
                with_table_aliases
            );
            let inner_group_by_exprs: Vec<RenderExpr> = inner_render_plan
                .select
                .items
                .iter()
                .filter(|item| !matches!(&item.expression, RenderExpr::AggregateFnCall(_)))
                .filter_map(|item| {
                    // Check if this is a property of a node variable (table alias)
                    if let RenderExpr::PropertyAccessExp(pa) = &item.expression {
                        let table_alias = &pa.table_alias.0;
                        log::info!(
                            "üîß   Checking item: table_alias={}, col_alias={:?}",
                            table_alias,
                            item.col_alias
                        );
                        // If this is a WITH table alias (node variable), only include ID columns
                        if with_table_aliases.contains(table_alias) {
                            log::info!("üîß     Is WITH table alias");
                            // Only include if it's an ID column
                            // ID columns have aliases like "a_user_id", "a_id", etc.
                            if let Some(col_alias) = &item.col_alias {
                                let alias = &col_alias.0;
                                // Pattern: <table>_*_id or <table>_id
                                if alias.ends_with("_id") || alias.ends_with("_user_id") {
                                    log::info!("üîß       ID column, including: {}", alias);
                                    return Some(item.expression.clone());
                                } else {
                                    log::info!("üîß       Non-ID column, skipping: {}", alias);
                                }
                            }
                            // Not an ID column, skip it for GROUP BY
                            return None;
                        }
                    }
                    // For non-node variables, include in GROUP BY
                    log::info!("üîß   Including non-node expression");
                    Some(item.expression.clone())
                })
                .collect();
            log::info!(
                "üîß GROUP BY will have {} expressions",
                inner_group_by_exprs.len()
            );

            // Create CTE for the inner (WITH) query
            // Generate CTE name from all exported aliases (both table aliases and aggregates)
            // Format: with_<alias1>_<alias2>_..._cte
            // This matches the format used in analyzer (graph_join_inference.rs)
            let mut all_with_aliases: Vec<String> = with_table_aliases
                .iter()
                .chain(with_aliases.iter())
                .cloned()
                .collect();
            all_with_aliases.sort(); // Ensure consistent ordering
                                         // Use base name (without counter) - counter added later if needed
            let cte_name = crate::utils::cte_naming::generate_cte_base_name(&all_with_aliases);
            let inner_cte = Cte::new(
                cte_name.clone(),
                super::CteContent::Structured(RenderPlan {
                    ctes: CteItems(vec![]),
                    select: inner_render_plan.select.clone(),
                    from: inner_render_plan.from.clone(),
                    joins: inner_render_plan.joins.clone(),
                    array_join: ArrayJoinItem(Vec::new()),
                    filters: inner_render_plan.filters.clone(),
                    group_by: GroupByExpressions(inner_group_by_exprs),
                    having_clause: inner_group_by
                        .having_clause
                        .as_ref()
                        .map(|h| h.clone().try_into())
                        .transpose()?,
                    order_by: OrderByItems(vec![]),
                    skip: SkipItem(None),
                    limit: LimitItem(None),
                    union: UnionItems(None),
                }),
                false, // is_recursive
            );

            // Build outer SELECT items from RETURN projection, rewriting WITH alias references
            let outer_select_items: Vec<SelectItem> = if let Some(proj) = return_projection {
                proj.items
                    .iter()
                    .map(|item| {
                        let mut render_expr: RenderExpr = item.expression.clone().try_into()?;

                        // Rewrite WITH alias references (like postCount) to CTE references
                        let (rewritten, _) =
                            super::plan_builder_helpers::rewrite_with_aliases_to_cte(
                                render_expr.clone(),
                                &with_aliases,
                                &cte_name,
                            );
                        render_expr = rewritten;

                        // Also rewrite table alias references (like person.id) to CTE references
                        render_expr = super::plan_builder_helpers::rewrite_table_aliases_to_cte(
                            render_expr,
                            &with_table_aliases,
                            &cte_name,
                        );

                        Ok(SelectItem {
                            expression: render_expr,
                            col_alias: item
                                .col_alias
                                .as_ref()
                                .map(|a| super::render_expr::ColumnAlias(a.0.clone())),
                        })
                    })
                    .collect::<Result<Vec<_>, RenderBuildError>>()?
            } else {
                vec![]
            };

            // Build outer GROUP BY from outer_group_by.expressions, rewriting aliases
            let mut outer_group_by_exprs: Vec<RenderExpr> = Vec::new();
            for expr in &outer_group_by.expressions {
                let render_expr: RenderExpr = expr.clone().try_into()?;
                let (rewritten, _) = super::plan_builder_helpers::rewrite_with_aliases_to_cte(
                    render_expr,
                    &with_aliases,
                    &cte_name,
                );
                outer_group_by_exprs.push(rewritten);
            }

            // Build ORDER BY items, rewriting WITH alias references
            let order_by_items = if let Some(order_items) = order_by {
                order_items
                    .iter()
                    .map(|item| {
                        let expr: RenderExpr = item.expression.clone().try_into()?;
                        let (rewritten, _) =
                            super::plan_builder_helpers::rewrite_with_aliases_to_cte(
                                expr,
                                &with_aliases,
                                &cte_name,
                            );
                        // Also rewrite table alias references
                        let final_expr = super::plan_builder_helpers::rewrite_table_aliases_to_cte(
                            rewritten,
                            &with_table_aliases,
                            &cte_name,
                        );
                        Ok(super::OrderByItem {
                            expression: final_expr,
                            order: match item.order {
                                crate::query_planner::logical_plan::OrderByOrder::Asc => {
                                    super::OrderByOrder::Asc
                                }
                                crate::query_planner::logical_plan::OrderByOrder::Desc => {
                                    super::OrderByOrder::Desc
                                }
                            },
                        })
                    })
                    .collect::<Result<Vec<_>, RenderBuildError>>()?
            } else {
                vec![]
            };

            // Return the nested query structure
            return Ok(RenderPlan {
                ctes: CteItems(vec![inner_cte]),
                select: SelectItems {
                    items: outer_select_items,
                    distinct: false,
                },
                from: FromTableItem(Some(ViewTableRef {
                    source: Arc::new(LogicalPlan::Empty),
                    name: cte_name.clone(),
                    alias: Some(cte_name.clone()),
                    use_final: false,
                })),
                joins: JoinItems(vec![]),
                array_join: ArrayJoinItem(Vec::new()),
                filters: FilterItems(None),
                group_by: GroupByExpressions(outer_group_by_exprs),
                having_clause: outer_group_by
                    .having_clause
                    .as_ref()
                    .map(|h| h.clone().try_into())
                    .transpose()?,
                order_by: OrderByItems(order_by_items),
                skip: SkipItem(skip_val),
                limit: LimitItem(limit_val),
                union: UnionItems(None),
            });
        }
    }

    // Now check if core_plan is Projection(Return) over GroupBy
    if let LogicalPlan::Projection(outer_proj) = core_plan {
        if let LogicalPlan::GroupBy(group_by) = outer_proj.input.as_ref() {
            // Check for variable-length paths in GroupBy's input
            // VLP with aggregation requires CTE-based processing
            if group_by.input.contains_variable_length_path() {
                crate::debug_println!(
                    "DEBUG: GroupBy contains variable-length path - need CTE"
                );
                return Err(RenderBuildError::InvalidRenderPlan(
                    "Variable-length paths with aggregation require CTE-based processing"
                        .to_string(),
                ));
            }

            // Check if RETURN items need data beyond what WITH provides
            // CTE is needed if RETURN contains:
            // 1. Node references (TableAlias that refers to a node, not a WITH alias)
            // 2. Wildcards (like `a.*`)
            // 3. References to WITH projection aliases that aren't in the inner projection

            // Collect all WITH projection aliases AND table aliases from the inner Projection
            // Handle GraphJoins wrapper by looking inside it
            let (with_aliases, with_table_aliases): (
                std::collections::HashSet<String>,
                std::collections::HashSet<String>,
            ) = {
                // Helper to extract WITH aliases and table aliases from Projection(With)
                fn extract_with_aliases_and_tables(
                    plan: &LogicalPlan,
                ) -> (
                    std::collections::HashSet<String>,
                    std::collections::HashSet<String>,
                ) {
                    match plan {
                        LogicalPlan::Projection(proj) => {
                            let mut aliases = std::collections::HashSet::new();
                            let mut table_aliases = std::collections::HashSet::new();

                            for item in &proj.items {
                                // Collect explicit aliases (like `count(post) AS messageCount`)
                                if let Some(alias) = &item.col_alias {
                                    aliases.insert(alias.0.clone());
                                }
                                // Collect table aliases from pass-through expressions (like `WITH person, ...`)
                                match &item.expression {
                                            crate::query_planner::logical_expr::LogicalExpr::TableAlias(ta) => {
                                                table_aliases.insert(ta.0.clone());
                                            }
                                            crate::query_planner::logical_expr::LogicalExpr::PropertyAccessExp(pa) => {
                                                table_aliases.insert(pa.table_alias.0.clone());
                                            }
                                            _ => {}
                                        }
                            }
                            (aliases, table_aliases)
                        }
                        LogicalPlan::GraphJoins(graph_joins) => {
                            // Look inside GraphJoins for the Projection
                            extract_with_aliases_and_tables(&graph_joins.input)
                        }
                        _ => (
                            std::collections::HashSet::new(),
                            std::collections::HashSet::new(),
                        ),
                    }
                }
                extract_with_aliases_and_tables(group_by.input.as_ref())
            };

            crate::debug_println!("DEBUG: WITH aliases found: {:?}", with_aliases);
            crate::debug_println!("DEBUG: WITH table aliases found: {:?}", with_table_aliases);

            // CTE is always needed when there are WITH aliases (aggregates)
            // because the outer query needs to reference them from the CTE
            let needs_cte = !with_aliases.is_empty()
                || outer_proj.items.iter().any(|item| match &item.expression {
                    crate::query_planner::logical_expr::LogicalExpr::PropertyAccessExp(
                        prop,
                    ) if prop.column.raw() == "*" => true,
                    _ => false,
                });

            if needs_cte {
                println!(
                            "DEBUG: Detected Projection(Return) over GroupBy where RETURN needs data beyond WITH output - using CTE pattern"

                        );

                // Build the GROUP BY subquery as a CTE
                // Step 1: Build inner query (GROUP BY + HAVING) as a RenderPlan
                use crate::graph_catalog::graph_schema::GraphSchema;
                use std::collections::HashMap;
                let empty_schema = GraphSchema::build(
                    1,
                    "default".to_string(),
                    HashMap::new(),
                    HashMap::new(),
                );
                let inner_render_plan = group_by.input.to_render_plan(&empty_schema)?;

                // Step 2: Extract GROUP BY expressions and HAVING clause
                // For wildcards, we need to either:
                // 1. GROUP BY all properties (to match SELECT), or
                // 2. Only SELECT the ID column (to match GROUP BY)
                // We'll do option 1: expand wildcards to all properties in GROUP BY
                let mut group_by_exprs: Vec<RenderExpr> = Vec::new();
                for expr in group_by.expressions.iter() {
                    match expr {
                        crate::query_planner::logical_expr::LogicalExpr::PropertyAccessExp(
                            prop,
                        ) if prop.column.raw() == "*" => {
                            // Expand a.* to all properties: a.age, a.name, a.user_id
                            if let Ok((properties, actual_table_alias)) =
                                plan.get_properties_with_table_alias(&prop.table_alias.0)
                            {
                                let table_alias_to_use = actual_table_alias
                                    .as_ref()
                                    .map(|s| {
                                        crate::query_planner::logical_expr::TableAlias(
                                            s.clone(),
                                        )
                                    })
                                    .unwrap_or_else(|| prop.table_alias.clone());

                                for (_prop_name, col_name) in properties {
                                    let expr = crate::query_planner::logical_expr::LogicalExpr::PropertyAccessExp(
                                            crate::query_planner::logical_expr::PropertyAccess {
                                                table_alias: table_alias_to_use.clone(),
                                                column: PropertyValue::Column(col_name),
                                            }
                                        );
                                    group_by_exprs.push(expr.try_into()?);
                                }
                            } else {
                                // Fallback to just ID column
                                let id_column =
                                    plan.find_id_column_for_alias(&prop.table_alias.0)?;
                                let expr = crate::query_planner::logical_expr::LogicalExpr::PropertyAccessExp(
                                        crate::query_planner::logical_expr::PropertyAccess {
                                            table_alias: prop.table_alias.clone(),
                                            column: PropertyValue::Column(id_column),
                                        }
                                    );
                                group_by_exprs.push(expr.try_into()?);
                            }
                        }
                        crate::query_planner::logical_expr::LogicalExpr::TableAlias(alias) => {
                            // Expand table alias to all properties
                            if let Ok((properties, actual_table_alias)) =
                                plan.get_properties_with_table_alias(&alias.0)
                            {
                                let table_alias_to_use = actual_table_alias
                                    .as_ref()
                                    .map(|s| {
                                        crate::query_planner::logical_expr::TableAlias(
                                            s.clone(),
                                        )
                                    })
                                    .unwrap_or_else(|| alias.clone());

                                for (_prop_name, col_name) in properties {
                                    let expr = crate::query_planner::logical_expr::LogicalExpr::PropertyAccessExp(
                                            crate::query_planner::logical_expr::PropertyAccess {
                                                table_alias: table_alias_to_use.clone(),
                                                column: PropertyValue::Column(col_name),
                                            }
                                        );
                                    group_by_exprs.push(expr.try_into()?);
                                }
                            } else {
                                // Fallback to just ID column
                                let id_column = plan.find_id_column_for_alias(&alias.0)?;
                                let expr = crate::query_planner::logical_expr::LogicalExpr::PropertyAccessExp(
                                        crate::query_planner::logical_expr::PropertyAccess {
                                            table_alias: alias.clone(),
                                            column: PropertyValue::Column(id_column),
                                        }
                                    );
                                group_by_exprs.push(expr.try_into()?);
                            }
                        }
                        _ => {
                            group_by_exprs.push(expr.clone().try_into()?);
                        }
                    }
                }

                let having_expr: Option<RenderExpr> =
                    if let Some(having) = &group_by.having_clause {
                        Some(having.clone().try_into()?)
                    } else {
                        None
                    };

                // Step 2.5: Build SELECT list for CTE (only grouping keys + aggregates, not wildcards)
                // Extract from the inner Projection (child of GroupBy)
                let cte_select_items = if let LogicalPlan::Projection(inner_proj) =
                    group_by.input.as_ref()
                {
                    inner_proj
                        .items
                        .iter()
                        .map(|item| {
                            // For each projection item, check if it's an aggregate or grouping key
                            let render_expr: RenderExpr = item.expression.clone().try_into()?;

                            // Normalize aggregate arguments: COUNT(b) -> COUNT(b.user_id)
                            let normalized_expr = plan.normalize_aggregate_args(render_expr)?;

                            // Replace wildcard expressions with the specific ID column
                            let (fixed_expr, auto_alias) = match &normalized_expr {
                                RenderExpr::PropertyAccessExp(prop)
                                    if prop.column.raw() == "*" =>
                                {
                                    // Find the ID column for this alias
                                    let id_col =
                                        plan.find_id_column_for_alias(&prop.table_alias.0)?;
                                    let expr = RenderExpr::PropertyAccessExp(
                                        super::render_expr::PropertyAccess {
                                            table_alias: prop.table_alias.clone(),
                                            column: PropertyValue::Column(id_col.clone()),
                                        },
                                    );
                                    // Add alias so it can be referenced as grouped_data.user_id
                                    (expr, Some(super::render_expr::ColumnAlias(id_col)))
                                }
                                _ => (normalized_expr, None),
                            };

                            // Use existing alias if present, otherwise use auto-generated alias for grouping keys
                            let col_alias = item
                                .col_alias
                                .as_ref()
                                .map(|a| super::render_expr::ColumnAlias(a.0.clone()))
                                .or(auto_alias);

                            Ok(super::SelectItem {
                                expression: fixed_expr,
                                col_alias,
                            })
                        })
                        .collect::<Result<Vec<super::SelectItem>, RenderBuildError>>()?
                } else {
                    // Fallback to original select items
                    inner_render_plan.select.items.clone()
                };

                // Step 3: Create CTE with GROUP BY + HAVING
                let cte_name = "grouped_data".to_string();
                let cte = Cte::new(
                    cte_name.clone(),
                    super::CteContent::Structured(RenderPlan {
                        ctes: CteItems(vec![]),
                        select: SelectItems {
                            items: cte_select_items,
                            distinct: false,
                        },
                        from: inner_render_plan.from.clone(),
                        joins: inner_render_plan.joins.clone(),
                        array_join: ArrayJoinItem(Vec::new()),
                        filters: inner_render_plan.filters.clone(),
                        group_by: GroupByExpressions(group_by_exprs.clone()), // Clone to preserve for later use
                        having_clause: having_expr,
                        order_by: OrderByItems(vec![]),
                        skip: SkipItem(None),
                        limit: LimitItem(None),
                        union: UnionItems(None),
                    }),
                    false, // is_recursive
                );

                // Step 4: Build outer query that joins to CTE
                // Extract the grouping key to use for join (use the FIXED expression with ID column)
                let grouping_key_render = if let Some(first_expr) = group_by_exprs.first() {
                    first_expr.clone()
                } else {
                    return Err(RenderBuildError::InvalidRenderPlan(
                        "GroupBy has no grouping expressions after fixing wildcards"
                            .to_string(),
                    ));
                };

                // Extract table alias and column name from the fixed grouping key
                let (table_alias, key_column) = match &grouping_key_render {
                    RenderExpr::PropertyAccessExp(prop_access) => (
                        prop_access.table_alias.0.clone(),
                        prop_access.column.clone(),
                    ),
                    _ => {
                        return Err(RenderBuildError::InvalidRenderPlan(
                            "Grouping expression is not a property access after fixing"
                                .to_string(),
                        ));
                    }
                };

                // Build outer SELECT items from outer_proj
                // Need to rewrite references to WITH aliases AND table aliases to pull from the CTE
                // Also track if ALL RETURN items reference WITH aliases or table aliases
                let mut all_items_from_with = true;
                let outer_select_items = outer_proj
                        .items
                        .iter()
                        .map(|item| {
                            let expr: RenderExpr = item.expression.clone().try_into()?;

                            // Step 1: Rewrite TableAlias/ColumnAlias references that are WITH aliases
                            // This handles cases like AVG(follows) -> AVG(grouped_data.follows)
                            let (rewritten_expr, from_with_alias) =
                                super::plan_builder_helpers::rewrite_with_aliases_to_cte(
                                    expr,
                                    &with_aliases,
                                    &cte_name
                                );

                            // Step 2: Also rewrite table alias references (like person.id) to CTE references
                            // This handles cases like `WITH person, ...` -> person.id becomes grouped_data."person.id"
                            let final_expr = super::plan_builder_helpers::rewrite_table_aliases_to_cte(
                                rewritten_expr,
                                &with_table_aliases,
                                &cte_name,
                            );

                            // Check if the original expression referenced a table alias from WITH
                            let from_table_alias = matches!(&item.expression,
                                crate::query_planner::logical_expr::LogicalExpr::PropertyAccessExp(pa)
                                    if with_table_aliases.contains(&pa.table_alias.0));

                            if !from_with_alias && !from_table_alias {
                                all_items_from_with = false;
                            }

                            Ok(super::SelectItem {
                                expression: final_expr,
                                col_alias: item.col_alias.as_ref().map(|alias| {
                                    super::render_expr::ColumnAlias(alias.0.clone())
                                }),
                            })
                        })
                        .collect::<Result<Vec<super::SelectItem>, RenderBuildError>>()?;

                println!(
                    "DEBUG: all_items_from_with={}, with_aliases={:?}",
                    all_items_from_with, with_aliases
                );

                // If ALL RETURN items come from WITH aliases, we can SELECT directly from the CTE
                // without needing to join back to the original table
                if all_items_from_with {
                    println!(
                        "DEBUG: All RETURN items come from WITH - selecting directly from CTE"
                    );

                    // Build ORDER BY items for the direct-from-CTE case
                    let order_by_items = if let Some(order_items) = order_by {
                        order_items.iter()
                                .map(|item| {
                                    let expr: RenderExpr = item.expression.clone().try_into()?;
                                    // Recursively rewrite WITH aliases to CTE references
                                    let (rewritten_expr, _) =
                                        super::plan_builder_helpers::rewrite_with_aliases_to_cte(
                                            expr,
                                            &with_aliases,
                                            &cte_name
                                        );
                                    // Also rewrite table alias references
                                    let final_expr = super::plan_builder_helpers::rewrite_table_aliases_to_cte(
                                        rewritten_expr,
                                        &with_table_aliases,
                                        &cte_name,
                                    );
                                    Ok(super::OrderByItem {
                                        expression: final_expr,
                                        order: match item.order {
                                            crate::query_planner::logical_plan::OrderByOrder::Asc => super::OrderByOrder::Asc,
                                            crate::query_planner::logical_plan::OrderByOrder::Desc => super::OrderByOrder::Desc,
                                        },
                                    })
                                })
                                .collect::<Result<Vec<_>, RenderBuildError>>()?
                    } else {
                        vec![]
                    };

                    // Return CTE-based plan that SELECT directly from CTE (no join)
                    return Ok(RenderPlan {
                        ctes: CteItems(vec![cte]),
                        select: SelectItems {
                            items: outer_select_items,
                            distinct: false,
                        },
                        from: FromTableItem(Some(super::ViewTableRef {
                            source: std::sync::Arc::new(LogicalPlan::Empty),
                            name: cte_name.clone(),
                            alias: Some(cte_name.clone()),
                            use_final: false,
                        })),
                        joins: JoinItems(vec![]), // No joins needed
                        array_join: ArrayJoinItem(Vec::new()),
                        filters: FilterItems(None),
                        group_by: GroupByExpressions(vec![]),
                        having_clause: None,
                        order_by: OrderByItems(order_by_items),
                        skip: SkipItem(skip_val),
                        limit: LimitItem(limit_val),
                        union: UnionItems(None),
                    });
                }

                // Extract FROM table for the outer query
                // IMPORTANT: The outer query needs to use the table for the grouping key alias,
                // not the inner query's FROM table. For example, if we're grouping by g.group_id
                // where g is a Group, the outer query should FROM sec_groups AS g, not sec_users.
                let outer_from = {
                    // Find the table name for the grouping key's alias
                    if let Some(table_name) = find_table_name_for_alias(plan, &table_alias) {
                        FromTableItem(Some(super::ViewTableRef {
                            source: std::sync::Arc::new(LogicalPlan::Empty),
                            name: table_name,
                            alias: Some(table_alias.clone()),
                            use_final: false,
                        }))
                    } else {
                        // Fallback to inner query's FROM if we can't find the table
                        inner_render_plan.from.clone()
                    }
                };

                // Create JOIN condition: a.user_id = grouped_data.user_id
                let cte_key_expr =
                    RenderExpr::PropertyAccessExp(super::render_expr::PropertyAccess {
                        table_alias: super::render_expr::TableAlias(cte_name.clone()),
                        column: key_column.clone(),
                    });

                let join_condition = super::render_expr::OperatorApplication {
                    operator: super::render_expr::Operator::Equal,
                    operands: vec![grouping_key_render, cte_key_expr],
                };

                // Create a join to the CTE
                let cte_join = super::Join {
                    table_name: cte_name.clone(),
                    table_alias: cte_name.clone(),
                    joining_on: vec![join_condition],
                    join_type: super::JoinType::Inner,
                    pre_filter: None,
                    from_id_column: None,
                    to_id_column: None,
                };

                println!(
                    "DEBUG: Created GroupBy CTE pattern with table_alias={}, key_column={}",
                    table_alias,
                    key_column.raw()
                );

                // Build ORDER BY items, rewriting WITH alias references to CTE references
                let order_by_items = if let Some(order_items) = order_by {
                    order_items
                        .iter()
                        .map(|item| {
                            let expr: RenderExpr = item.expression.clone().try_into()?;
                            // Recursively rewrite WITH aliases to CTE references
                            let (rewritten_expr, _) =
                                super::plan_builder_helpers::rewrite_with_aliases_to_cte(
                                    expr,
                                    &with_aliases,
                                    &cte_name,
                                );
                            // Also rewrite table alias references
                            let final_expr =
                                super::plan_builder_helpers::rewrite_table_aliases_to_cte(
                                    rewritten_expr,
                                    &with_table_aliases,
                                    &cte_name,
                                );

                            Ok(super::OrderByItem {
                                expression: final_expr,
                                order: match item.order {
                                    crate::query_planner::logical_plan::OrderByOrder::Asc => {
                                        super::OrderByOrder::Asc
                                    }
                                    crate::query_planner::logical_plan::OrderByOrder::Desc => {
                                        super::OrderByOrder::Desc
                                    }
                                },
                            })
                        })
                        .collect::<Result<Vec<_>, RenderBuildError>>()?
                } else {
                    vec![]
                };

                // Return the CTE-based plan with proper JOIN, ORDER BY, and LIMIT
                return Ok(RenderPlan {
                    ctes: CteItems(vec![cte]),
                    select: SelectItems {
                        items: outer_select_items,
                        distinct: false,
                    },
                    from: outer_from,
                    joins: JoinItems(vec![cte_join]),
                    array_join: ArrayJoinItem(Vec::new()),
                    filters: FilterItems(None),
                    group_by: GroupByExpressions(vec![]),
                    having_clause: None,
                    order_by: OrderByItems(order_by_items),
                    skip: SkipItem(skip_val),
                    limit: LimitItem(limit_val),
                    union: UnionItems(None),
                });
            }
        } else {
            println!(
                "DEBUG: Projection(Return) input is NOT GroupBy, discriminant: {:?}",
                std::mem::discriminant(outer_proj.input.as_ref())
            );
        }
    } else {
        println!(
            "DEBUG: core_plan is NOT Projection, discriminant: {:?}",
            std::mem::discriminant(core_plan)
        );
    }

    let mut final_select_items = plan.extract_select_items()?;
    log::debug!(
        "build_simple_relationship_render_plan - final_select_items BEFORE alias remap: {:?}",
        final_select_items
    );

    // For denormalized patterns, remap node aliases to edge aliases
    // This ensures SELECT src."id.orig_h" becomes SELECT a06963149f83."id.orig_h" when src is denormalized on edge a06963149f83
    for item in &mut final_select_items {
        apply_property_mapping_to_expr(&mut item.expression, plan);
    }
    log::debug!(
        "build_simple_relationship_render_plan - final_select_items AFTER alias remap: {:?}",
        final_select_items
    );

    // Validate that we have proper select items
    if final_select_items.is_empty() {
        return Err(RenderBuildError::InvalidRenderPlan(
            "No select items found for relationship query. This usually indicates missing schema information or incomplete query planning.".to_string()
        ));
    }

    // Validate that select items are not just literals (which would indicate failed expression conversion)
    for item in &final_select_items {
        if let RenderExpr::Literal(_) = &item.expression {
            return Err(RenderBuildError::InvalidRenderPlan(
                "Select item is a literal value, indicating failed expression conversion. Check schema mappings and query structure.".to_string()
            ));
        }
    }

    // üîß CRITICAL FIX FOR MULTI-HOP PATTERNS:
    // Recursively search for FROM marker in GraphJoins, handling all plan structure variations.
    // FROM markers are joins with empty joining_on, created by infer_graph_join for anchor nodes.
    // They can be buried under Filter (WHERE), Limit, Skip, OrderBy, or other wrapper nodes.
    //
    // Examples that need FROM markers:
    // - MATCH (u)-[:FOLLOWS]->(f1)-[:FOLLOWS]->(f2) WHERE u.user_id = 1
    // - MATCH (a)-[]->(b)-[]->(c) WHERE a.id = 1 LIMIT 10
    // - MATCH (x)-[]->(y)-[]->(z) ORDER BY x.name WHERE x.active = true
    //
    // Generic recursive search finds FROM marker at any depth, not just specific patterns.
    fn find_from_marker_recursive(plan: &LogicalPlan) -> Option<FromTable> {
        log::info!(
            "üîç find_from_marker_recursive: examining plan type: {:?}",
            std::mem::discriminant(plan)
        );
        match plan {
            // Recurse through wrapper nodes (WHERE, LIMIT, ORDER BY, etc.)
            LogicalPlan::Projection(proj) => {
                log::info!("  ‚Ü≥ Recursing through Projection");
                find_from_marker_recursive(&proj.input)
            }
            LogicalPlan::Filter(filter) => {
                log::info!("  ‚Ü≥ Recursing through Filter");
                find_from_marker_recursive(&filter.input)
            }
            LogicalPlan::Limit(limit) => {
                log::info!("  ‚Ü≥ Recursing through Limit");
                find_from_marker_recursive(&limit.input)
            }
            LogicalPlan::Skip(skip) => {
                log::info!("  ‚Ü≥ Recursing through Skip");
                find_from_marker_recursive(&skip.input)
            }
            LogicalPlan::OrderBy(order) => {
                log::info!("  ‚Ü≥ Recursing through OrderBy");
                find_from_marker_recursive(&order.input)
            }
            LogicalPlan::GroupBy(group) => {
                log::info!("  ‚Ü≥ Recursing through GroupBy");
                find_from_marker_recursive(&group.input)
            }

            // Found GraphJoins - search for FROM marker
            LogicalPlan::GraphJoins(graph_joins) => {
                log::info!(
                    "  ‚Ü≥ Found GraphJoins with {} joins",
                    graph_joins.joins.len()
                );
                for (i, j) in graph_joins.joins.iter().enumerate() {
                    log::info!(
                        "      Join[{}]: table='{}' alias='{}' joining_on.len={}",
                        i,
                        j.table_name,
                        j.table_alias,
                        j.joining_on.len()
                    );
                }
                graph_joins
                    .joins
                    .iter()
                    .find(|j| j.joining_on.is_empty())
                    .map(|from_marker| {
                        log::info!(
                            "üè† Found FROM marker: '{}' AS '{}' (recursive search)",
                            from_marker.table_name,
                            from_marker.table_alias
                        );
                        FromTable::new(Some(ViewTableRef {
                            source: std::sync::Arc::new(LogicalPlan::Empty),
                            name: from_marker.table_name.clone(),
                            alias: Some(from_marker.table_alias.clone()),
                            use_final: false,
                        }))
                    })
            }

            // Stop recursion at other node types
            _ => {
                log::info!(
                    "  ‚Ü≥ Stopping recursion at node type: {:?}",
                    std::mem::discriminant(plan)
                );
                None
            }
        }
    }

    let from_marker_from = find_from_marker_recursive(core_plan);
    let from_marker_present = from_marker_from.is_some();
    let mut final_from = from_marker_from.or_else(|| extract_from(core_plan).ok().flatten());

    log::debug!(
        "üîç build_simple_relationship_render_plan - extracted final_from from core_plan type: {:?}, is_some: {}, from_marker_used: {}",
        std::mem::discriminant(core_plan),
        final_from.is_some(),
        from_marker_present
    );

    // üöÄ CONSOLIDATED VLP FROM CLAUSE AND ALIAS REWRITING
    // For fixed-length VLP patterns, we need to:
    // 1. Set the correct FROM table based on schema type
    // 2. For Denormalized schemas, build alias mappings and rewrite expressions
    //
    // CRITICAL: Must search recursively because self could be Limit(GraphJoins(...))
    fn find_vlp_graph_rel_recursive(
        plan: &LogicalPlan,
    ) -> Option<&crate::query_planner::logical_plan::GraphRel> {
        match plan {
            LogicalPlan::GraphRel(gr) if gr.variable_length.is_some() => Some(gr),
            LogicalPlan::GraphJoins(gj) => find_vlp_graph_rel_recursive(&gj.input),
            LogicalPlan::Projection(p) => find_vlp_graph_rel_recursive(&p.input),
            LogicalPlan::Filter(f) => find_vlp_graph_rel_recursive(&f.input),
            LogicalPlan::Limit(l) => find_vlp_graph_rel_recursive(&l.input),
            LogicalPlan::Skip(s) => find_vlp_graph_rel_recursive(&s.input),
            LogicalPlan::OrderBy(o) => find_vlp_graph_rel_recursive(&o.input),
            _ => None,
        }
    }

    // Store VLP alias mapping for denormalized schemas
    // Format: (simple_alias_map, rel_column_to_hop_map, rel_alias)
    let mut vlp_alias_map: Option<(
        std::collections::HashMap<String, String>, // simple: a -> r1, b -> rN
        std::collections::HashMap<String, String>, // column -> hop: Origin -> r1, DestCityName -> rN
        String,                                    // rel_alias (f)
    )> = None;

    if let Some(graph_rel) = find_vlp_graph_rel_recursive(plan) {
        if let Some(vlp_ctx) = build_vlp_context(graph_rel) {
            if vlp_ctx.is_fixed_length {
                let exact_hops = vlp_ctx.exact_hops.unwrap_or(1);

                // Get FROM info from the consolidated context
                let (from_table, from_alias, _) =
                    expand_fixed_length_joins_with_context(&vlp_ctx);

                println!(
                    "DEBUG: Fixed-length VLP (*{}) {:?} - setting FROM {} AS {}",
                    exact_hops, vlp_ctx.schema_type, from_table, from_alias
                );

                final_from = Some(FromTable::new(Some(ViewTableRef {
                    source: std::sync::Arc::new(LogicalPlan::Empty),
                    name: from_table,
                    alias: Some(from_alias),
                    use_final: false,
                })));

                // For denormalized schemas, build alias mapping:
                // - start_alias (a) -> r1
                // - end_alias (b) -> rN
                // - rel_alias (f) -> DEPENDS on column (from_node_properties -> r1, to_node_properties -> rN)
                if vlp_ctx.schema_type == VlpSchemaType::Denormalized {
                    // Simple alias map for node aliases
                    let mut simple_map = std::collections::HashMap::new();
                    simple_map.insert(vlp_ctx.start_alias.clone(), "r1".to_string());
                    simple_map.insert(vlp_ctx.end_alias.clone(), format!("r{}", exact_hops));

                    // Build column -> hop alias mapping for relationship alias
                    // from_node_properties -> r1
                    // to_node_properties -> rN
                    let mut rel_column_map: std::collections::HashMap<String, String> =
                        std::collections::HashMap::new();

                    // Try to get node properties from the schema
                    // The node label should be the same for both (Airport in ontime_denormalized)
                    if let Some(schema_lock) = crate::server::GLOBAL_SCHEMAS.get() {
                        if let Ok(schemas) = schema_lock.try_read() {
                            // Try different schema names
                            for schema_name in ["default", ""] {
                                if let Some(schema) = schemas.get(schema_name) {
                                    // Get the node label from the graph_rel
                                    if let Some(_node_label) =
                                        graph_rel.labels.as_ref().and_then(|l| l.first())
                                    {
                                        // Actually, we need the node label, not rel label
                                        // Get it from the left/right GraphNodes
                                        fn get_node_label(
                                            plan: &LogicalPlan,
                                        ) -> Option<String>
                                        {
                                            match plan {
                                                LogicalPlan::GraphNode(n) => n.label.clone(),
                                                _ => None,
                                            }
                                        }

                                        if let Some(label) = get_node_label(&graph_rel.left) {
                                            if let Some(node_schema) =
                                                schema.get_nodes_schemas().get(&label)
                                            {
                                                // Add from_properties columns -> r1
                                                if let Some(ref from_props) =
                                                    node_schema.from_properties
                                                {
                                                    for (_, col_value) in from_props {
                                                        let col_name = col_value.clone();
                                                        rel_column_map
                                                            .insert(col_name, "r1".to_string());
                                                    }
                                                }
                                                // Add to_properties columns -> rN
                                                if let Some(ref to_props) =
                                                    node_schema.to_properties
                                                {
                                                    for (_, col_value) in to_props {
                                                        let col_name = col_value.clone();
                                                        rel_column_map.insert(
                                                            col_name,
                                                            format!("r{}", exact_hops),
                                                        );
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    // Fallback: use VlpContext properties if available
                    if let Some(ref from_props) = vlp_ctx.from_node_properties {
                        for (_, col_value) in from_props {
                            let col_name = match col_value {
                                crate::graph_catalog::expression_parser::PropertyValue::Column(c) => c.clone(),
                                crate::graph_catalog::expression_parser::PropertyValue::Expression(e) => e.clone(),
                            };
                            rel_column_map.insert(col_name, "r1".to_string());
                        }
                    }

                    if let Some(ref to_props) = vlp_ctx.to_node_properties {
                        for (_, col_value) in to_props {
                            let col_name = match col_value {
                                crate::graph_catalog::expression_parser::PropertyValue::Column(c) => c.clone(),
                                crate::graph_catalog::expression_parser::PropertyValue::Expression(e) => e.clone(),
                            };
                            rel_column_map.insert(col_name, format!("r{}", exact_hops));
                        }
                    }

                    // Also add from_id and to_id columns
                    rel_column_map.insert(vlp_ctx.rel_from_col.clone(), "r1".to_string());
                    rel_column_map
                        .insert(vlp_ctx.rel_to_col.clone(), format!("r{}", exact_hops));

                    println!(
                        "DEBUG: Denormalized VLP alias mapping - simple: {:?}, rel_column: {:?}",
                        simple_map, rel_column_map
                    );

                    vlp_alias_map =
                        Some((simple_map, rel_column_map, vlp_ctx.rel_alias.clone()));
                }
            }
        }
    }

    // Check if we have UNWIND clauses - if so and no FROM, resolve the source table
    let array_joins = extract_array_join(plan)?;
    if final_from.is_none() && !array_joins.is_empty() {
        log::debug!("UNWIND clause detected without FROM table - checking for CTE references");

        // Try to find CTE references from GraphJoins in the plan
        fn extract_cte_references_from_plan(
            plan: &LogicalPlan,
        ) -> std::collections::HashMap<String, String> {
            match plan {
                LogicalPlan::GraphJoins(gj) => gj.cte_references.clone(),
                LogicalPlan::Projection(p) => extract_cte_references_from_plan(&p.input),
                LogicalPlan::Filter(f) => extract_cte_references_from_plan(&f.input),
                LogicalPlan::Unwind(u) => extract_cte_references_from_plan(&u.input),
                LogicalPlan::Limit(l) => extract_cte_references_from_plan(&l.input),
                LogicalPlan::Skip(s) => extract_cte_references_from_plan(&s.input),
                LogicalPlan::OrderBy(o) => extract_cte_references_from_plan(&o.input),
                LogicalPlan::GroupBy(g) => extract_cte_references_from_plan(&g.input),
                _ => std::collections::HashMap::new(),
            }
        }

        let cte_refs = extract_cte_references_from_plan(plan);

        if let Some(cte_name) = cte_refs.values().next() {
            // Use the CTE as FROM table
            log::info!("‚úÖ UNWIND: Found CTE reference '{}', using as FROM table instead of system.one", cte_name);
            final_from = Some(FromTable::new(Some(ViewTableRef {
                source: std::sync::Arc::new(
                    crate::query_planner::logical_plan::LogicalPlan::Empty,
                ),
                name: cte_name.clone(),
                alias: Some(cte_name.clone()),
                use_final: false,
            })));
        } else {
            // Check if the first UNWIND expression is standalone (no schema references)
            // Only use system.one if unwinding a literal or standalone expression
            let first_array_join = &array_joins[0];
            let is_standalone = super::plan_builder_helpers::is_standalone_expression(
                &first_array_join.expression,
            );

            if is_standalone {
                // Standalone UNWIND with literals: UNWIND [1,2,3] AS n
                log::debug!(
                    "‚úÖ UNWIND: Expression is standalone (no schema refs), using system.one"
                );
                final_from = Some(FromTable::new(Some(ViewTableRef {
                    source: std::sync::Arc::new(
                        crate::query_planner::logical_plan::LogicalPlan::Empty,
                    ),
                    name: "system.one".to_string(),
                    alias: Some("_dummy".to_string()),
                    use_final: false,
                })));
            } else {
                // UNWIND references schema elements but no CTE found - this is an error!
                log::error!("‚ùå UNWIND: Expression references schema elements but no CTE or FROM table found!");
                log::error!("   Expression: {:?}", first_array_join.expression);
                return Err(RenderBuildError::InvalidRenderPlan(
                    format!("UNWIND expression references schema elements (columns/properties) but no FROM table or CTE was found. \
                                This indicates a query planning bug. Expression: {:?}", first_array_join.expression)
                ));
            }
        }
    }

    // Validate that we have a FROM clause
    if final_from.is_none() {
        return Err(RenderBuildError::InvalidRenderPlan(
            "No FROM table found for relationship query. Schema inference may have failed."
                .to_string(),
        ));
    }

    // Helper function to rewrite table aliases in RenderExpr for denormalized VLP
    // Takes: (simple_alias_map, column_to_hop_map, rel_alias)
    fn rewrite_aliases_in_expr_vlp(
        expr: RenderExpr,
        simple_map: &std::collections::HashMap<String, String>,
        column_map: &std::collections::HashMap<String, String>,
        rel_alias: &str,
    ) -> RenderExpr {
        use super::render_expr::{
            AggregateFnCall, OperatorApplication, PropertyAccess, ScalarFnCall, TableAlias,
        };
        use crate::graph_catalog::expression_parser::PropertyValue;

        match expr {
            RenderExpr::PropertyAccessExp(prop) => {
                // Get the column name from the PropertyValue
                let col_name = match &prop.column {
                    PropertyValue::Column(c) => c.clone(),
                    PropertyValue::Expression(e) => e.clone(),
                };

                let new_alias = if prop.table_alias.0 == rel_alias {
                    // This is a relationship alias - look up by column name
                    column_map
                        .get(&col_name)
                        .cloned()
                        .unwrap_or_else(|| "r1".to_string())
                } else {
                    // Check simple map for node aliases
                    simple_map
                        .get(&prop.table_alias.0)
                        .cloned()
                        .unwrap_or_else(|| prop.table_alias.0.clone())
                };

                RenderExpr::PropertyAccessExp(PropertyAccess {
                    table_alias: TableAlias(new_alias),
                    column: prop.column,
                })
            }
            RenderExpr::TableAlias(alias) => {
                if let Some(new_alias) = simple_map.get(&alias.0) {
                    RenderExpr::TableAlias(TableAlias(new_alias.clone()))
                } else {
                    RenderExpr::TableAlias(alias)
                }
            }
            RenderExpr::OperatorApplicationExp(op) => {
                RenderExpr::OperatorApplicationExp(OperatorApplication {
                    operator: op.operator,
                    operands: op
                        .operands
                        .into_iter()
                        .map(|o| {
                            rewrite_aliases_in_expr_vlp(o, simple_map, column_map, rel_alias)
                        })
                        .collect(),
                })
            }
            RenderExpr::ScalarFnCall(func) => RenderExpr::ScalarFnCall(ScalarFnCall {
                name: func.name,
                args: func
                    .args
                    .into_iter()
                    .map(|a| rewrite_aliases_in_expr_vlp(a, simple_map, column_map, rel_alias))
                    .collect(),
            }),
            RenderExpr::AggregateFnCall(agg) => RenderExpr::AggregateFnCall(AggregateFnCall {
                name: agg.name,
                args: agg
                    .args
                    .into_iter()
                    .map(|a| rewrite_aliases_in_expr_vlp(a, simple_map, column_map, rel_alias))
                    .collect(),
            }),
            RenderExpr::List(items) => RenderExpr::List(
                items
                    .into_iter()
                    .map(|i| rewrite_aliases_in_expr_vlp(i, simple_map, column_map, rel_alias))
                    .collect(),
            ),
            RenderExpr::Case(case) => RenderExpr::Case(super::render_expr::RenderCase {
                expr: case.expr.map(|e| {
                    Box::new(rewrite_aliases_in_expr_vlp(
                        *e, simple_map, column_map, rel_alias,
                    ))
                }),
                when_then: case
                    .when_then
                    .into_iter()
                    .map(|(w, t)| {
                        (
                            rewrite_aliases_in_expr_vlp(w, simple_map, column_map, rel_alias),
                            rewrite_aliases_in_expr_vlp(t, simple_map, column_map, rel_alias),
                        )
                    })
                    .collect(),
                else_expr: case.else_expr.map(|e| {
                    Box::new(rewrite_aliases_in_expr_vlp(
                        *e, simple_map, column_map, rel_alias,
                    ))
                }),
            }),
            // Pass through expressions that don't contain table aliases
            other => other,
        }
    }

    // Apply alias rewriting for denormalized VLP if we have a mapping
    if let Some((ref simple_map, ref column_map, ref rel_alias)) = vlp_alias_map {
        crate::debug_println!("DEBUG: Rewriting select items with VLP alias map: simple={:?}, column={:?}, rel={}",
                     simple_map, column_map, rel_alias);
        final_select_items = final_select_items
            .into_iter()
            .map(|item| SelectItem {
                expression: rewrite_aliases_in_expr_vlp(
                    item.expression,
                    simple_map,
                    column_map,
                    rel_alias,
                ),
                col_alias: item.col_alias,
            })
            .collect();
    }

    let mut final_filters = plan.extract_filters()?;
    println!(
        "DEBUG: build_simple_relationship_render_plan - final_filters: {:?}",
        final_filters
    );

    // Apply alias rewriting to filters for denormalized VLP
    if let Some((ref simple_map, ref column_map, ref rel_alias)) = vlp_alias_map {
        if let Some(filter) = final_filters {
            crate::debug_println!(
                "DEBUG: Rewriting filters with VLP alias map: simple={:?}, column={:?}, rel={}",
                simple_map,
                column_map,
                rel_alias
            );
            final_filters = Some(rewrite_aliases_in_expr_vlp(
                filter, simple_map, column_map, rel_alias,
            ));
        }
    }

    // Apply property mapping to filters to translate denormalized node aliases to their SQL table aliases.
    // For denormalized nodes (like `d:Domain` stored on edge table), the Cypher alias `d`
    // doesn't exist in SQL. We must rewrite `d.answers` to `edge_alias.answers`.
    // Uses the same apply_property_mapping_to_expr that works for SELECT items.
    if let Some(ref mut filter) = final_filters {
        apply_property_mapping_to_expr(filter, plan);
    }

    // Validate that filters don't contain obviously invalid expressions
    if let Some(ref filter_expr) = final_filters {
        if is_invalid_filter_expression(filter_expr) {
            return Err(RenderBuildError::InvalidRenderPlan(
                "Filter expression appears invalid (e.g., '1 = 0'). This usually indicates schema mapping issues.".to_string()
            ));
        }
    }

    let mut extracted_joins = plan.extract_joins(schema)?;
    println!(
        "DEBUG: build_simple_relationship_render_plan - extracted {} joins",
        extracted_joins.len()
    );

    // Filter out JOINs that duplicate the FROM table
    // If we're starting FROM node 'a', we shouldn't also have it in the JOINs list
    // BUT: If the filtered-out JOIN has a pre_filter (e.g., polymorphic edge filter),
    // we need to preserve it as a WHERE filter
    let from_alias = final_from
        .as_ref()
        .and_then(|ft| ft.table.as_ref())
        .and_then(|vt| vt.alias.clone());
    let mut anchor_pre_filter: Option<RenderExpr> = None;
    let filtered_joins: Vec<Join> = if let Some(ref anchor_alias) = from_alias {
        extracted_joins.into_iter()
            .filter(|join| {
                if &join.table_alias == anchor_alias {
                    crate::debug_println!("DEBUG: Filtering out JOIN for '{}' because it's already in FROM clause", anchor_alias);
                    // Preserve the pre_filter from the anchor JOIN
                    if join.pre_filter.is_some() {
                        anchor_pre_filter = join.pre_filter.clone();
                        crate::debug_println!("DEBUG: Preserving pre_filter from anchor JOIN: {:?}", anchor_pre_filter);
                    }
                    false
                } else {
                    true
                }
            })
            .collect()
    } else {
        extracted_joins
    };

    // Add anchor pre_filter to final_filters if present
    let final_filters = if let Some(filter) = anchor_pre_filter {
        crate::debug_println!("DEBUG: Adding anchor pre_filter to final_filters");
        match final_filters {
            Some(existing) => {
                // Combine existing filter with anchor pre_filter using AND
                Some(RenderExpr::OperatorApplicationExp(OperatorApplication {
                    operator: Operator::And,
                    operands: vec![existing, filter],
                }))
            }
            None => Some(filter),
        }
    } else {
        final_filters
    };

    println!(
        "DEBUG: build_simple_relationship_render_plan - filtered_joins: {:?}",
        filtered_joins
    );

    // Sort JOINs by dependency order to ensure referenced tables are defined before use
    // CRITICAL FIX: This was missing in CTE generation path, causing multi-hop WITH clauses
    // to generate JOINs in wrong order (e.g., JOIN t1 ON t1.MessageId = message.id before message is defined)
    let sorted_joins = sort_joins_by_dependency(filtered_joins, final_from.as_ref());
    println!(
        "DEBUG: build_simple_relationship_render_plan - sorted_joins: {:?}",
        sorted_joins
    );

    // distinct was already extracted at the beginning of this function
    println!(
        "DEBUG: build_simple_relationship_render_plan - using pre-extracted distinct: {}",
        distinct
    );

    //  üîß WITH CLAUSE CTE EXTRACTION
    // Extract CTEs from WITH clauses in the logical plan
    // This is needed for WITH...MATCH patterns where first MATCH is in CTE
    println!(
        "DEBUG CTE EXTRACTION SHORT: About to extract CTEs from plan type {:?}",
        std::mem::discriminant(plan)
    );
    let mut context = analyze_property_requirements(plan, schema);
    let extracted_ctes = match plan.extract_ctes_with_context("_", &mut context, schema) {
        Ok(ctes) => {
            println!(
                "DEBUG CTE EXTRACTION SHORT: Successfully extracted {} CTEs",
                ctes.len()
            );
            for (i, cte) in ctes.iter().enumerate() {
                println!("DEBUG CTE EXTRACTION SHORT: CTE {}: {}", i, cte.cte_name);
            }
            if !ctes.is_empty() {
                log::info!(
                    "üîß Extracted {} CTEs in simple relationship render",
                    ctes.len()
                );
            }
            ctes
        }
        Err(e) => {
            println!("DEBUG CTE EXTRACTION SHORT: Failed with error: {:?}", e);
            log::debug!("CTE extraction returned error (may be expected): {:?}", e);
            vec![]
        }
    };

    // üîß CTE JOIN GENERATION
    // If we extracted CTEs, check if they need to be joined to the main query
    // This handles WITH...MATCH patterns where WITH exports variables used in subsequent MATCH
    let mut cte_joins = vec![];
    if !extracted_ctes.is_empty() {
        // Extract CTE references to see which aliases map to which CTEs
        let cte_references = extract_cte_references(plan);
        log::info!(
            "üîß CTE JOIN: Found {} CTE references: {:?}",
            cte_references.len(),
            cte_references
        );
        log::info!("üîß CTE JOIN: final_filters = {:?}", final_filters);

        // Extract correlation predicates from logical plan (from CartesianJoinExtraction optimizer)
        let correlation_predicates = extract_correlation_predicates(plan);
        log::info!(
            "üîß CTE JOIN: Found {} correlation predicates from optimizer",
            correlation_predicates.len()
        );

        // Convert correlation predicates to join conditions
        let mut join_conditions =
            convert_correlation_predicates_to_joins(&correlation_predicates, &cte_references);

        // Also extract join conditions from WHERE clause filters as fallback
        // This finds equality comparisons like: WHERE src2.ip = source_ip
        let filter_conditions = extract_cte_join_conditions(&final_filters, &cte_references);
        join_conditions.extend(filter_conditions);

        // Build map of CTE name ‚Üí join conditions
        let mut cte_join_map: std::collections::HashMap<String, Vec<(String, String, String)>> =
            std::collections::HashMap::new();

        for (cte_name, cte_column, main_table_alias, main_column) in join_conditions {
            cte_join_map.entry(cte_name).or_insert_with(Vec::new).push((
                cte_column,
                main_table_alias,
                main_column,
            ));
        }

        // Only use heuristic inference if no join conditions found at all
        if cte_join_map.is_empty() && !extracted_ctes.is_empty() {
            log::warn!("‚ö†Ô∏è CTE JOIN: No join conditions from optimizer or filters - falling back to heuristic (should not happen in production)");

            // Collect CTE column names from the CTE's SELECT items
            for cte in &extracted_ctes {
                if let CteContent::Structured(ref cte_plan) = cte.content {
                    let cte_columns: Vec<String> = cte_plan
                        .select
                        .items
                        .iter()
                        .filter_map(|item| item.col_alias.clone().map(|a| a.0))
                        .collect();

                    log::info!(
                        "üîß CTE JOIN: CTE '{}' exports columns: {:?}",
                        cte.cte_name,
                        cte_columns
                    );
                    log::info!(
                        "üîß CTE JOIN: Main SELECT items: {:?}",
                        final_select_items
                            .iter()
                            .map(|item| format!("{:?}: {:?}", item.col_alias, item.expression))
                            .collect::<Vec<_>>()
                    );

                    // Check which CTE columns are referenced in main SELECT items
                    // CTE columns can appear as either ColumnAlias or TableAlias in SELECT
                    let mut used_cte_cols = vec![];
                    for select_item in &final_select_items {
                        match &select_item.expression {
                            RenderExpr::ColumnAlias(col) if cte_columns.contains(&col.0) => {
                                used_cte_cols.push(col.0.clone());
                                log::info!("üîß CTE JOIN: SELECT references CTE column (ColumnAlias): {}", col.0);
                            }
                            RenderExpr::TableAlias(tbl_alias)
                                if cte_columns.contains(&tbl_alias.0) =>
                            {
                                used_cte_cols.push(tbl_alias.0.clone());
                                log::info!("üîß CTE JOIN: SELECT references CTE column (TableAlias): {}", tbl_alias.0);
                            }
                            _ => {}
                        }
                    }

                    if !used_cte_cols.is_empty() {
                        log::info!(
                            "üîß CTE JOIN: Found {} CTE columns used in SELECT: {:?}",
                            used_cte_cols.len(),
                            used_cte_cols
                        );

                        // Try to infer join column from CTE's internal query
                        // Look at the CTE's FROM table and its first ID-like column
                        if let Some(ref cte_from_table) = cte_plan.from.0 {
                            // Get the main query's FROM table
                            if let Some(ref main_from) = final_from {
                                if let Some(ref main_table) = main_from.table {
                                    let main_alias = main_table
                                        .alias
                                        .clone()
                                        .unwrap_or_else(|| main_table.name.clone());

                                    // Infer: Both queries reference IP nodes, likely joining on IP column
                                    // Use the first used CTE column as the join column
                                    if let Some(cte_col) = used_cte_cols.first() {
                                        // Heuristic: If column name contains "ip" or "id", use it for join
                                        // Otherwise, assume it correlates with a matching column in main table
                                        let main_col = if cte_col.contains("ip") {
                                            // Try to get node schema and extract ID column
                                            let _table_name = cte_from_table
                                                .name
                                                .split('.')
                                                .last()
                                                .unwrap_or("unknown");

                                            // For Zeek IP nodes, the ID column is the IP address column itself
                                            // In this schema, dns_log uses orig_h, conn_log also uses orig_h
                                            "orig_h".to_string()
                                        } else {
                                            cte_col.clone()
                                        };

                                        log::info!("üîß CTE JOIN: Inferred join condition: {}.{} = {}.{}",
                                                       main_alias, main_col, cte.cte_name, cte_col);

                                        cte_join_map
                                            .entry(cte.cte_name.clone())
                                            .or_insert_with(Vec::new)
                                            .push((
                                                cte_col.clone(),
                                                main_alias.clone(),
                                                main_col,
                                            ));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // For each CTE, generate a JOIN with the extracted or inferred conditions
        for cte in &extracted_ctes {
            let cte_alias = cte.cte_name.clone();

            // Get join conditions for this CTE
            let join_condition = if let Some(conditions) = cte_join_map.get(&cte.cte_name) {
                // Generate ON clause from extracted conditions
                let mut join_ops = vec![];
                for (cte_col, main_alias, main_column) in conditions {
                    // CRITICAL FIX: Check if main_alias is from a CTE
                    // If so, we need to use the CTE's table alias and qualified column name
                    let (resolved_table_alias, resolved_column) =
                        if let Some(ref_cte_name) = cte_references.get(main_alias) {
                            // main_alias (e.g., "b") is from a CTE - resolve to CTE format
                            // Calculate CTE alias: "with_a_b_cte_1" -> "a_b"
                            // Strategy: strip "with_" prefix, then strip "_cte" or "_cte_N" suffix
                            let after_prefix: &str =
                                ref_cte_name.strip_prefix("with_").unwrap_or(ref_cte_name);
                            let ref_cte_alias: &str = after_prefix
                                .strip_suffix("_cte")
                                .or_else(|| after_prefix.strip_suffix("_cte_1"))
                                .or_else(|| after_prefix.strip_suffix("_cte_2"))
                                .or_else(|| after_prefix.strip_suffix("_cte_3"))
                                .unwrap_or(after_prefix);

                            // Column name in CTE: alias_column (e.g., "b_user_id")
                            let cte_column = format!("{}_{}", main_alias, main_column);

                            log::info!(
                                "üîß CTE JOIN: Resolved '{}' -> CTE '{}' (alias '{}'), column '{}'",
                                main_alias,
                                ref_cte_name,
                                ref_cte_alias,
                                cte_column
                            );

                            (ref_cte_alias.to_string(), cte_column)
                        } else {
                            // Not from CTE, use as-is
                            (main_alias.clone(), main_column.clone())
                        };

                    join_ops.push(OperatorApplication {
                        operator: Operator::Equal,
                        operands: vec![
                            RenderExpr::PropertyAccessExp(PropertyAccess {
                                table_alias: TableAlias(resolved_table_alias),
                                column: PropertyValue::Column(resolved_column),
                            }),
                            RenderExpr::PropertyAccessExp(PropertyAccess {
                                table_alias: TableAlias(cte_alias.clone()),
                                column: PropertyValue::Column(cte_col.clone()),
                            }),
                        ],
                    });
                }

                log::info!(
                    "üîß CTE JOIN: Generated {} join conditions for CTE '{}'",
                    join_ops.len(),
                    cte.cte_name
                );
                join_ops
            } else {
                log::warn!("‚ö†Ô∏è CTE JOIN: No join conditions found for CTE '{}' - CTE may be unreferenced",
                               cte.cte_name);
                vec![]
            };

            if !join_condition.is_empty() {
                cte_joins.push(Join {
                    table_name: cte.cte_name.clone(),
                    table_alias: cte_alias,
                    joining_on: join_condition,
                    join_type: JoinType::Inner,
                    pre_filter: None,
                    from_id_column: None,
                    to_id_column: None,
                });
            }
        }
    }

    Ok(RenderPlan {
        ctes: CteItems(extracted_ctes),
        select: SelectItems {
            items: final_select_items,
            distinct,
        },
        from: FromTableItem(from_table_to_view_ref(final_from)),
        joins: JoinItems({
            let mut all_joins = sorted_joins; // CRITICAL FIX: Use sorted_joins instead of filtered_joins
            all_joins.extend(cte_joins);
            all_joins
        }),
        array_join: ArrayJoinItem(extract_array_join(plan)?),
        filters: FilterItems(final_filters),
        group_by: GroupByExpressions(plan.extract_group_by()?),
        having_clause: plan.extract_having()?,
        order_by: OrderByItems(plan.extract_order_by()?),
        skip: SkipItem(plan.extract_skip()),
        limit: LimitItem(plan.extract_limit()),
        union: UnionItems(None),
    })
}

pub fn collect_aliases_from_render_expr(exprs: &[RenderExpr], aliases: &mut Vec<String>) {
    for expr in exprs {
        match expr {
            RenderExpr::PropertyAccessExp(prop) => {
                if !aliases.contains(&prop.table_alias.0) {
                    aliases.push(prop.table_alias.0.clone());
                }
            }
            RenderExpr::TableAlias(alias) => {
                if !aliases.contains(&alias.0) {
                    aliases.push(alias.0.clone());
                }
            }
            RenderExpr::OperatorApplicationExp(op) => {
                collect_aliases_from_render_expr(&op.operands, aliases);
            }
            RenderExpr::ScalarFnCall(func) => {
                collect_aliases_from_render_expr(&func.args, aliases);
            }
            RenderExpr::AggregateFnCall(agg) => {
                collect_aliases_from_render_expr(&agg.args, aliases);
            }
            _ => {}
        }
    }
}

/// Collect aliases from GraphRel and GraphNode structures in a logical plan
/// Used to find all aliases referenced in graph patterns
pub fn collect_from_graph_rel(plan: &LogicalPlan, aliases: &mut std::collections::HashSet<String>) {
    match plan {
        LogicalPlan::GraphRel(gr) => {
            aliases.insert(gr.alias.clone()); // relationship alias
            aliases.insert(gr.left_connection.clone()); // left node alias
            aliases.insert(gr.right_connection.clone()); // right node alias
            collect_from_graph_rel(&gr.left, aliases);
            collect_from_graph_rel(&gr.right, aliases);
        }
        LogicalPlan::GraphNode(gn) => {
            aliases.insert(gn.alias.clone());
            collect_from_graph_rel(&gn.input, aliases);
        }
        LogicalPlan::Projection(p) => collect_from_graph_rel(&p.input, aliases),
        LogicalPlan::Filter(f) => collect_from_graph_rel(&f.input, aliases),
        _ => {}
    }
}

/// Collect aliases from the inner scope of a GroupBy plan by finding GraphRel structures
/// within nested GroupBy/GraphJoins/Projection/Filter nodes
pub fn collect_inner_scope_aliases(group_by_plan: &LogicalPlan) -> std::collections::HashSet<String> {
    let mut aliases = std::collections::HashSet::new();

    // First unwrap GroupBy and GraphJoins to find the actual GraphRel structure
    fn find_graph_rel_in_plan(plan: &LogicalPlan, aliases: &mut std::collections::HashSet<String>) {
        match plan {
            LogicalPlan::GroupBy(gb) => find_graph_rel_in_plan(&gb.input, aliases),
            LogicalPlan::GraphJoins(gj) => find_graph_rel_in_plan(&gj.input, aliases),
            LogicalPlan::Projection(p) => {
                // This is likely the WITH projection - look at its input GraphRel
                collect_from_graph_rel(&p.input, aliases);
            }
            LogicalPlan::Filter(f) => find_graph_rel_in_plan(&f.input, aliases),
            LogicalPlan::GraphRel(_gr) => {
                collect_from_graph_rel(plan, aliases);
            }
            _ => {}
        }
    }

    find_graph_rel_in_plan(group_by_plan, &mut aliases);
    aliases
}

/// Check if a RenderExpr references any alias in the given set
pub fn cond_references_alias(cond: &RenderExpr, aliases: &std::collections::HashSet<String>) -> bool {
    match cond {
        RenderExpr::PropertyAccessExp(pa) => aliases.contains(&pa.table_alias.0),
        RenderExpr::OperatorApplicationExp(op) => op
            .operands
            .iter()
            .any(|o| cond_references_alias(o, aliases)),
        _ => false,
    }
}

/// Extract ArrayJoin structures from LogicalPlan nodes recursively
/// This function traverses the logical plan tree to find all UNWIND operations
/// and converts them into ArrayJoin structures for ClickHouse ARRAY JOIN clauses
pub fn extract_array_join(plan: &LogicalPlan) -> Result<Vec<ArrayJoin>, RenderBuildError> {
    let mut array_joins = Vec::new();

    match plan {
        LogicalPlan::Unwind(u) => {
            // Convert LogicalExpr to RenderExpr for this UNWIND
            let render_expr = RenderExpr::try_from(u.expression.clone())?;
            array_joins.push(ArrayJoin {
                expression: render_expr,
                alias: u.alias.clone(),
            });
            // Recursively collect UNWIND nodes from input
            let mut inner_joins = extract_array_join(&u.input)?;
            array_joins.append(&mut inner_joins);
            Ok(array_joins)
        }
        // Recursively check children for more UNWIND nodes
        LogicalPlan::Projection(p) => extract_array_join(&p.input),
        LogicalPlan::Filter(f) => extract_array_join(&f.input),
        LogicalPlan::GroupBy(g) => extract_array_join(&g.input),
        LogicalPlan::OrderBy(o) => extract_array_join(&o.input),
        LogicalPlan::Limit(l) => extract_array_join(&l.input),
        LogicalPlan::Skip(s) => extract_array_join(&s.input),
        LogicalPlan::GraphJoins(gj) => extract_array_join(&gj.input),
        LogicalPlan::GraphNode(gn) => extract_array_join(&gn.input),
        LogicalPlan::GraphRel(gr) => {
            // Check all branches for UNWIND nodes
            let mut joins = extract_array_join(&gr.center)?;
            joins.append(&mut extract_array_join(&gr.left)?);
            joins.append(&mut extract_array_join(&gr.right)?);
            Ok(joins)
        }
        _ => Ok(Vec::new()),
    }
}

/// Extract join conditions from equality expressions between CTE columns and table columns
/// This function analyzes RenderExpr equality patterns to identify JOIN conditions
/// between CTE references and table columns, returning the join specification as a tuple
pub fn extract_join_from_equality(
    left: &RenderExpr,
    right: &RenderExpr,
    cte_references: &std::collections::HashMap<String, String>,
) -> Option<(String, String, String, String)> {
    use crate::render_plan::render_expr::*;

    // Pattern 1: left is CTE column, right is table column
    // Example: source_ip = conn.orig_h
    if let RenderExpr::ColumnAlias(col_alias) = left {
        // Check if this column alias references a CTE
        if let Some(cte_name) = cte_references.get(&col_alias.0) {
            // Right side should be a property access (table.column)
            if let RenderExpr::PropertyAccessExp(prop) = right {
                return Some((
                    cte_name.clone(),
                    col_alias.0.clone(),
                    prop.table_alias.0.clone(),
                    match &prop.column {
                        PropertyValue::Column(col) => col.clone(),
                        _ => return None,
                    },
                ));
            }
        }
    }

    // Pattern 2: left is table column, right is CTE column
    // Example: conn.orig_h = source_ip
    if let RenderExpr::PropertyAccessExp(prop) = left {
        if let RenderExpr::ColumnAlias(col_alias) = right {
            if let Some(cte_name) = cte_references.get(&col_alias.0) {
                return Some((
                    cte_name.clone(),
                    col_alias.0.clone(),
                    prop.table_alias.0.clone(),
                    match &prop.column {
                        PropertyValue::Column(col) => col.clone(),
                        _ => return None,
                    },
                ));
            }
        }
    }

    None
}

/// Try to extract a CTE join condition from a logical equality comparison
/// Returns: Some((cte_name, cte_column, main_table_alias, main_column)) if found
pub fn extract_join_from_logical_equality(
    left: &crate::query_planner::logical_expr::LogicalExpr,
    right: &crate::query_planner::logical_expr::LogicalExpr,
    cte_references: &std::collections::HashMap<String, String>,
) -> Option<(String, String, String, String)> {
    use crate::query_planner::logical_expr::LogicalExpr;

    // Pattern 1: Left is table.column (PropertyAccess), Right is CTE variable
    // Example: src2.ip = source_ip
    if let LogicalExpr::PropertyAccessExp(prop) = left {
        if let LogicalExpr::ColumnAlias(var_name) = right {
            // Check if variable references a CTE column
            if let Some(cte_name) = cte_references.get(&var_name.0) {
                return Some((
                    cte_name.clone(),
                    var_name.0.clone(),
                    prop.table_alias.0.clone(),
                    prop.column.raw().to_string(),
                ));
            }
        }
    }

    // Pattern 2: Left is CTE variable, Right is table.column
    // Example: source_ip = src2.ip
    if let LogicalExpr::ColumnAlias(var_name) = left {
        if let LogicalExpr::PropertyAccessExp(prop) = right {
            if let Some(cte_name) = cte_references.get(&var_name.0) {
                return Some((
                    cte_name.clone(),
                    var_name.0.clone(),
                    prop.table_alias.0.clone(),
                    prop.column.raw().to_string(),
                ));
            }
        }
    }

    None
}

pub fn extract_distinct(plan: &LogicalPlan) -> bool {
    // Extract distinct flag from Projection nodes
    let result = match plan {
        LogicalPlan::Projection(projection) => {
            crate::debug_println!(
                "DEBUG extract_distinct: Found Projection, distinct={}",
                projection.distinct
            );
            projection.distinct
        }
        LogicalPlan::OrderBy(order_by) => {
            crate::debug_println!("DEBUG extract_distinct: OrderBy, recursing");
            extract_distinct(&order_by.input)
        }
        LogicalPlan::Skip(skip) => {
            crate::debug_println!("DEBUG extract_distinct: Skip, recursing");
            extract_distinct(&skip.input)
        }
        LogicalPlan::Limit(limit) => {
            crate::debug_println!("DEBUG extract_distinct: Limit, recursing");
            extract_distinct(&limit.input)
        }
        LogicalPlan::GroupBy(group_by) => {
            crate::debug_println!("DEBUG extract_distinct: GroupBy, recursing");
            extract_distinct(&group_by.input)
        }
        LogicalPlan::GraphJoins(graph_joins) => {
            crate::debug_println!("DEBUG extract_distinct: GraphJoins, recursing");
            extract_distinct(&graph_joins.input)
        }
        LogicalPlan::Filter(filter) => {
            crate::debug_println!("DEBUG extract_distinct: Filter, recursing");
            extract_distinct(&filter.input)
        }
        _ => {
            crate::debug_println!("DEBUG extract_distinct: Other variant, returning false");
            false
        }
    };
    crate::debug_println!("DEBUG extract_distinct: Returning {}", result);
    result
}

pub fn extract_filters(plan: &LogicalPlan) -> RenderPlanBuilderResult<Option<RenderExpr>> {
    let filters = match plan {
        LogicalPlan::Empty => None,
        LogicalPlan::ViewScan(scan) => {
            // ViewScan.view_filter should be None after CleanupViewScanFilters optimizer.
            // All filters are consolidated in GraphRel.where_predicate.
            // This case handles standalone ViewScans outside of GraphRel contexts.
            let mut filters = Vec::new();

            // Add view_filter if present
            if let Some(ref filter) = scan.view_filter {
                let mut expr: RenderExpr = filter.clone().try_into()?;
                apply_property_mapping_to_expr(&mut expr, &LogicalPlan::ViewScan(scan.clone()));
                filters.push(expr);
            }

            // Add schema_filter if present (defined in YAML schema)
            if let Some(ref schema_filter) = scan.schema_filter {
                // Use a default alias for standalone ViewScans
                // In practice, these will be wrapped in GraphNode which provides the alias
                if let Ok(sql) = schema_filter.to_sql("t") {
                    log::debug!("ViewScan: Adding schema filter: {}", sql);
                    filters.push(RenderExpr::Raw(sql));
                }
            }

            if filters.is_empty() {
                None
            } else if filters.len() == 1 {
                Some(filters.into_iter().next().unwrap())
            } else {
                // Combine with AND
                let combined = filters
                    .into_iter()
                    .reduce(|acc, pred| {
                        RenderExpr::OperatorApplicationExp(OperatorApplication {
                            operator: Operator::And,
                            operands: vec![acc, pred],
                        })
                    })
                    .unwrap();
                Some(combined)
            }
        }
        LogicalPlan::GraphNode(graph_node) => {
            // For node-only queries, extract both view_filter and schema_filter from the input ViewScan
            if let LogicalPlan::ViewScan(scan) = graph_node.input.as_ref() {
                log::info!(
                    "üîç GraphNode '{}' extract_filters: ViewScan table={}",
                    graph_node.alias,
                    scan.source_table
                );

                let mut filters = Vec::new();

                // Extract view_filter (user's WHERE clause, injected by optimizer)
                if let Some(ref view_filter) = scan.view_filter {
                    log::debug!(
                        "extract_filters: view_filter BEFORE conversion: {:?}",
                        view_filter
                    );
                    let mut expr: RenderExpr = view_filter.clone().try_into()?;
                    log::debug!("extract_filters: view_filter AFTER conversion: {:?}", expr);
                    apply_property_mapping_to_expr(&mut expr, &graph_node.input);
                    log::debug!(
                        "extract_filters: view_filter AFTER property mapping: {:?}",
                        expr
                    );
                    log::info!(
                        "GraphNode '{}': Adding view_filter: {:?}",
                        graph_node.alias,
                        expr
                    );
                    filters.push(expr);
                }

                // Extract schema_filter (from YAML schema)
                // Wrap in parentheses to ensure correct operator precedence when combined with user filters
                if let Some(ref schema_filter) = scan.schema_filter {
                    if let Ok(sql) = schema_filter.to_sql(&graph_node.alias) {
                        log::info!(
                            "GraphNode '{}': Adding schema filter: {}",
                            graph_node.alias,
                            sql
                        );
                        // Always wrap schema filter in parentheses for safe combination
                        filters.push(RenderExpr::Raw(format!("({})", sql)));
                    }
                }

                // Combine filters with AND if multiple
                // Use explicit AND combination - each operand will be wrapped appropriately
                if filters.is_empty() {
                    return Ok(None);
                } else if filters.len() == 1 {
                    return Ok(Some(filters.into_iter().next().unwrap()));
                } else {
                    // When combining filters, wrap non-Raw expressions in parentheses
                    // to handle AND/OR precedence correctly
                    let combined = filters
                        .into_iter()
                        .reduce(|acc, pred| {
                            // The OperatorApplicationExp will render as "(left) AND (right)"
                            // due to the render_expr_to_sql_string logic
                            RenderExpr::OperatorApplicationExp(OperatorApplication {
                                operator: Operator::And,
                                operands: vec![acc, pred],
                            })
                        })
                        .unwrap();
                    return Ok(Some(combined));
                }
            }
            None
        }
        LogicalPlan::GraphRel(graph_rel) => {
            log::trace!(
                "GraphRel node detected, collecting filters from ALL nested where_predicates"
            );

            // Collect all where_predicates from this GraphRel and nested GraphRel nodes
            // Using helper functions from plan_builder_helpers module
            let all_predicates =
                collect_graphrel_predicates(&LogicalPlan::GraphRel(graph_rel.clone()));

            let mut all_predicates = all_predicates;

            // üîí Add schema-level filters from ViewScans
            let schema_filters =
                collect_schema_filters(&LogicalPlan::GraphRel(graph_rel.clone()), None);
            if !schema_filters.is_empty() {
                log::info!(
                    "Adding {} schema filter(s) to WHERE clause",
                    schema_filters.len()
                );
                all_predicates.extend(schema_filters);
            }

            // TODO: Add relationship uniqueness filters for undirected multi-hop patterns
            // This requires fixing Issue #1 (Undirected Multi-Hop Patterns Generate Broken SQL) first.
            // See KNOWN_ISSUES.md for details.
            // Currently, undirected multi-hop patterns generate broken SQL with wrong aliases,
            // so adding uniqueness filters here would not work correctly.

            // üöÄ ADD CYCLE PREVENTION for fixed-length paths (only for 2+ hops)
            // Single hop (*1) can't have cycles - no need for cycle prevention
            if let Some(spec) = &graph_rel.variable_length {
                if let Some(exact_hops) = spec.exact_hop_count() {
                    // Skip cycle prevention for *1 - single hop can't cycle
                    if exact_hops >= 2 && graph_rel.shortest_path_mode.is_none() {
                        crate::debug_println!("DEBUG: extract_filters - Adding cycle prevention for fixed-length *{}", exact_hops);

                        // Check if this is a denormalized pattern
                        let is_denormalized = is_node_denormalized(&graph_rel.left)
                            && is_node_denormalized(&graph_rel.right);

                        // Extract table/column info for cycle prevention
                        // Use extract_table_name directly to avoid wrong fallbacks
                        let start_table =
                            extract_table_name(&graph_rel.left).ok_or_else(|| {
                                RenderBuildError::MissingTableInfo(
                                    "start node in cycle prevention".to_string(),
                                )
                            })?;
                        let end_table =
                            extract_table_name(&graph_rel.right).ok_or_else(|| {
                                RenderBuildError::MissingTableInfo(
                                    "end node in cycle prevention".to_string(),
                                )
                            })?;

                        let rel_cols = extract_relationship_columns(&graph_rel.center)
                            .unwrap_or(RelationshipColumns {
                                from_id: "from_node_id".to_string(),
                                to_id: "to_node_id".to_string(),
                            });

                        // For denormalized, use relationship columns directly
                        // For normal, use node ID columns
                        let (start_id_col, end_id_col) = if is_denormalized {
                            (rel_cols.from_id.clone(), rel_cols.to_id.clone())
                        } else {
                            let start = extract_id_column(&graph_rel.left)
                                .unwrap_or_else(|| table_to_id_column(&start_table));
                            let end = extract_id_column(&graph_rel.right)
                                .unwrap_or_else(|| table_to_id_column(&end_table));
                            (start, end)
                        };

                        // Generate cycle prevention filters
                        if let Some(cycle_filter) = crate::render_plan::cte_extraction::generate_cycle_prevention_filters(
                            exact_hops,
                            &start_id_col,
                            &rel_cols.to_id,
                            &rel_cols.from_id,
                            &end_id_col,
                            &graph_rel.left_connection,
                            &graph_rel.right_connection,
                        ) {
                            crate::debug_println!("DEBUG: extract_filters - Generated cycle prevention filter");
                            all_predicates.push(cycle_filter);
                        }
                    }
                }
            }

            if all_predicates.is_empty() {
                None
            } else if all_predicates.len() == 1 {
                log::trace!("Found 1 GraphRel predicate");
                Some(all_predicates.into_iter().next().unwrap())
            } else {
                // Combine with AND
                log::trace!(
                    "Found {} GraphRel predicates, combining with AND",
                    all_predicates.len()
                );
                let combined = all_predicates
                    .into_iter()
                    .reduce(|acc, pred| {
                        RenderExpr::OperatorApplicationExp(OperatorApplication {
                            operator: Operator::And,
                            operands: vec![acc, pred],
                        })
                    })
                    .unwrap();
                Some(combined)
            }
        }
        LogicalPlan::Filter(filter) => {
            println!(
                "DEBUG: extract_filters - Found Filter node with predicate: {:?}",
                filter.predicate
            );
            println!(
                "DEBUG: extract_filters - Filter input type: {:?}",
                std::mem::discriminant(&*filter.input)
            );
            let mut expr: RenderExpr = filter.predicate.clone().try_into()?;
            // Apply property mapping to the filter expression
            apply_property_mapping_to_expr(&mut expr, &filter.input);

            // Also check for schema filters from the input (e.g., GraphNode ‚Üí ViewScan)
            if let Some(input_filter) = filter.input.extract_filters()? {
                crate::debug_println!("DEBUG: extract_filters - Combining Filter predicate with input schema filter");
                // Combine the Filter predicate with input's schema filter using AND
                Some(RenderExpr::OperatorApplicationExp(OperatorApplication {
                    operator: Operator::And,
                    operands: vec![input_filter, expr],
                }))
            } else {
                crate::debug_println!("DEBUG: extract_filters - Returning Filter predicate only (no input filter)");
                Some(expr)
            }
        }
        LogicalPlan::Projection(projection) => {
            crate::debug_println!(
                "DEBUG: extract_filters - Projection, recursing to input type: {:?}",
                std::mem::discriminant(&*projection.input)
            );
            projection.input.extract_filters()?
        }
        LogicalPlan::GroupBy(group_by) => group_by.input.extract_filters()?,
        LogicalPlan::OrderBy(order_by) => order_by.input.extract_filters()?,
        LogicalPlan::Skip(skip) => skip.input.extract_filters()?,
        LogicalPlan::Limit(limit) => limit.input.extract_filters()?,
        LogicalPlan::Cte(cte) => cte.input.extract_filters()?,
        LogicalPlan::GraphJoins(graph_joins) => graph_joins.input.extract_filters()?,
        LogicalPlan::Union(_) => None,
        LogicalPlan::PageRank(_) => None,
        LogicalPlan::Unwind(u) => u.input.extract_filters()?,
        LogicalPlan::CartesianProduct(cp) => {
            // Combine filters from both sides with AND
            let left_filters = cp.left.extract_filters()?;
            let right_filters = cp.right.extract_filters()?;

            // DEBUG: Log what we're extracting
            log::info!("üîç CartesianProduct extract_filters:");
            log::info!("  Left filters: {:?}", left_filters);
            log::info!("  Right filters: {:?}", right_filters);

            match (left_filters, right_filters) {
                (None, None) => None,
                (Some(l), None) => {
                    log::info!("  ‚úÖ Returning left filters only");
                    Some(l)
                }
                (None, Some(r)) => {
                    log::info!("  ‚úÖ Returning right filters only");
                    Some(r)
                }
                (Some(l), Some(r)) => {
                    log::warn!("  ‚ö†Ô∏è BOTH sides have filters - combining with AND!");
                    log::warn!("  ‚ö†Ô∏è This may cause duplicates if filters are the same!");
                    Some(RenderExpr::OperatorApplicationExp(OperatorApplication {
                        operator: Operator::And,
                        operands: vec![l, r],
                    }))
                }
            }
        }
        LogicalPlan::WithClause(wc) => wc.input.extract_filters()?,
    };
    Ok(filters)
}

pub fn extract_final_filters(plan: &LogicalPlan) -> RenderPlanBuilderResult<Option<RenderExpr>> {
    let final_filters = match plan {
        LogicalPlan::Limit(limit) => extract_final_filters(&limit.input)?,
        LogicalPlan::Skip(skip) => extract_final_filters(&skip.input)?,
        LogicalPlan::OrderBy(order_by) => extract_final_filters(&order_by.input)?,
        LogicalPlan::GroupBy(group_by) => extract_final_filters(&group_by.input)?,
        LogicalPlan::GraphJoins(graph_joins) => extract_final_filters(&graph_joins.input)?,
        LogicalPlan::Projection(projection) => extract_final_filters(&projection.input)?,
        LogicalPlan::Filter(filter) => {
            let mut expr: RenderExpr = filter.predicate.clone().try_into()?;
            // Apply property mapping to the filter expression
            apply_property_mapping_to_expr(&mut expr, &filter.input);
            Some(expr)
        }
        LogicalPlan::GraphRel(graph_rel) => {
            // For GraphRel, extract path function filters that should be applied to the final query
            if let Some(logical_expr) = &graph_rel.where_predicate {
                let mut filter_expr: RenderExpr = logical_expr.clone().try_into()?;
                // Apply property mapping to the where predicate
                apply_property_mapping_to_expr(
                    &mut filter_expr,
                    &LogicalPlan::GraphRel(graph_rel.clone()),
                );
                let start_alias = graph_rel.left_connection.clone();
                let end_alias = graph_rel.right_connection.clone();

                // For extract_final_filters, we only need to categorize path function filters
                // Schema-aware categorization is not needed here since this is just for
                // separating path functions from other filters. Use a dummy categorization.
                let rel_labels = graph_rel.labels.clone().unwrap_or_default();

                // Try to get schema for proper categorization
                let schemas_lock = GLOBAL_SCHEMAS.get().expect("Schemas not initialized");
                let schemas = schemas_lock
                    .try_read()
                    .expect("Failed to acquire schema lock");

                // Try to find a schema that has this relationship type
                let schema_for_categorization = if !rel_labels.is_empty() {
                    schemas.values().find(|s| {
                        rel_labels
                            .iter()
                            .any(|label| s.get_rel_schema(label).is_ok())
                    })
                } else {
                    None
                };

                let schema_ref = schema_for_categorization.unwrap_or_else(|| {
                    schemas
                        .values()
                        .next()
                        .expect("At least one schema must be loaded")
                });

                let categorized = categorize_filters(
                    Some(&filter_expr),
                    &start_alias,
                    &end_alias,
                    &graph_rel.alias,
                    schema_ref,
                    &rel_labels,
                );

                categorized.path_function_filters
            } else {
                None
            }
        }
        _ => None,
    };
    Ok(final_filters)
}

pub fn extract_from(plan: &LogicalPlan) -> RenderPlanBuilderResult<Option<FromTable>> {
    log::debug!(
        "üîç extract_from START: plan type={:?}",
        std::mem::discriminant(plan)
    );

    let from_ref = match plan {
        LogicalPlan::Empty => None,
        LogicalPlan::ViewScan(scan) => {
            // Check if this is a relationship ViewScan (has from_id/to_id)
            if scan.from_id.is_some() && scan.to_id.is_some() {
                // For denormalized edges, use the actual table name directly
                // CTE references (rel_*) are only needed for standard edges with separate node tables
                // Denormalized ViewScans have from_node_properties/to_node_properties indicating
                // node data is stored on the edge table itself
                let use_actual_table =
                    scan.from_node_properties.is_some() && scan.to_node_properties.is_some();

                debug!("üìä extract_from ViewScan: source_table={}, from_props={:?}, to_props={:?}, use_actual_table={}",
                    scan.source_table,
                    scan.from_node_properties.as_ref().map(|p| p.len()),
                    scan.to_node_properties.as_ref().map(|p| p.len()),
                    use_actual_table);

                if use_actual_table {
                    // Denormalized: use actual table name
                    debug!("‚úÖ Using actual table name: {}", scan.source_table);
                    Some(ViewTableRef::new_table(
                        scan.as_ref().clone(),
                        scan.source_table.clone(),
                    ))
                } else {
                    // Standard edge: use CTE reference
                    let cte_name =
                        format!("rel_{}", scan.source_table.replace([' ', '-', '_'], ""));
                    debug!("üîÑ Using CTE reference: {}", cte_name);
                    Some(ViewTableRef::new_table(scan.as_ref().clone(), cte_name))
                }
            } else {
                // For node ViewScans, use the table name
                Some(ViewTableRef::new_table(
                    scan.as_ref().clone(),
                    scan.source_table.clone(),
                ))
            }
        }
        LogicalPlan::GraphNode(graph_node) => {
            // For GraphNode, extract FROM from the input but use this GraphNode's alias
            // CROSS JOINs for multiple standalone nodes are handled in extract_joins
            println!(
                "DEBUG: GraphNode.extract_from() - alias: {}, input: {:?}",
                graph_node.alias, graph_node.input
            );
            match &*graph_node.input {
                LogicalPlan::ViewScan(scan) => {
                    println!(
                        "DEBUG: GraphNode.extract_from() - matched ViewScan, table: {}",
                        scan.source_table
                    );
                    // Check if this is a relationship ViewScan (has from_id/to_id)
                    let table_or_cte_name = if scan.from_id.is_some() && scan.to_id.is_some() {
                        // For denormalized edges, use actual table; for standard edges, use CTE
                        let use_actual_table = scan.from_node_properties.is_some()
                            && scan.to_node_properties.is_some();
                        if use_actual_table {
                            scan.source_table.clone()
                        } else {
                            format!("rel_{}", scan.source_table.replace([' ', '-', '_'], ""))
                        }
                    } else {
                        // For node ViewScans, use the table name
                        scan.source_table.clone()
                    };
                    // ViewScan already returns ViewTableRef, just update the alias
                    let mut view_ref =
                        ViewTableRef::new_table(scan.as_ref().clone(), table_or_cte_name);
                    view_ref.alias = Some(graph_node.alias.clone());
                    println!(
                        "DEBUG: GraphNode.extract_from() - created ViewTableRef: {:?}",
                        view_ref
                    );
                    Some(view_ref)
                }
                _ => {
                    println!(
                        "DEBUG: GraphNode.extract_from() - not a ViewScan, input type: {:?}",
                        graph_node.input
                    );
                    // For other input types, extract FROM and convert
                    let mut from_ref = from_table_to_view_ref(extract_from(&graph_node.input)?);
                    // Use this GraphNode's alias
                    if let Some(ref mut view_ref) = from_ref {
                        view_ref.alias = Some(graph_node.alias.clone());
                    }
                    from_ref
                }
            }
        }
        LogicalPlan::GraphRel(graph_rel) => {
            // DENORMALIZED EDGE TABLE CHECK
            // For denormalized patterns, both nodes are virtual - use relationship table as FROM
            let left_is_denormalized = is_node_denormalized(&graph_rel.left);
            let right_is_denormalized = is_node_denormalized(&graph_rel.right);

            log::debug!(
                "üîç extract_from GraphRel: alias='{}', left_is_denorm={}, right_is_denorm={}",
                graph_rel.alias,
                left_is_denormalized,
                right_is_denormalized
            );

            if left_is_denormalized && right_is_denormalized {
                log::debug!("‚úì DENORMALIZED pattern: both nodes on edge table, using edge table as FROM");

                // For multi-hop denormalized, find the first (leftmost) relationship
                fn find_first_graph_rel(
                    graph_rel: &crate::query_planner::logical_plan::GraphRel,
                ) -> &crate::query_planner::logical_plan::GraphRel {
                    match graph_rel.left.as_ref() {
                        LogicalPlan::GraphRel(left_rel) => find_first_graph_rel(left_rel),
                        _ => graph_rel,
                    }
                }

                let first_graph_rel = find_first_graph_rel(graph_rel);

                // Try ViewScan first (normal case)
                if let LogicalPlan::ViewScan(scan) = first_graph_rel.center.as_ref() {
                    log::debug!(
                        "‚úì Using ViewScan edge table '{}' AS '{}'",
                        scan.source_table,
                        first_graph_rel.alias
                    );
                    return Ok(Some(FromTable::new(Some(ViewTableRef {
                        source: first_graph_rel.center.clone(),
                        name: scan.source_table.clone(),
                        alias: Some(first_graph_rel.alias.clone()),
                        use_final: scan.use_final,
                    }))));
                }

                log::debug!(
                    "‚ö†Ô∏è  Could not extract edge table from center (type: {:?})",
                    std::mem::discriminant(first_graph_rel.center.as_ref())
                );
            }

            // Check if both nodes are anonymous (edge-driven query)
            let left_table_name = extract_table_name(&graph_rel.left);
            let right_table_name = extract_table_name(&graph_rel.right);

            // If both nodes are anonymous, use the relationship table as FROM
            if left_table_name.is_none() && right_table_name.is_none() {
                // Edge-driven query: use relationship table directly (not as CTE)
                // Extract table name from the relationship ViewScan
                if let LogicalPlan::ViewScan(scan) = graph_rel.center.as_ref() {
                    // Use actual table name, not CTE name
                    return Ok(Some(FromTable::new(Some(ViewTableRef::new_table(
                        scan.as_ref().clone(),
                        scan.source_table.clone(),
                    )))));
                }
                // Fallback to normal extraction if not a ViewScan
                return Ok(None);
            }

            // For GraphRel with labeled nodes, we need to include the start node in the FROM clause
            // This handles simple relationship queries where the start node should be FROM

            // ALWAYS use left node as FROM for relationship patterns.
            // The is_optional flag determines JOIN type (INNER vs LEFT), not FROM table selection.
            //
            // For `MATCH (a) OPTIONAL MATCH (a)-[:R]->(b)`:
            //   - a is the left connection (required, already defined)
            //   - b is the right connection (optional, newly introduced)
            //   - FROM should be `a`, with LEFT JOIN to relationship and `b`
            //
            // For `MATCH (a) OPTIONAL MATCH (b)-[:R]->(a)`:
            //   - b is the left connection (optional, newly introduced)
            //   - a is the right connection (required, already defined)
            //   - FROM should be `a` (the required one), but the pattern structure has `b` on left
            //   - This case needs special handling: find which connection is NOT optional

            println!("DEBUG: graph_rel.is_optional = {:?}", graph_rel.is_optional);

            // Use left as primary, right as fallback
            let (primary_from, fallback_from) = (
                extract_from(&graph_rel.left),
                extract_from(&graph_rel.right),
            );

            crate::debug_println!("DEBUG: primary_from = {:?}", primary_from);
            crate::debug_println!("DEBUG: fallback_from = {:?}", fallback_from);

            if let Ok(Some(from_table)) = primary_from {
                from_table_to_view_ref(Some(from_table))
            } else {
                // If primary node doesn't have FROM, try fallback
                let right_from = fallback_from;
                crate::debug_println!("DEBUG: Using fallback FROM");
                crate::debug_println!("DEBUG: right_from = {:?}", right_from);

                if let Ok(Some(from_table)) = right_from {
                    from_table_to_view_ref(Some(from_table))
                } else {
                    // If right also doesn't have FROM, check if right contains a nested GraphRel
                    if let LogicalPlan::GraphRel(nested_graph_rel) = graph_rel.right.as_ref() {
                        // Extract FROM from the nested GraphRel's left node
                        let nested_left_from = extract_from(&nested_graph_rel.left);
                        crate::debug_println!(
                            "DEBUG: nested_graph_rel.left = {:?}",
                            nested_graph_rel.left
                        );
                        crate::debug_println!(
                            "DEBUG: nested_left_from = {:?}",
                            nested_left_from
                        );

                        if let Ok(Some(nested_from_table)) = nested_left_from {
                            from_table_to_view_ref(Some(nested_from_table))
                        } else {
                            // If nested left also doesn't have FROM, create one from the nested left_connection alias
                            let table_name = extract_table_name(&nested_graph_rel.left)
                                .ok_or_else(|| {
                                    super::errors::RenderBuildError::TableNameNotFound(format!(
                                    "Could not resolve table name for alias '{}', plan: {:?}",
                                    nested_graph_rel.left_connection, nested_graph_rel.left
                                ))
                                })?;

                            Some(super::ViewTableRef {
                                source: std::sync::Arc::new(LogicalPlan::Empty),
                                name: table_name,
                                alias: Some(nested_graph_rel.left_connection.clone()),
                                use_final: false,
                            })
                        }
                    } else {
                        // If right doesn't have FROM, we need to determine which node should be the anchor
                        // Use find_anchor_node logic to choose the correct anchor
                        let all_connections = get_all_relationship_connections(plan);
                        let optional_aliases = std::collections::HashSet::new();
                        let denormalized_aliases = std::collections::HashSet::new();

                        if let Some(anchor_alias) = find_anchor_node(
                            &all_connections,
                            &optional_aliases,
                            &denormalized_aliases,
                        ) {
                            // Determine which node (left or right) the anchor corresponds to
                            let (table_plan, connection_alias) =
                                if anchor_alias == graph_rel.left_connection {
                                    (&graph_rel.left, &graph_rel.left_connection)
                                } else {
                                    (&graph_rel.right, &graph_rel.right_connection)
                                };

                            let table_name = extract_table_name(table_plan)
                                .ok_or_else(|| super::errors::RenderBuildError::TableNameNotFound(format!(
                                    "Could not resolve table name for anchor alias '{}', plan: {:?}",
                                    connection_alias, table_plan
                                )))?;

                            Some(super::ViewTableRef {
                                source: std::sync::Arc::new(LogicalPlan::Empty),
                                name: table_name,
                                alias: Some(connection_alias.clone()),
                                use_final: false,
                            })
                        } else {
                            // Fallback: use left_connection as anchor (traditional behavior)
                            let table_name =
                                extract_table_name(&graph_rel.left).ok_or_else(|| {
                                    super::errors::RenderBuildError::TableNameNotFound(format!(
                                    "Could not resolve table name for alias '{}', plan: {:?}",
                                    graph_rel.left_connection, graph_rel.left
                                ))
                                })?;

                            Some(super::ViewTableRef {
                                source: std::sync::Arc::new(LogicalPlan::Empty),
                                name: table_name,
                                alias: Some(graph_rel.left_connection.clone()),
                                use_final: false,
                            })
                        }
                    }
                }
            }
        }
        LogicalPlan::Filter(filter) => {
            log::debug!(
                "  ‚Üí Filter, recursing to input type={:?}",
                std::mem::discriminant(filter.input.as_ref())
            );
            from_table_to_view_ref(extract_from(&filter.input)?)
        }
        LogicalPlan::Projection(projection) => {
            log::debug!(
                "  ‚Üí Projection, recursing to input type={:?}",
                std::mem::discriminant(projection.input.as_ref())
            );
            from_table_to_view_ref(extract_from(&projection.input)?)
        }
        LogicalPlan::GraphJoins(graph_joins) => {
            // ============================================================================
            // CLEAN DESIGN: FROM table determination for GraphJoins
            // ============================================================================
            //
            // The logical model is simple:
            // 1. Every table in a graph query is represented as a Join in graph_joins.joins
            // 2. A Join with EMPTY joining_on is a FROM marker (no join conditions = base table)
            // 3. A Join with NON-EMPTY joining_on is a real JOIN
            // 4. There should be exactly ONE FROM marker per GraphJoins
            //
            // This function finds that FROM marker and returns it.
            // NO FALLBACKS. If there's no FROM marker, something is wrong upstream.
            // ============================================================================

            log::debug!(
                "üîç GraphJoins.extract_from: {} joins, anchor_table={:?}",
                graph_joins.joins.len(),
                graph_joins.anchor_table
            );

            // üîß PARAMETERIZED VIEW FIX: Get parameterized table references from input plan
            let parameterized_tables = extract_rel_and_node_tables(&graph_joins.input);

            // STEP 1: Find FROM marker (Join with empty joining_on)
            // This is the authoritative source - it was set by graph_join_inference
            for join in &graph_joins.joins {
                if join.joining_on.is_empty() {
                    // üîß PARAMETERIZED VIEW FIX: Use parameterized table reference if available
                    let table_name = parameterized_tables
                        .get(&join.table_alias)
                        .cloned()
                        .unwrap_or_else(|| join.table_name.clone());

                    log::info!(
                        "‚úÖ Found FROM marker: table='{}' (original='{}') alias='{}'",
                        table_name,
                        join.table_name,
                        join.table_alias
                    );
                    return Ok(Some(FromTable::new(Some(super::ViewTableRef {
                        source: std::sync::Arc::new(LogicalPlan::Empty),
                        name: table_name,
                        alias: Some(join.table_alias.clone()),
                        use_final: false,
                    }))));
                }
            }

            // STEP 2: No FROM marker found - check special cases that don't use joins

            // Helper to find GraphRel through wrappers
            fn find_graph_rel(plan: &LogicalPlan) -> Option<&GraphRel> {
                match plan {
                    LogicalPlan::GraphRel(gr) => Some(gr),
                    LogicalPlan::Projection(proj) => find_graph_rel(&proj.input),
                    LogicalPlan::Filter(filter) => find_graph_rel(&filter.input),
                    LogicalPlan::Unwind(u) => find_graph_rel(&u.input),
                    LogicalPlan::GraphJoins(gj) => find_graph_rel(&gj.input),
                    _ => None,
                }
            }

            // Helper to find GraphNode for node-only queries
            fn find_graph_node(
                plan: &LogicalPlan,
            ) -> Option<&crate::query_planner::logical_plan::GraphNode> {
                match plan {
                    LogicalPlan::GraphNode(gn) => Some(gn),
                    LogicalPlan::Projection(proj) => find_graph_node(&proj.input),
                    LogicalPlan::Filter(filter) => find_graph_node(&filter.input),
                    LogicalPlan::Unwind(u) => find_graph_node(&u.input),
                    LogicalPlan::GraphJoins(gj) => find_graph_node(&gj.input),
                    _ => None,
                }
            }

            // Helper to find CartesianProduct
            fn find_cartesian_product(
                plan: &LogicalPlan,
            ) -> Option<&crate::query_planner::logical_plan::CartesianProduct> {
                match plan {
                    LogicalPlan::CartesianProduct(cp) => Some(cp),
                    LogicalPlan::Filter(f) => find_cartesian_product(&f.input),
                    LogicalPlan::Projection(p) => find_cartesian_product(&p.input),
                    _ => None,
                }
            }

            fn is_cte_reference(plan: &LogicalPlan) -> bool {
                match plan {
                    LogicalPlan::WithClause(_) => true,
                    LogicalPlan::ViewScan(vs) => vs.source_table.starts_with("with_"),
                    LogicalPlan::GraphNode(gn) => is_cte_reference(&gn.input),
                    LogicalPlan::Projection(p) => is_cte_reference(&p.input),
                    LogicalPlan::Filter(f) => is_cte_reference(&f.input),
                    _ => false,
                }
            }

            // CASE A: Empty joins - check for denormalized edge or node-only patterns
            if graph_joins.joins.is_empty() {
                log::debug!("üìã No joins - checking for special patterns");

                // A.1: Denormalized edge pattern - use edge table directly
                if let Some(graph_rel) = find_graph_rel(&graph_joins.input) {
                    if let LogicalPlan::ViewScan(rel_scan) = graph_rel.center.as_ref() {
                        if rel_scan.from_node_properties.is_some()
                            || rel_scan.to_node_properties.is_some()
                        {
                            log::info!(
                                "üéØ DENORMALIZED: Using edge table '{}' as FROM",
                                rel_scan.source_table
                            );
                            return Ok(Some(FromTable::new(Some(super::ViewTableRef {
                                source: graph_rel.center.clone(),
                                name: rel_scan.source_table.clone(),
                                alias: Some(graph_rel.alias.clone()),
                                use_final: rel_scan.use_final,
                            }))));
                        }
                    }

                    // A.2: Polymorphic edge - use the labeled node
                    if let LogicalPlan::GraphNode(left_node) = graph_rel.left.as_ref() {
                        if let LogicalPlan::ViewScan(scan) = left_node.input.as_ref() {
                            log::info!(
                                "üéØ POLYMORPHIC: Using left node '{}' as FROM",
                                left_node.alias
                            );
                            return Ok(Some(FromTable::new(Some(super::ViewTableRef {
                                source: std::sync::Arc::new(LogicalPlan::GraphNode(
                                    left_node.clone(),
                                )),
                                name: scan.source_table.clone(),
                                alias: Some(left_node.alias.clone()),
                                use_final: scan.use_final,
                            }))));
                        }
                    }
                    if let LogicalPlan::GraphNode(right_node) = graph_rel.right.as_ref() {
                        if let LogicalPlan::ViewScan(scan) = right_node.input.as_ref() {
                            log::info!(
                                "üéØ POLYMORPHIC: Using right node '{}' as FROM",
                                right_node.alias
                            );
                            return Ok(Some(FromTable::new(Some(super::ViewTableRef {
                                source: std::sync::Arc::new(LogicalPlan::GraphNode(
                                    right_node.clone(),
                                )),
                                name: scan.source_table.clone(),
                                alias: Some(right_node.alias.clone()),
                                use_final: scan.use_final,
                            }))));
                        }
                    }
                }

                // A.3: Node-only query (MATCH (n:Label) RETURN n)
                if let Some(graph_node) = find_graph_node(&graph_joins.input) {
                    if let LogicalPlan::ViewScan(scan) = graph_node.input.as_ref() {
                        log::info!("üéØ NODE-ONLY: Using node '{}' as FROM", graph_node.alias);
                        let view_ref = super::ViewTableRef::new_table_with_alias(
                            scan.as_ref().clone(),
                            scan.source_table.clone(),
                            graph_node.alias.clone(),
                        );
                        return Ok(Some(FromTable::new(Some(view_ref))));
                    }
                }

                // A.4: CartesianProduct (WITH...MATCH or comma patterns)
                if let Some(cp) = find_cartesian_product(&graph_joins.input) {
                    if is_cte_reference(&cp.left) {
                        log::info!("üéØ WITH...MATCH: FROM comes from right side");
                        return extract_from(&cp.right);
                    } else {
                        log::info!("üéØ COMMA PATTERN: FROM comes from left side");
                        return extract_from(&cp.left);
                    }
                }

                // No valid FROM found for empty joins - this is unexpected
                log::warn!("‚ö†Ô∏è GraphJoins has empty joins and no recognizable pattern - returning None");
                return Ok(None);
            }

            // CASE B: Has joins but no FROM marker
            // This happens for OPTIONAL MATCH where the anchor comes from a prior MATCH
            // The anchor_table is set but the anchor table info is in the input plan, not in joins
            //
            // ALSO: After WITH scope barriers, anchor_table may be None if the original anchor
            // was not exported by the WITH. In this case, pick the first join as anchor.
            if let Some(anchor_alias) = &graph_joins.anchor_table {
                log::info!(
                    "üîç No FROM marker in joins, looking for anchor '{}' in input plan",
                    anchor_alias
                );

                // Try to find the anchor table in the input plan tree
                // For OPTIONAL MATCH, the anchor is from the first MATCH (which is in input)
                let rel_tables = extract_rel_and_node_tables(&graph_joins.input);
                if let Some(table_name) = rel_tables.get(anchor_alias) {
                    log::info!(
                        "‚úÖ Found anchor '{}' table '{}' in input plan",
                        anchor_alias,
                        table_name
                    );
                    return Ok(Some(FromTable::new(Some(super::ViewTableRef {
                        source: std::sync::Arc::new(LogicalPlan::Empty),
                        name: table_name.clone(),
                        alias: Some(anchor_alias.clone()),
                        use_final: false,
                    }))));
                }

                // Also check CTE references
                if let Some(cte_name) = graph_joins.cte_references.get(anchor_alias) {
                    log::info!(
                        "‚úÖ Anchor '{}' has CTE reference: '{}'",
                        anchor_alias,
                        cte_name
                    );
                    return Ok(Some(FromTable::new(Some(super::ViewTableRef {
                        source: std::sync::Arc::new(LogicalPlan::Empty),
                        name: cte_name.clone(),
                        alias: Some(anchor_alias.clone()),
                        use_final: false,
                    }))));
                }

                // Try find_table_name_for_alias as last resort
                if let Some(table_name) =
                    find_table_name_for_alias(&graph_joins.input, anchor_alias)
                {
                    log::info!(
                        "‚úÖ Found anchor '{}' via find_table_name_for_alias: '{}'",
                        anchor_alias,
                        table_name
                    );
                    return Ok(Some(FromTable::new(Some(super::ViewTableRef {
                        source: std::sync::Arc::new(LogicalPlan::Empty),
                        name: table_name,
                        alias: Some(anchor_alias.clone()),
                        use_final: false,
                    }))));
                }
            } else {
                // No anchor_table - likely cleared due to scope barrier
                // PRIORITY: If we have CTE references, use the LATEST CTE as FROM
                // The CTE references represent variables that are in scope after WITH clauses
                // We want the LAST CTE (highest sequence number) as it represents the final scope

                if !graph_joins.cte_references.is_empty() {
                    log::warn!(
                        "üîç anchor_table is None, but have {} CTE references - finding latest CTE as FROM",
                        graph_joins.cte_references.len()
                    );

                    // Find the CTE with the highest sequence number (format: with_*_cte_N)
                    // This is the most recent WITH clause's output
                    let mut best_cte: Option<(&String, &String, usize)> = None;
                    for (alias, cte_name) in &graph_joins.cte_references {
                        // Extract sequence number from CTE name
                        // Format: "with_tag_cte_1" or "with_inValidPostCount_postCount_tag_cte_1"
                        let seq_num = if let Some(pos) = cte_name.rfind("_cte_") {
                            cte_name[pos + 5..].parse::<usize>().unwrap_or(0)
                        } else {
                            0
                        };

                        // Keep the CTE with highest sequence number (latest in the chain)
                        // Tie-breaker: prefer longer CTE names (more aliases = more complete)
                        match &best_cte {
                            None => best_cte = Some((alias, cte_name, seq_num)),
                            Some((_, current_name, current_seq)) => {
                                if seq_num > *current_seq
                                    || (seq_num == *current_seq
                                        && cte_name.len() > current_name.len())
                                {
                                    best_cte = Some((alias, cte_name, seq_num));
                                }
                            }
                        }
                    }

                    if let Some((alias, cte_name, _)) = best_cte {
                        log::info!(
                            "‚úÖ Using latest CTE '{}' AS '{}' as FROM (from cte_references)",
                            cte_name,
                            alias
                        );
                        return Ok(Some(FromTable::new(Some(super::ViewTableRef {
                            source: std::sync::Arc::new(LogicalPlan::Empty),
                            name: cte_name.clone(),
                            alias: Some(alias.clone()),
                            use_final: false,
                        }))));
                    }
                }

                // SECONDARY FALLBACK: Pick first join as FROM table
                log::warn!(
                    "üîç anchor_table is None and no CTE references, using first join as FROM"
                );
                if let Some(first_join) = graph_joins.joins.first() {
                    // Check if this join has a CTE reference
                    if let Some(cte_name) =
                        graph_joins.cte_references.get(&first_join.table_alias)
                    {
                        log::info!(
                            "‚úÖ Using first join '{}' ‚Üí CTE '{}' as FROM",
                            first_join.table_alias,
                            cte_name
                        );
                        return Ok(Some(FromTable::new(Some(super::ViewTableRef {
                            source: std::sync::Arc::new(LogicalPlan::Empty),
                            name: cte_name.clone(),
                            alias: Some(first_join.table_alias.clone()),
                            use_final: false,
                        }))));
                    } else {
                        log::info!(
                            "‚úÖ Using first join '{}' (table '{}') as FROM",
                            first_join.table_alias,
                            first_join.table_name
                        );
                        return Ok(Some(FromTable::new(Some(super::ViewTableRef {
                            source: std::sync::Arc::new(LogicalPlan::Empty),
                            name: first_join.table_name.clone(),
                            alias: Some(first_join.table_alias.clone()),
                            use_final: false,
                        }))));
                    }
                }
            }

            // If we still can't find FROM, this is a real bug
            log::error!("‚ùå BUG: GraphJoins has {} joins but NO FROM marker and couldn't resolve anchor! anchor_table={:?}",
                graph_joins.joins.len(), graph_joins.anchor_table);
            for (i, join) in graph_joins.joins.iter().enumerate() {
                log::error!(
                    "  join[{}]: table='{}' alias='{}' conditions={}",
                    i,
                    join.table_name,
                    join.table_alias,
                    join.joining_on.len()
                );
            }

            // Return None to surface the bug
            None
        }
        LogicalPlan::GroupBy(group_by) => {
            from_table_to_view_ref(extract_from(&group_by.input)?)
        }
        LogicalPlan::OrderBy(order_by) => {
            from_table_to_view_ref(extract_from(&order_by.input)?)
        }
        LogicalPlan::Skip(skip) => from_table_to_view_ref(extract_from(&skip.input)?),
        LogicalPlan::Limit(limit) => from_table_to_view_ref(extract_from(&limit.input)?),
        LogicalPlan::Cte(cte) => from_table_to_view_ref(extract_from(&cte.input)?),
        LogicalPlan::Union(_) => None,
        LogicalPlan::PageRank(_) => None,
        LogicalPlan::Unwind(u) => from_table_to_view_ref(extract_from(&u.input)?),
        LogicalPlan::CartesianProduct(cp) => {
            // Try left side first (for most queries)
            let left_from = extract_from(&cp.left)?;
            if left_from.is_some() {
                // Left has a table, use it (normal case)
                from_table_to_view_ref(left_from)
            } else {
                // Left has no FROM (e.g., WITH clause creating a CTE)
                // Use right side as FROM source (e.g., new MATCH after WITH)
                log::info!(
                    "CartesianProduct: Left side has no FROM (likely CTE), using right side"
                );
                from_table_to_view_ref(extract_from(&cp.right)?)
            }
        }
        LogicalPlan::WithClause(wc) => from_table_to_view_ref(extract_from(&wc.input)?),
    };
    Ok(view_ref_to_from_table(from_ref))
}

pub fn find_all_with_clauses_grouped(
    plan: &LogicalPlan,
) -> std::collections::HashMap<String, Vec<LogicalPlan>> {
    use crate::query_planner::logical_expr::LogicalExpr;
    use crate::query_planner::logical_plan::ProjectionItem;
    use std::collections::HashMap;

    /// Extract the alias from a WITH projection item.
    /// Priority: explicit col_alias > inferred from expression (variable name, table alias)
    /// Note: Strips ".*" suffix from col_alias (e.g., "friend.*" -> "friend")
    fn extract_with_alias(item: &ProjectionItem) -> Option<String> {
        // First check for explicit alias
        if let Some(ref alias) = item.col_alias {
            // Strip ".*" suffix if present (added by projection_tagging.rs for node expansions)
            let clean_alias = alias.0.strip_suffix(".*").unwrap_or(&alias.0).to_string();
            log::info!(
                "üîç extract_with_alias: Found explicit col_alias: {} -> {}",
                alias.0,
                clean_alias
            );
            return Some(clean_alias);
        }

        // Try to infer from expression
        log::info!(
            "üîç extract_with_alias: Expression type: {:?}",
            std::mem::discriminant(&item.expression)
        );
        extract_alias_from_expr(&item.expression)
    }

    /// Generate a unique key for a WITH clause based on all its projection items.
    /// This allows distinguishing "WITH friend" from "WITH friend, post".
    /// Generate a unique key for a WithClause based on its exported aliases or projection items.
    fn generate_with_key_from_with_clause(
        wc: &crate::query_planner::logical_plan::WithClause,
    ) -> String {
        // First try exported_aliases (preferred, already computed)
        if !wc.exported_aliases.is_empty() {
            let mut aliases = wc.exported_aliases.clone();
            aliases.sort();
            return aliases.join("_");
        }
        // Fall back to extracting from items
        let mut aliases: Vec<String> = wc
            .items
            .iter()
            .filter_map(extract_with_alias)
            .filter(|a| a != "*")
            .collect();
        aliases.sort();
        if aliases.is_empty() {
            "with_var".to_string()
        } else {
            aliases.join("_")
        }
    }

    /// Find the first WITH clause key in a plan subtree (non-recursive into Union)
    fn find_first_with_key(plan: &LogicalPlan) -> Option<String> {
        match plan {
            // NEW: Handle WithClause type
            LogicalPlan::WithClause(wc) => Some(generate_with_key_from_with_clause(wc)),
            LogicalPlan::GraphRel(graph_rel) => {
                // Check for WithClause in right
                if let LogicalPlan::WithClause(wc) = graph_rel.right.as_ref() {
                    return Some(generate_with_key_from_with_clause(wc));
                }
                // Check for WithClause in left
                if let LogicalPlan::WithClause(wc) = graph_rel.left.as_ref() {
                    return Some(generate_with_key_from_with_clause(wc));
                }
                if let LogicalPlan::GraphJoins(gj) = graph_rel.right.as_ref() {
                    if let LogicalPlan::WithClause(wc) = gj.input.as_ref() {
                        return Some(generate_with_key_from_with_clause(wc));
                    }
                }
                None
            }
            LogicalPlan::GraphJoins(gj) => find_first_with_key(&gj.input),
            LogicalPlan::Filter(f) => find_first_with_key(&f.input),
            _ => None,
        }
    }

    fn find_all_with_clauses_impl(plan: &LogicalPlan, results: &mut Vec<(LogicalPlan, String)>) {
        log::info!(
            "üîç find_all_with_clauses_impl: Checking plan type: {:?}",
            std::mem::discriminant(plan)
        );
        match plan {
            // NEW: Handle WithClause type directly
            LogicalPlan::WithClause(wc) => {
                let alias = generate_with_key_from_with_clause(wc);
                log::info!(
                    "üîç find_all_with_clauses_impl: Found WithClause directly, key='{}'",
                    alias
                );
                results.push((plan.clone(), alias));
                // Recurse into input to find nested WITH clauses
                // They will be processed innermost-first due to sorting by underscore count
                find_all_with_clauses_impl(&wc.input, results);
            }
            LogicalPlan::GraphRel(graph_rel) => {
                // NEW: Check for WithClause in right
                if let LogicalPlan::WithClause(wc) = graph_rel.right.as_ref() {
                    let key = generate_with_key_from_with_clause(wc);
                    let alias = if key == "with_var" {
                        graph_rel.right_connection.clone()
                    } else {
                        key
                    };
                    log::info!("üîç find_all_with_clauses_impl: Found WithClause in GraphRel.right, key='{}' (connection='{}')",
                               alias, graph_rel.right_connection);
                    results.push((graph_rel.right.as_ref().clone(), alias));
                    find_all_with_clauses_impl(&wc.input, results);
                    return;
                }
                // NEW: Check for WithClause in left
                if let LogicalPlan::WithClause(wc) = graph_rel.left.as_ref() {
                    let key = generate_with_key_from_with_clause(wc);
                    let alias = if key == "with_var" {
                        graph_rel.left_connection.clone()
                    } else {
                        key
                    };
                    log::info!("üîç find_all_with_clauses_impl: Found WithClause in GraphRel.left, key='{}' (connection='{}')",
                               alias, graph_rel.left_connection);
                    results.push((graph_rel.left.as_ref().clone(), alias));
                    find_all_with_clauses_impl(&wc.input, results);
                    return;
                }
                // Also check GraphJoins wrapped inside GraphRel
                if let LogicalPlan::GraphJoins(gj) = graph_rel.right.as_ref() {
                    // NEW: Check for WithClause in GraphJoins
                    if let LogicalPlan::WithClause(wc) = gj.input.as_ref() {
                        let key = generate_with_key_from_with_clause(wc);
                        let alias = if key == "with_var" {
                            graph_rel.right_connection.clone()
                        } else {
                            key
                        };
                        log::info!("üîç find_all_with_clauses_impl: Found WithClause in GraphJoins inside GraphRel.right, key='{}' (connection='{}')",
                                   alias, graph_rel.right_connection);
                        results.push((gj.input.as_ref().clone(), alias));
                        find_all_with_clauses_impl(&wc.input, results);
                        return;
                    }
                }
                if let LogicalPlan::GraphJoins(gj) = graph_rel.left.as_ref() {
                    // NEW: Check for WithClause in GraphJoins on left
                    if let LogicalPlan::WithClause(wc) = gj.input.as_ref() {
                        let key = generate_with_key_from_with_clause(wc);
                        let alias = if key == "with_var" {
                            graph_rel.left_connection.clone()
                        } else {
                            key
                        };
                        log::info!("üîç find_all_with_clauses_impl: Found WithClause in GraphJoins inside GraphRel.left, key='{}' (connection='{}')",
                                   alias, graph_rel.left_connection);
                        results.push((gj.input.as_ref().clone(), alias));
                        find_all_with_clauses_impl(&wc.input, results);
                        return;
                    }
                }
                find_all_with_clauses_impl(&graph_rel.left, results);
                find_all_with_clauses_impl(&graph_rel.right, results);
            }
            LogicalPlan::Projection(proj) => {
                find_all_with_clauses_impl(&proj.input, results);
            }
            LogicalPlan::Filter(filter) => find_all_with_clauses_impl(&filter.input, results),
            LogicalPlan::GroupBy(group_by) => find_all_with_clauses_impl(&group_by.input, results),
            LogicalPlan::GraphJoins(graph_joins) => {
                find_all_with_clauses_impl(&graph_joins.input, results)
            }
            LogicalPlan::Limit(limit) => find_all_with_clauses_impl(&limit.input, results),
            LogicalPlan::OrderBy(order_by) => find_all_with_clauses_impl(&order_by.input, results),
            LogicalPlan::Skip(skip) => find_all_with_clauses_impl(&skip.input, results),
            LogicalPlan::Union(union) => {
                // For Union (bidirectional patterns), check if WITH clauses exist inside.
                // If so, the entire Union should be treated as a single WITH-bearing structure,
                // not collected multiple times from each branch.
                //
                // Strategy: Check if all branches have matching WITH clauses (same key).
                // If yes, collect the WITH key but note that the Union itself needs to be rendered.
                // If branches have different WITH structures, recurse into each.

                let mut branch_with_keys: Vec<Option<String>> = Vec::new();
                for input in &union.inputs {
                    // Find the first Projection(With) in this branch
                    if let Some(key) = find_first_with_key(input) {
                        branch_with_keys.push(Some(key));
                    } else {
                        branch_with_keys.push(None);
                    }
                }

                // Check if all branches have the same WITH key
                let first_key = branch_with_keys.first().and_then(|k| k.clone());
                let all_same = branch_with_keys.iter().all(|k| k == &first_key);

                if all_same && first_key.is_some() {
                    // All branches have the same WITH key - this is a bidirectional pattern
                    // Collect from just the first branch to avoid duplicates
                    // The Union structure will be preserved when we render the parent GraphRel
                    log::info!("üîç find_all_with_clauses_impl: Union has matching WITH key '{}' in all branches, collecting from first only",
                               first_key.as_ref().unwrap());
                    if let Some(first_input) = union.inputs.first() {
                        find_all_with_clauses_impl(first_input, results);
                    }
                } else {
                    // Branches have different WITH structures - recurse into each
                    for input in &union.inputs {
                        find_all_with_clauses_impl(input, results);
                    }
                }
            }
            LogicalPlan::CartesianProduct(cp) => {
                // CartesianProduct is used for WITH...MATCH patterns where aliases don't overlap
                // Check both sides for WITH clauses
                log::info!(
                    "üîç find_all_with_clauses_impl: Checking CartesianProduct left and right"
                );
                find_all_with_clauses_impl(&cp.left, results);
                find_all_with_clauses_impl(&cp.right, results);
            }
            _ => {}
        }
    }

    let mut all_withs: Vec<(LogicalPlan, String)> = Vec::new();
    find_all_with_clauses_impl(plan, &mut all_withs);

    // Group by alias
    let mut grouped: HashMap<String, Vec<LogicalPlan>> = HashMap::new();
    for (plan, alias) in all_withs {
        grouped.entry(alias).or_default().push(plan);
    }

    log::info!(
        "üîç find_all_with_clauses_grouped: Found {} unique aliases with {} total WITH clauses",
        grouped.len(),
        grouped.values().map(|v| v.len()).sum::<usize>()
    );
    for (alias, plans) in &grouped {
        log::info!("üîç   alias '{}': {} WITH clause(s)", alias, plans.len());
    }

    grouped
}

/// Build chained WITH clause CTE plan with iterative processing.
///
/// This function handles complex WITH clause patterns including:
/// - Chained WITH clauses (WITH a WITH b WITH c)
/// - Union branches with different WITH clauses
/// - Passthrough WITH clauses that just reference existing CTEs
/// - Nested WITH processing with schema extraction
///
/// The function iteratively processes WITH clauses until none remain,
/// building CTEs progressively and handling complex alias relationships.
///
/// # Arguments
/// * `plan` - The logical plan containing WITH clauses
/// * `schema` - Graph schema for table resolution
/// * `plan_ctx` - Optional PlanCtx for property requirements
///
/// # Returns
/// RenderPlan with all WITH clauses converted to CTEs
pub fn build_chained_with_match_cte_plan(
    plan: &LogicalPlan,
    schema: &GraphSchema,
    plan_ctx: Option<&PlanCtx>,
) -> RenderPlanBuilderResult<RenderPlan> {
    use super::CteContent;

    const MAX_WITH_ITERATIONS: usize = 10; // Safety limit to prevent infinite loops

    let mut current_plan = plan.clone();
    let mut all_ctes: Vec<Cte> = Vec::new();
    let mut iteration = 0;

    // Track CTE schemas: map CTE name to:
    // 1. Vec<SelectItem>: Column definitions
    // 2. Vec<String>: Property names
    // 3. HashMap<String, String>: alias ‚Üí ID column name
    // 4. HashMap<(String, String), String>: (alias, property) ‚Üí CTE column name (EXPLICIT MAPPING)
    let mut cte_schemas: std::collections::HashMap<
        String,
        (
            Vec<SelectItem>,                   // SELECT items
            Vec<String>,                       // Property names
            HashMap<String, String>,           // alias ‚Üí ID column
            HashMap<(String, String), String>, // (alias, property) ‚Üí column_name
        ),
    > = std::collections::HashMap::new();

    // Track aliases that have been converted to CTEs across ALL iterations
    // This prevents re-processing the same alias in subsequent iterations
    // (important for chained WITH like `WITH DISTINCT fof WITH fof`)
    let mut processed_cte_aliases: std::collections::HashSet<String> =
        std::collections::HashSet::new();

    // Track sequence numbers for each alias to generate unique CTE names
    // Maps alias ‚Üí next sequence number (e.g., "a" ‚Üí 3 means next CTE is with_a_cte_3)
    let mut cte_sequence_numbers: std::collections::HashMap<String, usize> =
        std::collections::HashMap::new();

    // Track CTE references as we build them (alias ‚Üí CTE name)
    // Start EMPTY and populate as each CTE is created
    // This ensures we only reference CTEs that have actually been built in previous iterations
    let mut cte_references: std::collections::HashMap<String, String> =
        std::collections::HashMap::new();

    // Track CTE name remapping for passthrough WITHs
    // When analyzer generates multiple CTE names for the same alias chain (e.g., with_name_cte_1, with_name_cte_2),
    // but we skip creating duplicate CTEs, we need to remap the phantom names to the actual name.
    // Maps: analyzer_cte_name ‚Üí actual_cte_name (e.g., "with_name_cte_2" ‚Üí "with_name_cte_1")
    let mut cte_name_remapping: std::collections::HashMap<String, String> =
        std::collections::HashMap::new();

    log::warn!("üîß build_chained_with_match_cte_plan: Starting iterative WITH processing");

    // Process WITH clauses iteratively until none remain
    while has_with_clause_in_graph_rel(&current_plan) {
        iteration += 1;
        log::warn!(
            "üîß build_chained_with_match_cte_plan: ========== ITERATION {} ==========",
            iteration
        );
        if iteration > MAX_WITH_ITERATIONS {
            return Err(RenderBuildError::InvalidRenderPlan(format!(
                "Exceeded maximum WITH clause iterations ({})",
                MAX_WITH_ITERATIONS
            )));
        }

        log::warn!(
            "üîß build_chained_with_match_cte_plan: Iteration {} - processing WITH clause",
            iteration
        );

        // Find ALL WITH clauses grouped by alias
        // This handles Union branches that each have their own WITH clause with the same alias
        // Note: We collect the data without holding references across the mutation
        let grouped_withs = find_all_with_clauses_grouped(&current_plan);

        log::warn!("üîß build_chained_with_match_cte_plan: Found {} alias groups from find_all_with_clauses_grouped", grouped_withs.len());
        for (alias, plans) in &grouped_withs {
            log::warn!(
                "üîß build_chained_with_match_cte_plan:   Alias '{}': {} plan(s)",
                alias,
                plans.len()
            );
        }

        if grouped_withs.is_empty() {
            log::warn!("üîß build_chained_with_match_cte_plan: has_with_clause_in_graph_rel returned true but no WITH clauses found");
            break;
        }

        // CRITICAL: Collect ALL analyzer CTE names from ALL WITH clauses in the plan tree
        // This includes nested WITHs that will be collapsed later. We need to record
        // the analyzer's CTE names now so we can remap them after collapsing.
        fn collect_analyzer_cte_names(
            plan: &LogicalPlan,
            names: &mut std::collections::HashSet<String>,
        ) {
            match plan {
                LogicalPlan::WithClause(wc) => {
                    for (_alias, cte_name) in &wc.cte_references {
                        names.insert(cte_name.clone());
                    }
                    collect_analyzer_cte_names(&wc.input, names);
                }
                LogicalPlan::Projection(proj) => collect_analyzer_cte_names(&proj.input, names),
                LogicalPlan::Filter(f) => collect_analyzer_cte_names(&f.input, names),
                LogicalPlan::GroupBy(gb) => collect_analyzer_cte_names(&gb.input, names),
                LogicalPlan::OrderBy(ob) => collect_analyzer_cte_names(&ob.input, names),
                LogicalPlan::Limit(lim) => collect_analyzer_cte_names(&lim.input, names),
                LogicalPlan::Skip(skip) => collect_analyzer_cte_names(&skip.input, names),
                LogicalPlan::Union(u) => {
                    for input in &u.inputs {
                        collect_analyzer_cte_names(input, names);
                    }
                }
                _ => {}
            }
        }

        let mut all_analyzer_cte_names: std::collections::HashSet<String> =
            std::collections::HashSet::new();
        collect_analyzer_cte_names(&current_plan, &mut all_analyzer_cte_names);
        log::info!(
            "üîß build_chained_with_match_cte_plan: Collected {} analyzer CTE names: {:?}",
            all_analyzer_cte_names.len(),
            all_analyzer_cte_names
        );

        // CRITICAL FIX: For aliases with multiple WITH clauses (nested consecutive WITH with same alias),
        // we should only process the INNERMOST one per iteration. The others will be processed
        // in subsequent iterations after the inner one is converted to a CTE.
        //
        // Filter strategy: For each alias, only keep the WITH clause whose input has NO nested WITH clauses.
        // This is the "innermost" WITH that should be processed first.
        let mut filtered_grouped_withs: std::collections::HashMap<String, Vec<LogicalPlan>> =
            std::collections::HashMap::new();

        for (alias, plans) in grouped_withs {
            // Record original count before filtering
            let original_count = plans.len();

            // Find plans that are innermost (no nested WITH in their input)
            let innermost_plans: Vec<LogicalPlan> = plans
                .into_iter()
                .filter(|plan| {
                    if let LogicalPlan::WithClause(wc) = plan {
                        let has_nested = has_with_clause_in_graph_rel(&wc.input);
                        if has_nested {
                            log::warn!("üîß build_chained_with_match_cte_plan: Skipping WITH '{}' with nested WITH clauses (will process in next iteration)", alias);
                        } else {
                            log::warn!("üîß build_chained_with_match_cte_plan: Keeping innermost WITH '{}' for processing", alias);
                        }
                        !has_nested
                    } else {
                        log::warn!("üîß build_chained_with_match_cte_plan: Plan for alias '{}' is not WithClause: {:?}", alias, std::mem::discriminant(plan));
                        true  // Not a WithClause, keep it
                    }
                })
                .collect();

            if !innermost_plans.is_empty() {
                log::warn!("üîß build_chained_with_match_cte_plan: Alias '{}': filtered {} plan(s) to {} innermost",
                           alias, original_count, innermost_plans.len());
                filtered_grouped_withs.insert(alias, innermost_plans);
            } else {
                log::warn!("üîß build_chained_with_match_cte_plan: Alias '{}': NO innermost plans after filtering {} total",
                           alias, original_count);
            }
        }

        // Collect alias info for processing (to avoid holding references across mutation)
        let mut aliases_to_process: Vec<(String, usize)> = filtered_grouped_withs
            .iter()
            .map(|(alias, plans)| (alias.clone(), plans.len()))
            .collect();

        // Sort aliases to process innermost first (simpler names = fewer underscores = more inner)
        // This ensures "friend" is processed before "friend_post"
        aliases_to_process.sort_by(|a, b| {
            let a_depth = a.0.matches('_').count();
            let b_depth = b.0.matches('_').count();
            a_depth.cmp(&b_depth)
        });
        log::info!(
            "üîß build_chained_with_match_cte_plan: Sorted aliases: {:?}",
            aliases_to_process
                .iter()
                .map(|(a, _)| a)
                .collect::<Vec<_>>()
        );

        // Track if any alias was actually processed in this iteration
        let mut any_processed_this_iteration = false;

        // Process each alias group
        // For aliases with multiple WITH clauses (from Union branches), combine them with UNION ALL
        'alias_loop: for (with_alias, plan_count) in aliases_to_process {
            log::info!(
                "üîß build_chained_with_match_cte_plan: Processing {} WITH clause(s) for alias '{}'",
                plan_count,
                with_alias
            );

            // CRITICAL: Create a snapshot of cte_references that only includes CTEs from PREVIOUS iterations
            // Do NOT include the CTE we're about to build for this alias!
            // This prevents resolve_cte_reference from using future CTEs that don't exist yet
            let mut cte_references_for_rendering = cte_references.clone();
            log::info!(
                "üîß build_chained_with_match_cte_plan: cte_references for rendering '{}': {:?}",
                with_alias,
                cte_references_for_rendering
            );

            // Get the WITH plans from our filtered map
            let with_plans = match filtered_grouped_withs.get(&with_alias) {
                Some(plans) => {
                    log::info!(
                        "üîß build_chained_with_match_cte_plan: Found {} plan(s) for alias '{}' in filtered map",
                        plans.len(),
                        with_alias
                    );
                    plans.clone() // Clone the Vec<LogicalPlan> to avoid moving from borrowed data
                }
                None => {
                    log::info!("üîß build_chained_with_match_cte_plan: Alias '{}' not in filtered map (all WITH clauses had nested WITH), skipping", with_alias);
                    continue;
                }
            };

            // CRITICAL: Update cte_references for ALL plans BEFORE rendering them
            // GraphRel nodes inside these plans need to know about available CTEs
            // Use the snapshot from PREVIOUS iterations only (not including current alias)
            log::info!("üîß build_chained_with_match_cte_plan: Updating cte_references for {} plans before rendering. Using previous CTEs: {:?}", with_plans.len(), cte_references_for_rendering);

            // DEBUG: Check what cte_references exist in with_plans BEFORE update
            for (idx, plan) in with_plans.iter().enumerate() {
                if let LogicalPlan::WithClause(wc) = plan {
                    eprintln!("üîçüîçüîç BEFORE update_graph_joins_cte_refs: with_plans[{}] WithClause has {} cte_references: {:?}",
                              idx, wc.cte_references.len(), wc.cte_references);
                }
            }

            let with_plans: Vec<LogicalPlan> = with_plans
                .into_iter()
                .map(|plan| update_graph_joins_cte_refs(&plan, &cte_references_for_rendering))
                .collect::<Result<Vec<_>, _>>()?;

            // DEBUG: Check what cte_references exist in with_plans AFTER update
            for (idx, plan) in with_plans.iter().enumerate() {
                if let LogicalPlan::WithClause(wc) = plan {
                    eprintln!("üîçüîçüîç AFTER update_graph_joins_cte_refs: with_plans[{}] WithClause has {} cte_references: {:?}",
                              idx, wc.cte_references.len(), wc.cte_references);
                }
            }

            // Collect aliases from the pre-WITH scope (inside the WITH clauses)
            // These aliases should be filtered out from the outer query's joins
            let mut pre_with_aliases = std::collections::HashSet::new();
            for with_plan in with_plans.iter() {
                // For Projection(With), the input contains the pre-WITH pattern
                if let LogicalPlan::Projection(proj) = with_plan {
                    let inner_aliases = collect_aliases_from_plan(&proj.input);
                    pre_with_aliases.extend(inner_aliases);
                }
            }
            // Don't filter out the WITH variable itself - it's the boundary variable
            pre_with_aliases.remove(&with_alias);
            // Don't filter out aliases that are already CTEs (processed in earlier iterations)
            // These are now references to CTEs, not original tables
            for cte_alias in &processed_cte_aliases {
                if pre_with_aliases.remove(cte_alias) {
                    log::info!("üîß build_chained_with_match_cte_plan: Keeping '{}' (already a CTE reference)", cte_alias);
                }
            }
            log::info!(
                "üîß build_chained_with_match_cte_plan: Pre-WITH aliases to filter: {:?}",
                pre_with_aliases
            );

            /// Check if a plan is a CTE reference (ViewScan or GraphNode wrapping ViewScan with table starting with "with_")
            fn is_cte_reference(plan: &LogicalPlan) -> Option<String> {
                match plan {
                    LogicalPlan::ViewScan(vs) if vs.source_table.starts_with("with_") => {
                        Some(vs.source_table.clone())
                    }
                    LogicalPlan::GraphNode(gn) => {
                        if let LogicalPlan::ViewScan(vs) = gn.input.as_ref() {
                            if vs.source_table.starts_with("with_") {
                                return Some(vs.source_table.clone());
                            }
                        }
                        None
                    }
                    _ => None,
                }
            }

            // Render each WITH clause plan
            let mut rendered_plans: Vec<RenderPlan> = Vec::new();
            for with_plan in with_plans.iter() {
                log::info!("üîß build_chained_with_match_cte_plan: Rendering WITH plan for '{}' - plan type: {:?}",
                           with_alias, std::mem::discriminant(with_plan));

                // Check if this is a passthrough WITH whose input is already a CTE reference
                // E.g., `WITH fof` after `WITH DISTINCT fof` - the second WITH just passes through
                // Skip creating another CTE and use the existing one
                if let LogicalPlan::WithClause(wc) = with_plan {
                    if let Some(existing_cte) = is_cte_reference(&wc.input) {
                        // Check if this is a simple passthrough (same alias, no modifications)
                        let is_simple_passthrough = wc.items.len() == 1
                            && wc.order_by.is_none()
                            && wc.skip.is_none()
                            && wc.limit.is_none()
                            && !wc.distinct
                            && wc.where_clause.is_none()  // CRITICAL: WHERE clause makes it not a passthrough!
                            && matches!(
                                &wc.items[0].expression,
                                crate::query_planner::logical_expr::LogicalExpr::TableAlias(_)
                            );

                        log::warn!("üîß build_chained_with_match_cte_plan: Checking passthrough: items={}, order_by={}, skip={}, limit={}, distinct={}, where_clause={}, is_table_alias={}, is_passthrough={}",
                                   wc.items.len(), wc.order_by.is_some(), wc.skip.is_some(), wc.limit.is_some(), wc.distinct,
                                   wc.where_clause.is_some(),
                                   matches!(&wc.items[0].expression, crate::query_planner::logical_expr::LogicalExpr::TableAlias(_)),
                                   is_simple_passthrough);

                        if is_simple_passthrough {
                            log::warn!("üîß build_chained_with_match_cte_plan: Skipping passthrough WITH for '{}' - input is already CTE '{}'",
                                       with_alias, existing_cte);

                            // CRITICAL FIX: Update cte_references to map the skipped WITH's aliases
                            // to the actual CTE name. This ensures the final SELECT uses the correct CTE.
                            //
                            // Problem: Analyzer generates unique CTE names for each WITH clause
                            //   (e.g., with_name_cte_1, with_name_cte_2), but when passthrough WITHs
                            //   are skipped, the outer expressions still reference the skipped WITH's CTE name.
                            //
                            // Solution: Map all exported aliases of the skipped WITH to the existing CTE.
                            // ALSO: Extract the analyzer's CTE name for this WITH to collapse it properly.
                            let mut analyzer_cte_name_for_collapse: Option<String> = None;
                            for alias in &wc.exported_aliases {
                                log::info!(
                                    "üîß build_chained_with_match_cte_plan: Mapping skipped alias '{}' ‚Üí existing CTE '{}'",
                                    alias, existing_cte
                                );
                                cte_references.insert(alias.clone(), existing_cte.clone());

                                // Also record CTE name remapping: analyzer's CTE name ‚Üí actual CTE name
                                // The analyzer assigned a unique CTE name to this WITH, but we're skipping it.
                                // We need to remap expressions that reference the analyzer's name.
                                log::warn!(
                                    "üîß DEBUG: wc.cte_references = {:?}, looking for alias '{}'",
                                    wc.cte_references,
                                    alias
                                );
                                if let Some(analyzer_cte_name) = wc.cte_references.get(alias) {
                                    log::warn!(
                                        "üîß DEBUG: Found analyzer_cte_name '{}', existing_cte = '{}'",
                                        analyzer_cte_name, existing_cte
                                    );
                                    if analyzer_cte_name != &existing_cte {
                                        log::info!(
                                            "üîß build_chained_with_match_cte_plan: Recording CTE name remap: '{}' ‚Üí '{}'",
                                            analyzer_cte_name, existing_cte
                                        );
                                        cte_name_remapping.insert(
                                            analyzer_cte_name.clone(),
                                            existing_cte.clone(),
                                        );
                                        analyzer_cte_name_for_collapse =
                                            Some(analyzer_cte_name.clone());
                                    }
                                }
                            }

                            // CRITICAL FIX: Remove the passthrough WITH from current_plan!
                            // The passthrough WITH just wraps a CTE reference, so collapse it
                            // by replacing the WITH with its input (the CTE reference).
                            // Use the analyzer's CTE name to target the exact WITH clause.
                            let target_cte =
                                analyzer_cte_name_for_collapse.as_deref().unwrap_or("");
                            log::warn!(
                                "üîß build_chained_with_match_cte_plan: Collapsing passthrough WITH for '{}' with CTE '{}'",
                                with_alias, target_cte
                            );
                            current_plan =
                                collapse_passthrough_with(&current_plan, &with_alias, target_cte)?;
                            log::warn!(
                                "üîß build_chained_with_match_cte_plan: After collapse, plan discriminant: {:?}",
                                std::mem::discriminant(&current_plan)
                            );

                            // Mark that we processed something (collapsing passthrough is processing)
                            any_processed_this_iteration = true;

                            // CRITICAL: Break out of BOTH loops to restart iteration.
                            // We modified current_plan, so we need to re-run find_all_with_clauses_grouped.
                            // Using a labeled break to exit the outer for loop too.
                            break 'alias_loop;
                        }
                    }
                }

                // Extract the plan to render, WITH items, and modifiers (ORDER BY, SKIP, LIMIT, WHERE)
                // CRITICAL: Also extract CTE references from this WITH's input - these tell us which
                // variables come from previous CTEs in the chain
                let (
                    plan_to_render,
                    with_items,
                    with_distinct,
                    with_order_by,
                    with_skip,
                    with_limit,
                    with_where_clause,
                    with_cte_refs,
                ) = match with_plan {
                    LogicalPlan::WithClause(wc) => {
                        log::info!("ÔøΩ DEBUG: Unwrapping WithClause for alias '{}'", with_alias);
                        log::info!("üêõ DEBUG: WithClause has {} items", wc.items.len());
                        for (i, item) in wc.items.iter().enumerate() {
                            log::info!("üêõ DEBUG: wc.items[{}]: {:?}", i, item);
                        }
                        log::info!("ÔøΩüîß build_chained_with_match_cte_plan: Unwrapping WithClause, rendering input");
                        log::info!(
                            "üîß build_chained_with_match_cte_plan: wc.input type: {:?}",
                            std::mem::discriminant(wc.input.as_ref())
                        );

                        // Use CTE references from this WithClause (populated by analyzer)
                        let input_cte_refs = wc.cte_references.clone();
                        log::info!(
                            "üîß build_chained_with_match_cte_plan: CTE refs from WithClause: {:?}",
                            input_cte_refs
                        );
                        log::info!("üîß build_chained_with_match_cte_plan: wc has {} items, order_by={:?}, skip={:?}, limit={:?}, where={:?}",
                                   wc.items.len(), wc.order_by.is_some(), wc.skip, wc.limit, wc.where_clause.is_some());
                        // Debug: if it's GraphJoins, log the joins
                        if let LogicalPlan::GraphJoins(gj) = wc.input.as_ref() {
                            log::info!("üîß build_chained_with_match_cte_plan: wc.input is GraphJoins with {} joins", gj.joins.len());
                            for (i, join) in gj.joins.iter().enumerate() {
                                log::info!("üîß build_chained_with_match_cte_plan: GraphJoins join {}: table_name={}, table_alias={}, joining_on={:?}",
                                    i, join.table_name.as_str(), join.table_alias.as_str(), join.joining_on);
                            }
                        }
                        (
                            wc.input.as_ref(),
                            Some(wc.items.clone()),
                            wc.distinct,
                            wc.order_by.clone(),
                            wc.skip,
                            wc.limit,
                            wc.where_clause.clone(),
                            input_cte_refs,
                        )
                    }
                    LogicalPlan::Projection(proj) => {
                        log::info!("üîß build_chained_with_match_cte_plan: WITH projection input type: {:?}",
                                   std::mem::discriminant(proj.input.as_ref()));
                        // Check if input contains CTE reference
                        if let LogicalPlan::Filter(filter) = proj.input.as_ref() {
                            log::info!(
                                "üîß build_chained_with_match_cte_plan: Filter input type: {:?}",
                                std::mem::discriminant(filter.input.as_ref())
                            );
                        }
                        (
                            with_plan as &LogicalPlan,
                            None,
                            false,
                            None,
                            None,
                            None,
                            None,
                            std::collections::HashMap::new(),
                        )
                    }
                    _ => (
                        with_plan as &LogicalPlan,
                        None,
                        false,
                        None,
                        None,
                        None,
                        None,
                        std::collections::HashMap::new(),
                    ),
                };

                // Render the plan (even if it contains nested WITHs)
                // The recursive call will process inner WITHs first, then we hoist their CTEs
                match render_without_with_detection(plan_to_render, schema) {
                    Ok(mut rendered) => {
                        // CRITICAL: Extract CTE schemas from nested rendering
                        // When rendering nested WITHs, the recursive call builds CTEs that we need
                        // to reference. Extract their schemas and add to our cte_schemas map.
                        if !rendered.ctes.0.is_empty() {
                            for cte in &rendered.ctes.0 {
                                let select_items = match &cte.content {
                                    super::CteContent::Structured(plan) => match &plan.union {
                                        UnionItems(Some(union)) if !union.input.is_empty() => {
                                            union.input[0].select.items.clone()
                                        }
                                        _ => plan.select.items.clone(),
                                    },
                                    super::CteContent::RawSql(_) => {
                                        // VLP CTEs are RawSql - can't extract schema directly
                                        // But we can infer from the UNION that uses them
                                        // Skip for now, will be handled when we see the UNION
                                        log::info!("üîß Skipping RawSql CTE '{}' (VLP CTE - schema will be inferred from UNION)", cte.cte_name);
                                        continue;
                                    }
                                };
                                let property_names: Vec<String> = select_items
                                    .iter()
                                    .filter_map(|item| item.col_alias.as_ref().map(|a| a.0.clone()))
                                    .collect();

                                // Extract ID column information: map alias -> ID column name
                                // For VLP CTEs, columns are like "friend.id", "friend.firstName", "p.id", etc.
                                // We need to track that alias "friend" has ID column "id"
                                let mut alias_to_id_column: HashMap<String, String> =
                                    HashMap::new();
                                for item in &select_items {
                                    if let Some(col_alias) = &item.col_alias {
                                        let alias_str = col_alias.0.as_str();
                                        // Match pattern: "{alias}.id" or "{alias}_id"
                                        if let Some(dot_pos) = alias_str.rfind('.') {
                                            let (prefix, suffix) = alias_str.split_at(dot_pos);
                                            if suffix == ".id" {
                                                // Found ID column: "friend.id" means alias "friend" has ID "id"
                                                alias_to_id_column
                                                    .insert(prefix.to_string(), "id".to_string());
                                                log::info!("üìä CTE '{}': Found ID column for alias '{}' -> 'id'", cte.cte_name, prefix);
                                            }
                                        } else if alias_str.ends_with("_id") {
                                            // Pattern like "friend_id"
                                            let prefix = &alias_str[..alias_str.len() - 3];
                                            alias_to_id_column
                                                .insert(prefix.to_string(), "id".to_string());
                                            log::info!("üìä CTE '{}': Found ID column for alias '{}' -> 'id'", cte.cte_name, prefix);
                                        }
                                    }
                                }

                                // Build explicit property mapping
                                let property_mapping =
                                    build_property_mapping_from_columns(&select_items);

                                log::info!(
                                    "üîß build_chained_with_match_cte_plan: Extracted nested CTE schema '{}': {} columns, {} aliases with ID, {} property mappings",
                                    cte.cte_name, property_names.len(), alias_to_id_column.len(), property_mapping.len()
                                );

                                cte_schemas.insert(
                                    cte.cte_name.clone(),
                                    (
                                        select_items,
                                        property_names,
                                        alias_to_id_column,
                                        property_mapping,
                                    ),
                                );
                            }
                        }

                        // Apply WithClause's ORDER BY, SKIP, LIMIT to the rendered plan
                        if let Some(order_by_items) = with_order_by {
                            log::info!("üîß build_chained_with_match_cte_plan: Applying ORDER BY from WithClause");
                            let render_order_by: Vec<OrderByItem> = order_by_items
                                .iter()
                                .filter_map(|item| {
                                    let expr_result: Result<RenderExpr, _> = item.expression.clone().try_into();
                                    expr_result.ok().map(|expr| OrderByItem {
                                        expression: expr,
                                        order: match item.order {
                                            crate::query_planner::logical_plan::OrderByOrder::Asc => OrderByOrder::Asc,
                                            crate::query_planner::logical_plan::OrderByOrder::Desc => OrderByOrder::Desc,
                                        },
                                    })
                                })
                                .collect();
                            rendered.order_by = OrderByItems(render_order_by);
                        }
                        if let Some(skip_count) = with_skip {
                            log::info!("üîß build_chained_with_match_cte_plan: Applying SKIP {} from WithClause", skip_count);
                            rendered.skip = SkipItem(Some(skip_count as i64));
                        }
                        if let Some(limit_count) = with_limit {
                            log::info!("üîß build_chained_with_match_cte_plan: Applying LIMIT {} from WithClause", limit_count);
                            rendered.limit = LimitItem(Some(limit_count as i64));
                        }

                        // Apply WHERE clause from WITH - becomes HAVING if we have GROUP BY
                        if let Some(where_predicate) = with_where_clause {
                            log::info!("üîß build_chained_with_match_cte_plan: Applying WHERE clause from WITH");

                            // Convert LogicalExpr to RenderExpr
                            let where_render_expr: RenderExpr = where_predicate.try_into()?;

                            if !rendered.group_by.0.is_empty() {
                                // We have GROUP BY - WHERE becomes HAVING
                                log::info!("üîß build_chained_with_match_cte_plan: Converting WHERE to HAVING (GROUP BY present)");
                                rendered.having_clause = Some(where_render_expr);
                            } else {
                                // No GROUP BY - WHERE stays WHERE
                                log::info!("üîß build_chained_with_match_cte_plan: Applying WHERE as WHERE clause");
                                rendered.where_clause = Some(where_render_expr);
                            }
                        }

                        // Apply WITH items (SELECT clause) if present
                        if let Some(with_items) = with_items {
                            log::info!("üîß build_chained_with_match_cte_plan: Applying {} WITH items to SELECT", with_items.len());

                            // Convert WITH items to RenderExpr
                            let mut select_items: Vec<SelectItem> = Vec::new();
                            let mut has_aggregation = false;

                            for item in with_items {
                                // Check for aggregation functions
                                if matches!(&item.expression, crate::query_planner::logical_expr::LogicalExpr::AggregateFnCall(_)) {
                                    has_aggregation = true;
                                }

                                let expr: RenderExpr = item.expression.try_into()?;
                                select_items.push(SelectItem {
                                    expression: expr,
                                    col_alias: item.col_alias.as_ref().map(|a| crate::render_plan::render_expr::ColumnAlias(a.0.clone())),
                                });
                            }

                            log::info!("üîß build_chained_with_match_cte_plan: Total select_items after expansion: {}", select_items.len());

                            if !select_items.is_empty() {
                                // For UNION plans, we need to apply projection over the union
                                // We do this by keeping the UNION structure but replacing SELECT items
                                // The union branches already have all columns, so we wrap with our projection
                                // This creates: SELECT <with_items> FROM (SELECT * FROM table1 UNION ALL SELECT * FROM table2) AS __union

                                // For both UNION and non-UNION: apply projection to SELECT
                                rendered.select = SelectItems {
                                    items: select_items,
                                    distinct: with_distinct,
                                };

                                // If there's aggregation, add GROUP BY for non-aggregate expressions
                                // PERFORMANCE: Only GROUP BY the ID column(s) for TableAlias items
                                // (non-ID columns are wrapped with ANY() above, so they don't need to be grouped)
                                //
                                // This is efficient because:
                                // 1. node_id is the primary key (unique identifier)
                                // 2. ANY() picks the single value in each group (safe for PK)
                                // 3. GROUP BY 1 column is much faster than GROUP BY 7 columns
                                if has_aggregation {
                                    let group_by_exprs: Vec<RenderExpr> = with_items.iter()
                                        .filter(|item| !matches!(&item.expression, crate::query_planner::logical_expr::LogicalExpr::AggregateFnCall(_)))
                                        .flat_map(|item| {
                                            // For TableAlias, only GROUP BY the ID column
                                            // (other columns are wrapped with ANY() in SELECT)
                                            match &item.expression {
                                                crate::query_planner::logical_expr::LogicalExpr::TableAlias(alias) => {
                                                    // Use ID-only helper for efficient GROUP BY
                                                    expand_table_alias_to_group_by_id_only(&alias.0, plan_to_render, schema, &cte_schemas, &cte_references_for_rendering)
                                                }
                                                crate::query_planner::logical_expr::LogicalExpr::ArraySubscript { array, .. } => {
                                                    // For array subscripts (e.g., labels(x)[1]), only GROUP BY the array part
                                                    // ClickHouse can't GROUP BY an array element, only the array itself
                                                    let expr_vec: Vec<RenderExpr> = (**array).clone().try_into().ok().into_iter().collect();
                                                    expr_vec
                                                }
                                                _ => {
                                                    // Not a TableAlias, convert normally
                                                    let expr_vec: Vec<RenderExpr> = item.expression.clone().try_into().ok().into_iter().collect();
                                                    expr_vec
                                                }
                                            }
                                        })
                                        .collect();
                                    rendered.group_by = GroupByExpressions(group_by_exprs);
                                }
                            }
                        }

                        rendered_plans.push(rendered);
                    }
                    Err(e) => {
                        log::error!("üîß build_chained_with_match_cte_plan: Failed to render WITH plan for '{}': {:?}", with_alias, e);
                        return Err(e);
                    }
                }
            }

            // Combine multiple rendered plans with UNION ALL if needed
            let mut combined_plan = if rendered_plans.len() == 1 {
                rendered_plans.into_iter().next().unwrap()
            } else {
                // Create UNION of all rendered plans
                let union_inputs: Vec<RenderPlan> = rendered_plans;
                let union_plan = RenderPlan {
                    select: SelectItems {
                        items: vec![], // Will be filled by WITH items above
                        distinct: false,
                    },
                    from: FromTableItem(None),
                    joins: JoinItems(vec![]),
                    filters: FilterItems(vec![]),
                    group_by: GroupByExpressions(vec![]),
                    having_clause: None,
                    order_by: OrderByItems(vec![]),
                    skip: SkipItem(None),
                    limit: LimitItem(None),
                    ctes: CteItems(vec![]),
                    array_join: ArrayJoinItem::default(),
                    union: UnionItems(Some(Union {
                        input: union_inputs,
                        union_type: UnionType::All,
                    })),
                };
                union_plan
            };

            // Generate unique CTE name for this alias
            let sequence_num = cte_sequence_numbers.entry(with_alias.clone()).or_insert(0);
            *sequence_num += 1;
            let cte_name = format!("with_{}_cte_{}", with_alias, sequence_num);

            log::info!("üîß build_chained_with_match_cte_plan: Generated CTE name '{}' for alias '{}'", cte_name, with_alias);

            // Create the CTE
            let cte = Cte::new(cte_name.clone(), CteContent::Structured(combined_plan), false);

            // Add to our CTE list
            all_ctes.push(cte);

            // Update cte_references: map the WITH alias to the CTE name
            cte_references.insert(with_alias.clone(), cte_name.clone());

            // Mark this alias as processed
            processed_cte_aliases.insert(with_alias.clone());

            // Extract schema from the CTE we just created
            let select_items = match &all_ctes.last().unwrap().content {
                CteContent::Structured(plan) => match &plan.union {
                    UnionItems(Some(union)) if !union.input.is_empty() => {
                        union.input[0].select.items.clone()
                    }
                    _ => plan.select.items.clone(),
                },
                CteContent::RawSql(_) => {
                    // Should not happen for WITH CTEs
                    vec![]
                }
            };
            let property_names: Vec<String> = select_items
                .iter()
                .filter_map(|item| item.col_alias.as_ref().map(|a| a.0.clone()))
                .collect();

            // Extract ID column information
            let mut alias_to_id_column: HashMap<String, String> = HashMap::new();
            for item in &select_items {
                if let Some(col_alias) = &item.col_alias {
                    let alias_str = col_alias.0.as_str();
                    if let Some(dot_pos) = alias_str.rfind('.') {
                        let (prefix, suffix) = alias_str.split_at(dot_pos);
                        if suffix == ".id" {
                            alias_to_id_column.insert(prefix.to_string(), "id".to_string());
                            log::info!("üìä CTE '{}': Found ID column for alias '{}' -> 'id'", cte_name, prefix);
                        }
                    } else if alias_str.ends_with("_id") {
                        let prefix = &alias_str[..alias_str.len() - 3];
                        alias_to_id_column.insert(prefix.to_string(), "id".to_string());
                        log::info!("üìä CTE '{}': Found ID column for alias '{}' -> 'id'", cte_name, prefix);
                    }
                }
            }

            // Build property mapping
            let property_mapping = build_property_mapping_from_columns(&select_items);

            log::info!(
                "üîß build_chained_with_match_cte_plan: Extracted CTE schema '{}': {} columns, {} aliases with ID, {} property mappings",
                cte_name, property_names.len(), alias_to_id_column.len(), property_mapping.len()
            );

            cte_schemas.insert(
                cte_name,
                (
                    select_items,
                    property_names,
                    alias_to_id_column,
                    property_mapping,
                ),
            );

            // Mark that we processed something
            any_processed_this_iteration = true;
        }

        // If we didn't process anything in this iteration, break to avoid infinite loop
        if !any_processed_this_iteration {
            log::warn!("üîß build_chained_with_match_cte_plan: No aliases processed in iteration {}, breaking", iteration);
            break;
        }

        // Update the current plan to reflect the CTE references we just added
        log::info!("üîß build_chained_with_match_cte_plan: Updating current_plan with new CTE references: {:?}", cte_references);
        current_plan = update_graph_joins_cte_refs(&current_plan, &cte_references)?;
    }

    // Render the final plan (now without any WITH clauses)
    let mut render_plan = render_without_with_detection(&current_plan, schema)?;

    // Add all accumulated CTEs to the final plan
    all_ctes.extend(render_plan.ctes.0.into_iter());
    render_plan.ctes = CteItems(all_ctes);

    // Skip validation - CTEs are hoisted progressively through recursion
    // ClickHouse will validate CTE references when executing the SQL
    // Validation here causes false failures when nested calls reference outer CTEs
    // that haven't been hoisted yet but will be present in the final SQL

    // Apply VLP alias rewriting for path functions in WITH clauses
    // This fixes "Unknown expression identifier `t.hop_count`" errors where
    // length(path) was converted to t.hop_count but t needs to be rewritten to the actual VLP alias
    rewrite_vlp_union_branch_aliases(&mut render_plan)?;

    log::info!(
        "üîß build_chained_with_match_cte_plan: Success - final plan has {} CTEs",
        render_plan.ctes.0.len()
    );

    Ok(render_plan)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_placeholder_functions() {
        // Basic tests to ensure module compiles
        assert_eq!(strip_database_prefix("test"), "test");
        // Test has_multi_type_vlp with empty plan (should return false)
        assert!(!has_multi_type_vlp(&LogicalPlan::Empty, &GraphSchema::build(1, "test".to_string(), std::collections::HashMap::new(), std::collections::HashMap::new())));
        assert_eq!(get_anchor_alias_from_plan(&LogicalPlan::Empty), None);
    }
}