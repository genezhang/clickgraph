//! Pure utility functions for plan building
//!
//! This module contains utility functions that have no dependencies on LogicalPlan
//! or complex state. These are safe to extract early in the refactoring process.
//!
//! Functions in this module should be:
//! - Pure (no side effects)
//! - Independent of LogicalPlan structure
//! - Reusable across different builder modules

use crate::graph_catalog::graph_schema::GraphSchema;
use crate::query_planner::logical_plan::LogicalPlan;
use std::collections::HashMap;
use crate::render_plan::SelectItem;

/// Build property mapping from select items for CTE column resolution.
/// Maps (alias, property) -> column_name for property access resolution.
///
/// This function handles three patterns:
/// 1. "alias.property" (dotted, used in VLP CTEs)
/// 2. "alias_property" (underscore, used in WITH CTEs)  
/// 3. No separator - aggregate column like "friends" from collect()
pub fn build_property_mapping_from_columns(
    select_items: &[SelectItem],
) -> HashMap<(String, String), String> {
    let mut property_mapping = HashMap::new();

    for item in select_items {
        if let Some(col_alias) = &item.col_alias {
            let col_name = &col_alias.0;

            // Pattern 1: "alias.property" (dotted, used in VLP CTEs)
            if let Some(dot_pos) = col_name.find('.') {
                let alias = col_name[..dot_pos].to_string();
                let property = col_name[dot_pos + 1..].to_string();
                property_mapping.insert((alias.clone(), property.clone()), col_name.clone());
                log::debug!(
                    "  Property mapping: ({}, {}) → {}",
                    alias,
                    property,
                    col_name
                );
            }
            // Pattern 2: "alias_property" (underscore, used in WITH CTEs)
            else if let Some(underscore_pos) = col_name.find('_') {
                let alias = col_name[..underscore_pos].to_string();
                let property = col_name[underscore_pos + 1..].to_string();
                property_mapping.insert((alias.clone(), property.clone()), col_name.clone());
                log::debug!(
                    "  Property mapping: ({}, {}) → {}",
                    alias,
                    property,
                    col_name
                );
            }
            // Pattern 3: No separator - aggregate column like "friends" from collect()
            // Store with empty alias so ARRAY JOIN can find it: ("", column_name) → column_name
            else {
                property_mapping.insert(("".to_string(), col_name.clone()), col_name.clone());
                log::debug!(
                    "  Property mapping (aggregate): (\"\", {}) → {}",
                    col_name,
                    col_name
                );
            }
        }
    }

    log::info!(
        "Built property mapping with {} entries",
        property_mapping.len()
    );
    property_mapping
}

/// Placeholder for extract_vlp_alias_mappings function
/// Will be moved from plan_builder.rs lines 651-789
pub fn extract_vlp_alias_mappings(_ctes: &crate::render_plan::CteItems) -> HashMap<String, String> {
    // TODO: Implement when moving from plan_builder.rs
    HashMap::new()
}

/// Placeholder for rewrite_render_expr_for_vlp function
/// Will be moved from plan_builder.rs lines 790-901
pub fn rewrite_render_expr_for_vlp(
    _expr: &mut crate::render_plan::render_expr::RenderExpr,
    _mappings: &HashMap<String, String>,
) {
    // TODO: Implement when moving from plan_builder.rs
}

/// Strip database prefix from table name (e.g., "db.table" -> "table")
pub fn strip_database_prefix(table_name: &str) -> String {
    table_name
        .rsplit_once('.')
        .map(|(_, table)| table.to_string())
        .unwrap_or_else(|| table_name.to_string())
}

/// Check if the plan contains a multi-type variable-length path that requires CTE generation.
pub fn has_multi_type_vlp(
    plan: &LogicalPlan,
    schema: &crate::graph_catalog::graph_schema::GraphSchema,
) -> bool {
    use crate::query_planner::logical_plan::LogicalPlan;

    match plan {
        LogicalPlan::GraphRel(graph_rel) => {
            // Check if it's a VLP pattern
            if graph_rel.variable_length.is_some() {
                let rel_types: Vec<String> = graph_rel.labels.clone().unwrap_or_default();
                // Use the same logic as CTE extraction
                crate::render_plan::cte_extraction::should_use_join_expansion_public(
                    graph_rel, &rel_types, schema,
                )
            } else {
                false
            }
        }
        LogicalPlan::Projection(proj) => has_multi_type_vlp(&proj.input, schema),
        LogicalPlan::Filter(filter) => has_multi_type_vlp(&filter.input, schema),
        LogicalPlan::GroupBy(gb) => has_multi_type_vlp(&gb.input, schema),
        LogicalPlan::OrderBy(order) => has_multi_type_vlp(&order.input, schema),
        LogicalPlan::Limit(limit) => has_multi_type_vlp(&limit.input, schema),
        LogicalPlan::Skip(skip) => has_multi_type_vlp(&skip.input, schema),
        LogicalPlan::GraphJoins(joins) => has_multi_type_vlp(&joins.input, schema),
        _ => false,
    }
}

/// Get the anchor alias from a logical plan (for OPTIONAL MATCH join ordering).
pub fn get_anchor_alias_from_plan(plan: &std::sync::Arc<LogicalPlan>) -> Option<String> {
    match plan.as_ref() {
        LogicalPlan::GraphNode(node) => Some(node.alias.clone()),
        LogicalPlan::GraphRel(rel) => Some(rel.left_connection.clone()),
        LogicalPlan::Projection(proj) => get_anchor_alias_from_plan(&proj.input),
        LogicalPlan::Filter(filter) => get_anchor_alias_from_plan(&filter.input),
        LogicalPlan::GroupBy(gb) => get_anchor_alias_from_plan(&gb.input),
        LogicalPlan::CartesianProduct(cp) => get_anchor_alias_from_plan(&cp.left),
        _ => None,
    }
}

/// Find the label for a given alias in the logical plan.
pub fn find_label_for_alias(plan: &LogicalPlan, target_alias: &str) -> Option<String> {
    match plan {
        LogicalPlan::GraphNode(node) => {
            if node.alias == target_alias {
                // label is Option<String>, unwrap it
                node.label.clone()
            } else {
                None
            }
        }
        LogicalPlan::GraphRel(rel) => {
            // Check left and right connections
            // Note: GraphRel doesn't have nested plans, just connection strings
            None
        }
        LogicalPlan::Filter(filter) => find_label_for_alias(&filter.input, target_alias),
        LogicalPlan::WithClause(wc) => find_label_for_alias(&wc.input, target_alias),
        LogicalPlan::Projection(proj) => find_label_for_alias(&proj.input, target_alias),
        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;

    #[test]
    fn test_strip_database_prefix() {
        assert_eq!(strip_database_prefix("db.table"), "table");
        assert_eq!(strip_database_prefix("table"), "table");
        assert_eq!(strip_database_prefix("schema.db.table"), "table");
    }

    #[test]
    fn test_get_anchor_alias_empty_plan() {
        assert_eq!(get_anchor_alias_from_plan(&Arc::new(LogicalPlan::Empty)), None);
    }
}