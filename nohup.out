
ClickGraph v0.5.5

[2025-12-21T00:52:02Z INFO  clickgraph::server] Server configuration: http=0.0.0.0:8080, bolt=0.0.0.0:7687
[2025-12-21T00:52:02Z INFO  clickgraph::server::clickhouse_client] Connecting to ClickHouse at http://localhost:8123 (database: brahmand)
[2025-12-21T00:52:02Z INFO  clickgraph::server::graph_catalog] Initializing ClickGraph schema...
[2025-12-21T00:52:02Z INFO  clickgraph::server::graph_catalog] Loading schema from GRAPH_CONFIG_PATH: ./benchmarks/social_network/schemas/social_benchmark.yaml
[2025-12-21T00:52:02Z WARN  clickgraph::graph_catalog::engine_detection] Unknown engine type: Memory
[2025-12-21T00:52:02Z INFO  clickgraph::graph_catalog::engine_detection] Table brahmand.users_bench engine Other("Memory") FINAL support verified: false
[2025-12-21T00:52:02Z WARN  clickgraph::graph_catalog::engine_detection] Unknown engine type: Memory
[2025-12-21T00:52:02Z INFO  clickgraph::graph_catalog::engine_detection] Table brahmand.posts_bench engine Other("Memory") FINAL support verified: false
[2025-12-21T00:52:02Z WARN  clickgraph::graph_catalog::engine_detection] Unknown engine type: Memory
[2025-12-21T00:52:02Z INFO  clickgraph::graph_catalog::engine_detection] Table brahmand.zeek_logs engine Other("Memory") FINAL support verified: false
[2025-12-21T00:52:02Z WARN  clickgraph::graph_catalog::engine_detection] Unknown engine type: Memory
[2025-12-21T00:52:02Z INFO  clickgraph::graph_catalog::engine_detection] Table brahmand.user_follows_bench engine Other("Memory") FINAL support verified: false
[2025-12-21T00:52:02Z WARN  clickgraph::graph_catalog::engine_detection] Unknown engine type: Memory
[2025-12-21T00:52:02Z INFO  clickgraph::graph_catalog::engine_detection] Table brahmand.posts_bench engine Other("Memory") FINAL support verified: false
[2025-12-21T00:52:02Z WARN  clickgraph::graph_catalog::engine_detection] Unknown engine type: Memory
[2025-12-21T00:52:02Z INFO  clickgraph::graph_catalog::engine_detection] Table brahmand.post_likes_bench engine Other("Memory") FINAL support verified: false
[2025-12-21T00:52:02Z INFO  clickgraph::server::graph_catalog] ‚úì Loaded schema from YAML: ./benchmarks/social_network/schemas/social_benchmark.yaml
  Registering schema with name: social_benchmark
‚úì Schema initialization complete (YAML mode, default schema registered)
[2025-12-21T00:52:02Z INFO  clickgraph::server] Initializing query cache: enabled=true, max_entries=1000, max_size_mb=100
[2025-12-21T00:52:02Z INFO  clickgraph::server] Starting HTTP server on 0.0.0.0:8080
[2025-12-21T00:52:02Z INFO  clickgraph::server] Successfully bound HTTP listener to 0.0.0.0:8080
‚úì Successfully bound HTTP listener to 0.0.0.0:8080
Starting Bolt server on 0.0.0.0:7687
Successfully bound Bolt listener to 0.0.0.0:7687
ClickGraph server is running
  HTTP API: http://0.0.0.0:8080
  Bolt Protocol: bolt://0.0.0.0:7687
Bolt server loop starting, listening for connections...
DEBUG PlanCtx::insert_table_ctx: alias='u', in_optional_match_mode=false
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::logical_plan::match_clause] ‚úì ViewScan: Resolved label 'User' to table 'users_bench'
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::logical_plan::match_clause] ‚úì Successfully created ViewScan for label 'User'
is_denormalized_scan: ViewScan.is_denormalized = false for table 'brahmand.users_bench'
is_denormalized_scan: returning false
PropertyAccess::from AST: alias='u', column='user_id'
SchemaInference: analyze_with_graph_schema called with plan: Filter(Filter { input: GraphNode(GraphNode { input: ViewScan(ViewScan { source_table: "brahmand.users_bench", view_filter: None, property_mapping: {"city": Column("city"), "is_active": Column("is_active"), "user_id": Column("user_id"), "email": Column("email_address"), "name": Column("full_name"), "registration_date": Column("registration_date"), "country": Column("country")}, id_column: "user_id", output_schema: ["id"], projections: [], from_id: None, to_id: None, input: None, view_parameter_names: None, view_parameter_values: None, use_final: false, is_denormalized: false, from_node_properties: None, to_node_properties: None, type_column: None, type_values: None, from_label_column: None, to_label_column: None, schema_filter: None }), alias: "u", label: Some("User"), is_denormalized: false, projected_columns: None }), predicate: PropertyAccessExp(PropertyAccess { table_alias: TableAlias("u"), column: Column("user_id") }) })
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::analyzer::type_inference] üè∑Ô∏è TypeInference: Starting type inference pass
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::analyzer::type_inference] üè∑Ô∏è TypeInference: Completed - plan transformed: false
FilterTagging: analyze_with_graph_schema called with plan: Filter(Filter { input: GraphNode(GraphNode { input: ViewScan(ViewScan { source_table: "brahmand.users_bench", view_filter: None, property_mapping: {"city": Column("city"), "is_active": Column("is_active"), "user_id": Column("user_id"), "email": Column("email_address"), "name": Column("full_name"), "registration_date": Column("registration_date"), "country": Column("country")}, id_column: "user_id", output_schema: ["id"], projections: [], from_id: None, to_id: None, input: None, view_parameter_names: None, view_parameter_values: None, use_final: false, is_denormalized: false, from_node_properties: None, to_node_properties: None, type_column: None, type_values: None, from_label_column: None, to_label_column: None, schema_filter: None }), alias: "u", label: Some("User"), is_denormalized: false, projected_columns: Some([("city", "u.city"), ("country", "u.country"), ("email", "u.email_address"), ("is_active", "u.is_active"), ("name", "u.full_name"), ("registration_date", "u.registration_date"), ("user_id", "u.user_id")]) }), predicate: PropertyAccessExp(PropertyAccess { table_alias: TableAlias("u"), column: Column("user_id") }) })
FilterTagging: analyze_with_graph_schema called with plan type: Discriminant(5)
FilterTagging: About to match on variant: Filter
FilterTagging: ENTERING Filter case - processing Filter node
FilterTagging: Processing Filter node with predicate: PropertyAccessExp(PropertyAccess { table_alias: TableAlias("u"), column: Column("user_id") })
FilterTagging: analyze_with_graph_schema called with plan: GraphNode(GraphNode { input: ViewScan(ViewScan { source_table: "brahmand.users_bench", view_filter: None, property_mapping: {"city": Column("city"), "is_active": Column("is_active"), "user_id": Column("user_id"), "email": Column("email_address"), "name": Column("full_name"), "registration_date": Column("registration_date"), "country": Column("country")}, id_column: "user_id", output_schema: ["id"], projections: [], from_id: None, to_id: None, input: None, view_parameter_names: None, view_parameter_values: None, use_final: false, is_denormalized: false, from_node_properties: None, to_node_properties: None, type_column: None, type_values: None, from_label_column: None, to_label_column: None, schema_filter: None }), alias: "u", label: Some("User"), is_denormalized: false, projected_columns: Some([("city", "u.city"), ("country", "u.country"), ("email", "u.email_address"), ("is_active", "u.is_active"), ("name", "u.full_name"), ("registration_date", "u.registration_date"), ("user_id", "u.user_id")]) })
FilterTagging: analyze_with_graph_schema called with plan type: Discriminant(3)
FilterTagging: About to match on variant: GraphNode
FilterTagging: analyze_with_graph_schema called with plan: ViewScan(ViewScan { source_table: "brahmand.users_bench", view_filter: None, property_mapping: {"city": Column("city"), "is_active": Column("is_active"), "user_id": Column("user_id"), "email": Column("email_address"), "name": Column("full_name"), "registration_date": Column("registration_date"), "country": Column("country")}, id_column: "user_id", output_schema: ["id"], projections: [], from_id: None, to_id: None, input: None, view_parameter_names: None, view_parameter_values: None, use_final: false, is_denormalized: false, from_node_properties: None, to_node_properties: None, type_column: None, type_values: None, from_label_column: None, to_label_column: None, schema_filter: None })
FilterTagging: analyze_with_graph_schema called with plan type: Discriminant(2)
FilterTagging: About to match on variant: ViewScan
FilterTagging: apply_property_mapping for alias 'u', property 'user_id'
FilterTagging: Found table_ctx, is_relation=false, label=Some("User")
FilterTagging: Checking is_denormalized for alias='u' - from_plan=false, from_ctx=false, from_edge=None, result=false
FilterTagging: is_denormalized=false for alias='u', property='user_id'
FilterTagging: About to call resolve_node_property, is_relation=false, label=User, property=user_id
FilterTagging: resolve_node_property result: Ok(Column("user_id"))
FilterTagging: Successfully mapped property 'user_id' to column 'user_id' (keeping original table alias 'u')
FilterTagging: Mapped predicate: PropertyAccessExp(PropertyAccess { table_alias: TableAlias("u"), column: Column("user_id") })
FilterTagging: extract_filters called with predicate: PropertyAccessExp(PropertyAccess { table_alias: TableAlias("u"), column: Column("user_id") })
FilterTagging: Extracted 0 filters, 0 projections, remaining: Some(PropertyAccessExp(PropertyAccess { table_alias: TableAlias("u"), column: Column("user_id") }))
FilterTagging: Final filter option: Some(PropertyAccessExp(PropertyAccess { table_alias: TableAlias("u"), column: Column("user_id") }))
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::optimizer::cartesian_join_extraction] üîç CartesianJoinExtraction: Processing Filter node
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::optimizer::cartesian_join_extraction] üîç CartesianJoinExtraction: Filter child is Discriminant(3)
GroupByBuilding: Processing Filter node
GroupByBuilding: Filter child analyzed, checking if it's GroupBy
GroupByBuilding: Filter child is NOT GroupBy (it's Discriminant(3))
üî• INITIAL_OPTIMIZATION CALLED üî•
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::optimizer::cartesian_join_extraction] üîç CartesianJoinExtraction: Processing Filter node
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::optimizer::cartesian_join_extraction] üîç CartesianJoinExtraction: Filter child is Discriminant(3)
üîç After CartesianJoinExtraction:
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::optimizer::filter_into_graph_rel] FilterIntoGraphRel: Processing GraphNode alias='u'
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::optimizer::filter_into_graph_rel] FilterIntoGraphRel: Found table_ctx for alias 'u', filters.len() = 0
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::analyzer] üîç ANALYZER: About to call VariableResolver.analyze()
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::analyzer::variable_resolver] üîç VariableResolver: Starting variable resolution
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::analyzer::variable_resolver] üîç VariableResolver: Completed - transformed: true
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::analyzer] üîç ANALYZER: VariableResolver.analyze() completed
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::analyzer] üîç ANALYZER: About to call CteReferencePopulator.analyze()
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::analyzer::cte_reference_populator] üîç CteReferencePopulator: Starting CTE reference population
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::analyzer::cte_reference_populator] üîç CteReferencePopulator: Completed - transformed: false
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::analyzer] üîç ANALYZER: CteReferencePopulator.analyze() completed
DEBUG GraphJoinInference: analyze_with_graph_schema called, plan type: Discriminant(5)
[2025-12-21T00:52:15Z INFO  clickgraph::query_planner::analyzer::graph_join_inference] üîç Captured 0 WITH clause CTE references

+- collect_graph_joins ENTER
ÔøΩ Plan variant: Discriminant(5)
ÔøΩ Joins before: 0, Entities: {}
ÔøΩ ? Filter, recursing into input

+- collect_graph_joins ENTER
ÔøΩ Plan variant: Discriminant(3)
ÔøΩ Joins before: 0, Entities: {}
üü¢ GraphNode(u), recursing into input

+- collect_graph_joins ENTER
ÔøΩ Plan variant: Discriminant(2)
ÔøΩ Joins before: 0, Entities: {}
ÔøΩ ? ViewScan, nothing to collect
+- collect_graph_joins EXIT
   Joins after: 0, Entities: {}

+- collect_graph_joins EXIT
   Joins after: 0, Entities: {}

+- collect_graph_joins EXIT
   Joins after: 0, Entities: {}

DEBUG GraphJoinInference: collected_graph_joins.len() = 0
DEBUG: to_render_plan called for plan type: Discriminant(5)
DEBUG: Trying try_build_join_based_plan
[2025-12-21T00:52:15Z INFO  clickgraph::render_plan::plan_builder] üöÄüöÄüöÄ Trying try_build_join_based_plan for query
DEBUG: try_build_join_based_plan called
DEBUG: self plan type = Discriminant(5)
DEBUG extract_distinct: Filter, recursing
DEBUG extract_distinct: Other variant, returning false
DEBUG extract_distinct: Returning false
DEBUG extract_distinct: Returning false
DEBUG: try_build_join_based_plan - extracted distinct: false
DEBUG: self is NOT Limit/OrderBy/Skip: Discriminant(5)
DEBUG: order_by_items present = false
DEBUG has_with_aggregation_pattern: No top-level GraphJoins found, returning false
DEBUG: contains_variable_length_path() = false
DEBUG has_with_aggregation_pattern: No top-level GraphJoins found, returning false
DEBUG: Calling build_simple_relationship_render_plan with distinct: false
DEBUG: build_simple_relationship_render_plan START - plan type: Discriminant(5)
DEBUG: build_simple_relationship_render_plan - extracted distinct (early): false
DEBUG: No unwrapping needed, plan type: Discriminant(5)
DEBUG: After unwrapping - core_plan type: Discriminant(5), has_order_by: false, has_limit: false, has_skip: false
DEBUG: core_plan is NOT Projection, discriminant: Discriminant(5)
DEBUG: extract_select_items called on: Filter(Filter { input: GraphNode(GraphNode { input: ViewScan(ViewScan { source_table: "brahmand.users_bench", view_filter: None, property_mapping: {"city": Column("city"), "is_active": Column("is_active"), "user_id": Column("user_id"), "email": Column("email_address"), "name": Column("full_name"), "registration_date": Column("registration_date"), "country": Column("country")}, id_column: "user_id", output_schema: ["id"], projections: [], from_id: None, to_id: None, input: None, view_parameter_names: None, view_parameter_values: None, use_final: false, is_denormalized: false, from_node_properties: None, to_node_properties: None, type_column: None, type_values: None, from_label_column: None, to_label_column: None, schema_filter: None }), alias: "u", label: Some("User"), is_denormalized: false, projected_columns: Some([("city", "u.city"), ("country", "u.country"), ("email", "u.email_address"), ("is_active", "u.is_active"), ("name", "u.full_name"), ("registration_date", "u.registration_date"), ("user_id", "u.user_id")]) }), predicate: PropertyAccessExp(PropertyAccess { table_alias: TableAlias("u"), column: Column("user_id") }) })
DEBUG: extract_select_items called on: GraphNode(GraphNode { input: ViewScan(ViewScan { source_table: "brahmand.users_bench", view_filter: None, property_mapping: {"city": Column("city"), "is_active": Column("is_active"), "user_id": Column("user_id"), "email": Column("email_address"), "name": Column("full_name"), "registration_date": Column("registration_date"), "country": Column("country")}, id_column: "user_id", output_schema: ["id"], projections: [], from_id: None, to_id: None, input: None, view_parameter_names: None, view_parameter_values: None, use_final: false, is_denormalized: false, from_node_properties: None, to_node_properties: None, type_column: None, type_values: None, from_label_column: None, to_label_column: None, schema_filter: None }), alias: "u", label: Some("User"), is_denormalized: false, projected_columns: Some([("city", "u.city"), ("country", "u.country"), ("email", "u.email_address"), ("is_active", "u.is_active"), ("name", "u.full_name"), ("registration_date", "u.registration_date"), ("user_id", "u.user_id")]) })
DEBUG: GraphNode.extract_from() - alias: u, input: ViewScan(ViewScan { source_table: "brahmand.users_bench", view_filter: None, property_mapping: {"city": Column("city"), "is_active": Column("is_active"), "user_id": Column("user_id"), "email": Column("email_address"), "name": Column("full_name"), "registration_date": Column("registration_date"), "country": Column("country")}, id_column: "user_id", output_schema: ["id"], projections: [], from_id: None, to_id: None, input: None, view_parameter_names: None, view_parameter_values: None, use_final: false, is_denormalized: false, from_node_properties: None, to_node_properties: None, type_column: None, type_values: None, from_label_column: None, to_label_column: None, schema_filter: None })
DEBUG: GraphNode.extract_from() - matched ViewScan, table: brahmand.users_bench
DEBUG: GraphNode.extract_from() - created ViewTableRef: ViewTableRef { source: ViewScan(ViewScan { source_table: "brahmand.users_bench", view_filter: None, property_mapping: {"city": Column("city"), "is_active": Column("is_active"), "user_id": Column("user_id"), "email": Column("email_address"), "name": Column("full_name"), "registration_date": Column("registration_date"), "country": Column("country")}, id_column: "user_id", output_schema: ["id"], projections: [], from_id: None, to_id: None, input: None, view_parameter_names: None, view_parameter_values: None, use_final: false, is_denormalized: false, from_node_properties: None, to_node_properties: None, type_column: None, type_values: None, from_label_column: None, to_label_column: None, schema_filter: None }), name: "brahmand.users_bench", alias: Some("u"), use_final: false }
DEBUG: build_simple_relationship_render_plan - final_from: Some(FromTable { table: Some(ViewTableRef { source: ViewScan(ViewScan { source_table: "brahmand.users_bench", view_filter: None, property_mapping: {"city": Column("city"), "is_active": Column("is_active"), "user_id": Column("user_id"), "email": Column("email_address"), "name": Column("full_name"), "registration_date": Column("registration_date"), "country": Column("country")}, id_column: "user_id", output_schema: ["id"], projections: [], from_id: None, to_id: None, input: None, view_parameter_names: None, view_parameter_values: None, use_final: false, is_denormalized: false, from_node_properties: None, to_node_properties: None, type_column: None, type_values: None, from_label_column: None, to_label_column: None, schema_filter: None }), name: "brahmand.users_bench", alias: Some("u"), use_final: false }), joins: [] })
DEBUG: extract_filters - Found Filter node with predicate: PropertyAccessExp(PropertyAccess { table_alias: TableAlias("u"), column: Column("user_id") })
DEBUG: extract_filters - Filter input type: Discriminant(3)
DEBUG TryFrom RenderExpr: Converting LogicalExpr discriminant=Discriminant(11)
DEBUG TryFrom RenderExpr: Successfully converted to discriminant=Discriminant(10)
[2025-12-21T00:52:15Z INFO  clickgraph::render_plan::plan_builder] üîç GraphNode 'u' extract_filters: ViewScan table=brahmand.users_bench
DEBUG: extract_filters - Returning Filter predicate only (no input filter)
DEBUG: build_simple_relationship_render_plan - final_filters: Some(PropertyAccessExp(PropertyAccess { table_alias: TableAlias("u"), column: Column(Column("user_id")) }))
DEBUG: build_simple_relationship_render_plan - extracted_joins: []
DEBUG: build_simple_relationship_render_plan - filtered_joins: []
üîç DEBUG sort_joins_by_dependency: Sorting 0 JOINs by dependency
  DEBUG FROM alias: u
  DEBUG Starting topological sort with 0 JOINs
  DEBUG Sorted order: []
DEBUG: build_simple_relationship_render_plan - sorted_joins: []
DEBUG: build_simple_relationship_render_plan - using pre-extracted distinct: false
DEBUG CTE EXTRACTION SHORT: About to extract CTEs from plan type Discriminant(5)
DEBUG extract_ctes_with_context: Processing Filter node
DEBUG TryFrom RenderExpr: Converting LogicalExpr discriminant=Discriminant(11)
DEBUG TryFrom RenderExpr: Successfully converted to discriminant=Discriminant(10)
DEBUG extract_ctes_with_context: Processing GraphNode node
DEBUG extract_ctes_with_context: Processing ViewScan node
DEBUG CTE EXTRACTION SHORT: Successfully extracted 0 CTEs
[2025-12-21T00:52:15Z INFO  clickgraph::render_plan::plan_builder] üîß GROUP BY: extract_group_by() called for plan type Discriminant(5)
[2025-12-21T00:52:15Z INFO  clickgraph::render_plan::plan_builder] üîß GROUP BY: extract_group_by() called for plan type Discriminant(3)
[2025-12-21T00:52:15Z INFO  clickgraph::render_plan::plan_builder] üîß GROUP BY: extract_group_by() called for plan type Discriminant(2)
DEBUG: try_build_join_based_plan succeeded
[2025-12-21T00:52:15Z INFO  clickgraph::render_plan::plan_builder] ‚úÖ try_build_join_based_plan SUCCEEDED - VLP endpoint JOIN code below will NOT run!

 ch_query 
 SELECT 
      u.city AS "u.city", 
      u.is_active AS "u.is_active", 
      u.user_id AS "u.user_id", 
      u.email_address AS "u.email", 
      u.full_name AS "u.name", 
      u.registration_date AS "u.registration_date", 
      u.country AS "u.country"
FROM brahmand.users_bench AS u
WHERE u.user_id
 

[2025-12-21T00:52:15Z ERROR clickgraph::server::handlers] ClickHouse response parsing failed. SQL was:
    SELECT 
          u.city AS "u.city", 
          u.is_active AS "u.is_active", 
          u.user_id AS "u.user_id", 
          u.email_address AS "u.email", 
          u.full_name AS "u.name", 
          u.registration_date AS "u.registration_date", 
          u.country AS "u.country"
    FROM brahmand.users_bench AS u
    WHERE u.user_id
    
    Error: bad response: {"exception": "Code: 59. DB::Exception: Illegal type UInt32 of column __table1.user_id for filter. Must be UInt8 or Nullable(UInt8). (ILLEGAL_TYPE_OF_COLUMN_FOR_FILTER) (version 25.8.11.66 (official build))"}
[2025-12-21T00:52:15Z INFO  clickgraph::server::handlers] Query performance - Total: 8.498ms, Parse: 0.067ms, Planning: 1.567ms, Render: 1.320ms, SQL Gen: 0.067ms, Exec: 4.795ms, Type: read, Queries: 1, Rows: N/A
